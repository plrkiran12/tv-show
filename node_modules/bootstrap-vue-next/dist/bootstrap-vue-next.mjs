var Sn = Object.defineProperty;
var Vn = (a, o, e) => o in a ? Sn(a, o, { enumerable: !0, configurable: !0, writable: !0, value: e }) : a[o] = e;
var He = (a, o, e) => (Vn(a, typeof o != "symbol" ? o + "" : o, e), e);
import { computed as _, toValue as Te, unref as n, ref as F, shallowRef as Vt, watch as fe, getCurrentScope as Ml, onScopeDispose as Dl, shallowReadonly as kt, isRef as An, toRef as k, readonly as Ye, customRef as On, onMounted as Ue, nextTick as Ie, getCurrentInstance as ht, reactive as cl, defineComponent as z, watchEffect as Nt, mergeModels as ye, useModel as _e, onBeforeUnmount as Da, openBlock as b, createElementBlock as O, Fragment as pe, createElementVNode as Q, renderSlot as $, createBlock as N, Teleport as Bt, mergeProps as K, normalizeClass as D, normalizeStyle as Le, createTextVNode as se, toDisplayString as J, createCommentVNode as te, render as jl, h as Pe, inject as Ve, provide as Xe, onActivated as Pn, Transition as Wl, withCtx as I, useAttrs as Mt, resolveDynamicComponent as ue, createVNode as be, useSlots as Re, normalizeProps as Be, guardReactiveProps as Ce, withDirectives as ct, vShow as Dt, renderList as ke, TransitionGroup as ql, withModifiers as bt, vModelCheckbox as Nn, vModelRadio as In, vModelSelect as En, createSlots as ja, onUnmounted as Fn, withKeys as Ut } from "vue";
const jt = (a) => _(() => {
  const o = Te(a);
  return o ? `justify-content-${o}` : "";
}), ma = (a, o) => _(() => {
  const e = Te(a), l = Te(o);
  return e === !0 ? "true" : typeof e == "string" ? e : l === !1 ? "true" : e === !1 ? "false" : void 0;
});
class rt {
  constructor(o, e = {}) {
    He(this, "cancelable", !0);
    He(this, "componentId", null);
    He(this, "_defaultPrevented", !1);
    He(this, "eventType", "");
    He(this, "nativeEvent", null);
    He(this, "_preventDefault");
    He(this, "relatedTarget", null);
    He(this, "target", null);
    if (!o)
      throw new TypeError(
        `Failed to construct '${this.constructor.name}'. 1 argument required, ${arguments.length} given.`
      );
    Object.assign(this, rt.Defaults, e, { eventType: o }), this._preventDefault = function() {
      this.cancelable && (this.defaultPrevented = !0);
    };
  }
  // Readable by everyone,
  // But only overwritten by inherrited constructors
  get defaultPrevented() {
    return this._defaultPrevented;
  }
  set defaultPrevented(o) {
    this._defaultPrevented = o;
  }
  // I think this is right
  // We want to be able to have it callable to everyone,
  // But only overwritten by inherrited constructors
  get preventDefault() {
    return this._preventDefault;
  }
  // This may not be correct, because it doesn't get correct type inferences in children
  // Ex overwrite this.preventDefault = () => true is valid. Could be a TS issue
  set preventDefault(o) {
    this._preventDefault = o;
  }
  static get Defaults() {
    return {
      cancelable: !0,
      componentId: null,
      eventType: "",
      nativeEvent: null,
      relatedTarget: null,
      target: null
    };
  }
}
class _t extends rt {
  constructor(e, l = {}) {
    super(e, l);
    He(this, "trigger", null);
    Object.assign(this, rt.Defaults, l, { eventType: e });
  }
  static get Defaults() {
    return {
      ...super.Defaults,
      trigger: null
    };
  }
}
class Gl extends rt {
  constructor(e, l) {
    super(e, l);
    He(this, "from");
    He(this, "to");
    He(this, "direction");
    Object.assign(this, rt.Defaults, l, { eventType: e });
    const { from: t, direction: s, to: i } = l;
    this.from = t, this.to = i, this.direction = s;
  }
  static get Defaults() {
    return {
      ...super.Defaults
    };
  }
}
const Ln = (a, o = {}) => {
  const e = (t = []) => {
    const { activeElement: s } = document;
    return s && !t.some((i) => i === s) ? s : null;
  }, l = (t) => t === e();
  try {
    a.focus(o);
  } catch (t) {
    console.error(t);
  }
  return l(a);
}, Ae = (a) => ((a == null ? void 0 : a()) ?? []).length === 0, zn = (a) => {
  if (a.getAttribute("display") === "none")
    return !1;
  const o = a.getBoundingClientRect();
  return !!(o && o.height > 0 && o.width > 0);
}, xa = (a) => {
  const o = window.getComputedStyle(a), e = o.transitionDelay.split(",")[0] || "", l = o.transitionDuration.split(",")[0] || "", t = Number(e.slice(0, -1)) * 1e3, s = Number(l.slice(0, -1)) * 1e3;
  return t + s;
}, Wa = typeof window < "u" && typeof document < "u" && typeof navigator < "u", Rn = (a) => (() => {
  let e = !1;
  if (Wa)
    try {
      const l = {
        // This function will be called when the browser
        // attempts to access the passive property
        get passive() {
          e = !0;
        }
      };
      WINDOW.addEventListener("test", l, l), WINDOW.removeEventListener("test", l, l);
    } catch {
      e = !1;
    }
  return e;
})() ? typeof a == "object" ? a : { capture: !!a || !1 } : typeof a == "object" ? a.capture : a, Hn = (a, o, e, l) => {
  a && a.addEventListener && a.addEventListener(o, e, Rn(l));
}, Mn = (a, o, e, l) => {
  a && a.removeEventListener && a.removeEventListener(o, e, l);
}, fl = (a, o) => {
  (a ? Hn : Mn)(...o);
}, Dn = ["TD", "TH", "TR"], jn = [
  "a",
  "a *",
  // Include content inside links
  "button",
  "button *",
  // Include content inside buttons
  "input:not(.disabled):not([disabled])",
  "select:not(.disabled):not([disabled])",
  "textarea:not(.disabled):not([disabled])",
  '[role="link"]',
  '[role="link"] *',
  '[role="button"]',
  '[role="button"] *',
  "[tabindex]:not(.disabled):not([disabled])"
].join(","), Xt = (a) => {
  if (!a || !a.target)
    return !1;
  const o = a.target;
  if ("disabled" in o && o.disabled || Dn.indexOf(o.tagName) !== -1)
    return !1;
  if (o.closest(".dropdown-menu"))
    return !0;
  const e = o.tagName === "LABEL" ? o : o.closest("label");
  if (e) {
    const l = e.getAttribute("for"), t = l ? document.getElementById(l) : e.querySelector("input, select, textarea");
    if (t && !t.disabled)
      return !0;
  }
  return o.matches(jn);
}, Ul = ["top", "right", "bottom", "left"], vl = ["start", "end"], pl = /* @__PURE__ */ Ul.reduce((a, o) => a.concat(o, o + "-" + vl[0], o + "-" + vl[1]), []), je = Math.min, Ne = Math.max, oa = Math.round, Kt = Math.floor, mt = (a) => ({
  x: a,
  y: a
}), Wn = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, qn = {
  start: "end",
  end: "start"
};
function Sa(a, o, e) {
  return Ne(a, je(o, e));
}
function ft(a, o) {
  return typeof a == "function" ? a(o) : a;
}
function Je(a) {
  return a.split("-")[0];
}
function lt(a) {
  return a.split("-")[1];
}
function Xl(a) {
  return a === "x" ? "y" : "x";
}
function qa(a) {
  return a === "y" ? "height" : "width";
}
function It(a) {
  return ["top", "bottom"].includes(Je(a)) ? "y" : "x";
}
function Ga(a) {
  return Xl(It(a));
}
function Kl(a, o, e) {
  e === void 0 && (e = !1);
  const l = lt(a), t = Ga(a), s = qa(t);
  let i = t === "x" ? l === (e ? "end" : "start") ? "right" : "left" : l === "start" ? "bottom" : "top";
  return o.reference[s] > o.floating[s] && (i = sa(i)), [i, sa(i)];
}
function Gn(a) {
  const o = sa(a);
  return [na(a), o, na(o)];
}
function na(a) {
  return a.replace(/start|end/g, (o) => qn[o]);
}
function Un(a, o, e) {
  const l = ["left", "right"], t = ["right", "left"], s = ["top", "bottom"], i = ["bottom", "top"];
  switch (a) {
    case "top":
    case "bottom":
      return e ? o ? t : l : o ? l : t;
    case "left":
    case "right":
      return o ? s : i;
    default:
      return [];
  }
}
function Xn(a, o, e, l) {
  const t = lt(a);
  let s = Un(Je(a), e === "start", l);
  return t && (s = s.map((i) => i + "-" + t), o && (s = s.concat(s.map(na)))), s;
}
function sa(a) {
  return a.replace(/left|right|bottom|top/g, (o) => Wn[o]);
}
function Kn(a) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...a
  };
}
function Ua(a) {
  return typeof a != "number" ? Kn(a) : {
    top: a,
    right: a,
    bottom: a,
    left: a
  };
}
function At(a) {
  return {
    ...a,
    top: a.y,
    left: a.x,
    right: a.x + a.width,
    bottom: a.y + a.height
  };
}
function ml(a, o, e) {
  let {
    reference: l,
    floating: t
  } = a;
  const s = It(o), i = Ga(o), u = qa(i), r = Je(o), d = s === "y", c = l.x + l.width / 2 - t.width / 2, f = l.y + l.height / 2 - t.height / 2, m = l[u] / 2 - t[u] / 2;
  let v;
  switch (r) {
    case "top":
      v = {
        x: c,
        y: l.y - t.height
      };
      break;
    case "bottom":
      v = {
        x: c,
        y: l.y + l.height
      };
      break;
    case "right":
      v = {
        x: l.x + l.width,
        y: f
      };
      break;
    case "left":
      v = {
        x: l.x - t.width,
        y: f
      };
      break;
    default:
      v = {
        x: l.x,
        y: l.y
      };
  }
  switch (lt(o)) {
    case "start":
      v[i] -= m * (e && d ? -1 : 1);
      break;
    case "end":
      v[i] += m * (e && d ? -1 : 1);
      break;
  }
  return v;
}
const Yn = async (a, o, e) => {
  const {
    placement: l = "bottom",
    strategy: t = "absolute",
    middleware: s = [],
    platform: i
  } = e, u = s.filter(Boolean), r = await (i.isRTL == null ? void 0 : i.isRTL(o));
  let d = await i.getElementRects({
    reference: a,
    floating: o,
    strategy: t
  }), {
    x: c,
    y: f
  } = ml(d, l, r), m = l, v = {}, y = 0;
  for (let h = 0; h < u.length; h++) {
    const {
      name: C,
      fn: p
    } = u[h], {
      x: B,
      y: g,
      data: S,
      reset: w
    } = await p({
      x: c,
      y: f,
      initialPlacement: l,
      placement: m,
      strategy: t,
      middlewareData: v,
      rects: d,
      platform: i,
      elements: {
        reference: a,
        floating: o
      }
    });
    c = B ?? c, f = g ?? f, v = {
      ...v,
      [C]: {
        ...v[C],
        ...S
      }
    }, w && y <= 50 && (y++, typeof w == "object" && (w.placement && (m = w.placement), w.rects && (d = w.rects === !0 ? await i.getElementRects({
      reference: a,
      floating: o,
      strategy: t
    }) : w.rects), {
      x: c,
      y: f
    } = ml(d, m, r)), h = -1);
  }
  return {
    x: c,
    y: f,
    placement: m,
    strategy: t,
    middlewareData: v
  };
};
async function Ot(a, o) {
  var e;
  o === void 0 && (o = {});
  const {
    x: l,
    y: t,
    platform: s,
    rects: i,
    elements: u,
    strategy: r
  } = a, {
    boundary: d = "clippingAncestors",
    rootBoundary: c = "viewport",
    elementContext: f = "floating",
    altBoundary: m = !1,
    padding: v = 0
  } = ft(o, a), y = Ua(v), C = u[m ? f === "floating" ? "reference" : "floating" : f], p = At(await s.getClippingRect({
    element: (e = await (s.isElement == null ? void 0 : s.isElement(C))) == null || e ? C : C.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(u.floating)),
    boundary: d,
    rootBoundary: c,
    strategy: r
  })), B = f === "floating" ? {
    x: l,
    y: t,
    width: i.floating.width,
    height: i.floating.height
  } : i.reference, g = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(u.floating)), S = await (s.isElement == null ? void 0 : s.isElement(g)) ? await (s.getScale == null ? void 0 : s.getScale(g)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, w = At(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: u,
    rect: B,
    offsetParent: g,
    strategy: r
  }) : B);
  return {
    top: (p.top - w.top + y.top) / S.y,
    bottom: (w.bottom - p.bottom + y.bottom) / S.y,
    left: (p.left - w.left + y.left) / S.x,
    right: (w.right - p.right + y.right) / S.x
  };
}
const Zn = (a) => ({
  name: "arrow",
  options: a,
  async fn(o) {
    const {
      x: e,
      y: l,
      placement: t,
      rects: s,
      platform: i,
      elements: u,
      middlewareData: r
    } = o, {
      element: d,
      padding: c = 0
    } = ft(a, o) || {};
    if (d == null)
      return {};
    const f = Ua(c), m = {
      x: e,
      y: l
    }, v = Ga(t), y = qa(v), h = await i.getDimensions(d), C = v === "y", p = C ? "top" : "left", B = C ? "bottom" : "right", g = C ? "clientHeight" : "clientWidth", S = s.reference[y] + s.reference[v] - m[v] - s.floating[y], w = m[v] - s.reference[v], x = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(d));
    let V = x ? x[g] : 0;
    (!V || !await (i.isElement == null ? void 0 : i.isElement(x))) && (V = u.floating[g] || s.floating[y]);
    const G = S / 2 - w / 2, W = V / 2 - h[y] / 2 - 1, P = je(f[p], W), Y = je(f[B], W), ae = P, ne = V - h[y] - Y, U = V / 2 - h[y] / 2 + G, T = Sa(ae, U, ne), A = !r.arrow && lt(t) != null && U !== T && s.reference[y] / 2 - (U < ae ? P : Y) - h[y] / 2 < 0, E = A ? U < ae ? U - ae : U - ne : 0;
    return {
      [v]: m[v] + E,
      data: {
        [v]: T,
        centerOffset: U - T - E,
        ...A && {
          alignmentOffset: E
        }
      },
      reset: A
    };
  }
});
function Jn(a, o, e) {
  return (a ? [...e.filter((t) => lt(t) === a), ...e.filter((t) => lt(t) !== a)] : e.filter((t) => Je(t) === t)).filter((t) => a ? lt(t) === a || (o ? na(t) !== t : !1) : !0);
}
const Qn = function(a) {
  return a === void 0 && (a = {}), {
    name: "autoPlacement",
    options: a,
    async fn(o) {
      var e, l, t;
      const {
        rects: s,
        middlewareData: i,
        placement: u,
        platform: r,
        elements: d
      } = o, {
        crossAxis: c = !1,
        alignment: f,
        allowedPlacements: m = pl,
        autoAlignment: v = !0,
        ...y
      } = ft(a, o), h = f !== void 0 || m === pl ? Jn(f || null, v, m) : m, C = await Ot(o, y), p = ((e = i.autoPlacement) == null ? void 0 : e.index) || 0, B = h[p];
      if (B == null)
        return {};
      const g = Kl(B, s, await (r.isRTL == null ? void 0 : r.isRTL(d.floating)));
      if (u !== B)
        return {
          reset: {
            placement: h[0]
          }
        };
      const S = [C[Je(B)], C[g[0]], C[g[1]]], w = [...((l = i.autoPlacement) == null ? void 0 : l.overflows) || [], {
        placement: B,
        overflows: S
      }], x = h[p + 1];
      if (x)
        return {
          data: {
            index: p + 1,
            overflows: w
          },
          reset: {
            placement: x
          }
        };
      const V = w.map((P) => {
        const Y = lt(P.placement);
        return [P.placement, Y && c ? (
          // Check along the mainAxis and main crossAxis side.
          P.overflows.slice(0, 2).reduce((ae, ne) => ae + ne, 0)
        ) : (
          // Check only the mainAxis.
          P.overflows[0]
        ), P.overflows];
      }).sort((P, Y) => P[1] - Y[1]), W = ((t = V.filter((P) => P[2].slice(
        0,
        // Aligned placements should not check their opposite crossAxis
        // side.
        lt(P[0]) ? 2 : 3
      ).every((Y) => Y <= 0))[0]) == null ? void 0 : t[0]) || V[0][0];
      return W !== u ? {
        data: {
          index: p + 1,
          overflows: w
        },
        reset: {
          placement: W
        }
      } : {};
    }
  };
}, es = function(a) {
  return a === void 0 && (a = {}), {
    name: "flip",
    options: a,
    async fn(o) {
      var e, l;
      const {
        placement: t,
        middlewareData: s,
        rects: i,
        initialPlacement: u,
        platform: r,
        elements: d
      } = o, {
        mainAxis: c = !0,
        crossAxis: f = !0,
        fallbackPlacements: m,
        fallbackStrategy: v = "bestFit",
        fallbackAxisSideDirection: y = "none",
        flipAlignment: h = !0,
        ...C
      } = ft(a, o);
      if ((e = s.arrow) != null && e.alignmentOffset)
        return {};
      const p = Je(t), B = Je(u) === u, g = await (r.isRTL == null ? void 0 : r.isRTL(d.floating)), S = m || (B || !h ? [sa(u)] : Gn(u));
      !m && y !== "none" && S.push(...Xn(u, h, y, g));
      const w = [u, ...S], x = await Ot(o, C), V = [];
      let G = ((l = s.flip) == null ? void 0 : l.overflows) || [];
      if (c && V.push(x[p]), f) {
        const ae = Kl(t, i, g);
        V.push(x[ae[0]], x[ae[1]]);
      }
      if (G = [...G, {
        placement: t,
        overflows: V
      }], !V.every((ae) => ae <= 0)) {
        var W, P;
        const ae = (((W = s.flip) == null ? void 0 : W.index) || 0) + 1, ne = w[ae];
        if (ne)
          return {
            data: {
              index: ae,
              overflows: G
            },
            reset: {
              placement: ne
            }
          };
        let U = (P = G.filter((T) => T.overflows[0] <= 0).sort((T, A) => T.overflows[1] - A.overflows[1])[0]) == null ? void 0 : P.placement;
        if (!U)
          switch (v) {
            case "bestFit": {
              var Y;
              const T = (Y = G.map((A) => [A.placement, A.overflows.filter((E) => E > 0).reduce((E, M) => E + M, 0)]).sort((A, E) => A[1] - E[1])[0]) == null ? void 0 : Y[0];
              T && (U = T);
              break;
            }
            case "initialPlacement":
              U = u;
              break;
          }
        if (t !== U)
          return {
            reset: {
              placement: U
            }
          };
      }
      return {};
    }
  };
};
function bl(a, o) {
  return {
    top: a.top - o.height,
    right: a.right - o.width,
    bottom: a.bottom - o.height,
    left: a.left - o.width
  };
}
function yl(a) {
  return Ul.some((o) => a[o] >= 0);
}
const ts = function(a) {
  return a === void 0 && (a = {}), {
    name: "hide",
    options: a,
    async fn(o) {
      const {
        rects: e
      } = o, {
        strategy: l = "referenceHidden",
        ...t
      } = ft(a, o);
      switch (l) {
        case "referenceHidden": {
          const s = await Ot(o, {
            ...t,
            elementContext: "reference"
          }), i = bl(s, e.reference);
          return {
            data: {
              referenceHiddenOffsets: i,
              referenceHidden: yl(i)
            }
          };
        }
        case "escaped": {
          const s = await Ot(o, {
            ...t,
            altBoundary: !0
          }), i = bl(s, e.floating);
          return {
            data: {
              escapedOffsets: i,
              escaped: yl(i)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
function Yl(a) {
  const o = je(...a.map((s) => s.left)), e = je(...a.map((s) => s.top)), l = Ne(...a.map((s) => s.right)), t = Ne(...a.map((s) => s.bottom));
  return {
    x: o,
    y: e,
    width: l - o,
    height: t - e
  };
}
function as(a) {
  const o = a.slice().sort((t, s) => t.y - s.y), e = [];
  let l = null;
  for (let t = 0; t < o.length; t++) {
    const s = o[t];
    !l || s.y - l.y > l.height / 2 ? e.push([s]) : e[e.length - 1].push(s), l = s;
  }
  return e.map((t) => At(Yl(t)));
}
const ls = function(a) {
  return a === void 0 && (a = {}), {
    name: "inline",
    options: a,
    async fn(o) {
      const {
        placement: e,
        elements: l,
        rects: t,
        platform: s,
        strategy: i
      } = o, {
        padding: u = 2,
        x: r,
        y: d
      } = ft(a, o), c = Array.from(await (s.getClientRects == null ? void 0 : s.getClientRects(l.reference)) || []), f = as(c), m = At(Yl(c)), v = Ua(u);
      function y() {
        if (f.length === 2 && f[0].left > f[1].right && r != null && d != null)
          return f.find((C) => r > C.left - v.left && r < C.right + v.right && d > C.top - v.top && d < C.bottom + v.bottom) || m;
        if (f.length >= 2) {
          if (It(e) === "y") {
            const P = f[0], Y = f[f.length - 1], ae = Je(e) === "top", ne = P.top, U = Y.bottom, T = ae ? P.left : Y.left, A = ae ? P.right : Y.right, E = A - T, M = U - ne;
            return {
              top: ne,
              bottom: U,
              left: T,
              right: A,
              width: E,
              height: M,
              x: T,
              y: ne
            };
          }
          const C = Je(e) === "left", p = Ne(...f.map((P) => P.right)), B = je(...f.map((P) => P.left)), g = f.filter((P) => C ? P.left === B : P.right === p), S = g[0].top, w = g[g.length - 1].bottom, x = B, V = p, G = V - x, W = w - S;
          return {
            top: S,
            bottom: w,
            left: x,
            right: V,
            width: G,
            height: W,
            x,
            y: S
          };
        }
        return m;
      }
      const h = await s.getElementRects({
        reference: {
          getBoundingClientRect: y
        },
        floating: l.floating,
        strategy: i
      });
      return t.reference.x !== h.reference.x || t.reference.y !== h.reference.y || t.reference.width !== h.reference.width || t.reference.height !== h.reference.height ? {
        reset: {
          rects: h
        }
      } : {};
    }
  };
};
async function os(a, o) {
  const {
    placement: e,
    platform: l,
    elements: t
  } = a, s = await (l.isRTL == null ? void 0 : l.isRTL(t.floating)), i = Je(e), u = lt(e), r = It(e) === "y", d = ["left", "top"].includes(i) ? -1 : 1, c = s && r ? -1 : 1, f = ft(o, a);
  let {
    mainAxis: m,
    crossAxis: v,
    alignmentAxis: y
  } = typeof f == "number" ? {
    mainAxis: f,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...f
  };
  return u && typeof y == "number" && (v = u === "end" ? y * -1 : y), r ? {
    x: v * c,
    y: m * d
  } : {
    x: m * d,
    y: v * c
  };
}
const Zl = function(a) {
  return a === void 0 && (a = 0), {
    name: "offset",
    options: a,
    async fn(o) {
      var e, l;
      const {
        x: t,
        y: s,
        placement: i,
        middlewareData: u
      } = o, r = await os(o, a);
      return i === ((e = u.offset) == null ? void 0 : e.placement) && (l = u.arrow) != null && l.alignmentOffset ? {} : {
        x: t + r.x,
        y: s + r.y,
        data: {
          ...r,
          placement: i
        }
      };
    }
  };
}, ns = function(a) {
  return a === void 0 && (a = {}), {
    name: "shift",
    options: a,
    async fn(o) {
      const {
        x: e,
        y: l,
        placement: t
      } = o, {
        mainAxis: s = !0,
        crossAxis: i = !1,
        limiter: u = {
          fn: (C) => {
            let {
              x: p,
              y: B
            } = C;
            return {
              x: p,
              y: B
            };
          }
        },
        ...r
      } = ft(a, o), d = {
        x: e,
        y: l
      }, c = await Ot(o, r), f = It(Je(t)), m = Xl(f);
      let v = d[m], y = d[f];
      if (s) {
        const C = m === "y" ? "top" : "left", p = m === "y" ? "bottom" : "right", B = v + c[C], g = v - c[p];
        v = Sa(B, v, g);
      }
      if (i) {
        const C = f === "y" ? "top" : "left", p = f === "y" ? "bottom" : "right", B = y + c[C], g = y - c[p];
        y = Sa(B, y, g);
      }
      const h = u.fn({
        ...o,
        [m]: v,
        [f]: y
      });
      return {
        ...h,
        data: {
          x: h.x - e,
          y: h.y - l
        }
      };
    }
  };
}, ss = function(a) {
  return a === void 0 && (a = {}), {
    name: "size",
    options: a,
    async fn(o) {
      const {
        placement: e,
        rects: l,
        platform: t,
        elements: s
      } = o, {
        apply: i = () => {
        },
        ...u
      } = ft(a, o), r = await Ot(o, u), d = Je(e), c = lt(e), f = It(e) === "y", {
        width: m,
        height: v
      } = l.floating;
      let y, h;
      d === "top" || d === "bottom" ? (y = d, h = c === (await (t.isRTL == null ? void 0 : t.isRTL(s.floating)) ? "start" : "end") ? "left" : "right") : (h = d, y = c === "end" ? "top" : "bottom");
      const C = v - r.top - r.bottom, p = m - r.left - r.right, B = je(v - r[y], C), g = je(m - r[h], p), S = !o.middlewareData.shift;
      let w = B, x = g;
      if (f ? x = c || S ? je(g, p) : p : w = c || S ? je(B, C) : C, S && !c) {
        const G = Ne(r.left, 0), W = Ne(r.right, 0), P = Ne(r.top, 0), Y = Ne(r.bottom, 0);
        f ? x = m - 2 * (G !== 0 || W !== 0 ? G + W : Ne(r.left, r.right)) : w = v - 2 * (P !== 0 || Y !== 0 ? P + Y : Ne(r.top, r.bottom));
      }
      await i({
        ...o,
        availableWidth: x,
        availableHeight: w
      });
      const V = await t.getDimensions(s.floating);
      return m !== V.width || v !== V.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function it(a) {
  return Xa(a) ? (a.nodeName || "").toLowerCase() : "#document";
}
function qe(a) {
  var o;
  return (a == null || (o = a.ownerDocument) == null ? void 0 : o.defaultView) || window;
}
function vt(a) {
  var o;
  return (o = (Xa(a) ? a.ownerDocument : a.document) || window.document) == null ? void 0 : o.documentElement;
}
function Xa(a) {
  return a instanceof Node || a instanceof qe(a).Node;
}
function ut(a) {
  return a instanceof Element || a instanceof qe(a).Element;
}
function nt(a) {
  return a instanceof HTMLElement || a instanceof qe(a).HTMLElement;
}
function gl(a) {
  return typeof ShadowRoot > "u" ? !1 : a instanceof ShadowRoot || a instanceof qe(a).ShadowRoot;
}
function Wt(a) {
  const {
    overflow: o,
    overflowX: e,
    overflowY: l,
    display: t
  } = Qe(a);
  return /auto|scroll|overlay|hidden|clip/.test(o + l + e) && !["inline", "contents"].includes(t);
}
function rs(a) {
  return ["table", "td", "th"].includes(it(a));
}
function Ka(a) {
  const o = Ya(), e = Qe(a);
  return e.transform !== "none" || e.perspective !== "none" || (e.containerType ? e.containerType !== "normal" : !1) || !o && (e.backdropFilter ? e.backdropFilter !== "none" : !1) || !o && (e.filter ? e.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((l) => (e.willChange || "").includes(l)) || ["paint", "layout", "strict", "content"].some((l) => (e.contain || "").includes(l));
}
function is(a) {
  let o = Pt(a);
  for (; nt(o) && !ba(o); ) {
    if (Ka(o))
      return o;
    o = Pt(o);
  }
  return null;
}
function Ya() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function ba(a) {
  return ["html", "body", "#document"].includes(it(a));
}
function Qe(a) {
  return qe(a).getComputedStyle(a);
}
function ya(a) {
  return ut(a) ? {
    scrollLeft: a.scrollLeft,
    scrollTop: a.scrollTop
  } : {
    scrollLeft: a.pageXOffset,
    scrollTop: a.pageYOffset
  };
}
function Pt(a) {
  if (it(a) === "html")
    return a;
  const o = (
    // Step into the shadow DOM of the parent of a slotted node.
    a.assignedSlot || // DOM Element detected.
    a.parentNode || // ShadowRoot detected.
    gl(a) && a.host || // Fallback.
    vt(a)
  );
  return gl(o) ? o.host : o;
}
function Jl(a) {
  const o = Pt(a);
  return ba(o) ? a.ownerDocument ? a.ownerDocument.body : a.body : nt(o) && Wt(o) ? o : Jl(o);
}
function Rt(a, o, e) {
  var l;
  o === void 0 && (o = []), e === void 0 && (e = !0);
  const t = Jl(a), s = t === ((l = a.ownerDocument) == null ? void 0 : l.body), i = qe(t);
  return s ? o.concat(i, i.visualViewport || [], Wt(t) ? t : [], i.frameElement && e ? Rt(i.frameElement) : []) : o.concat(t, Rt(t, [], e));
}
function Ql(a) {
  const o = Qe(a);
  let e = parseFloat(o.width) || 0, l = parseFloat(o.height) || 0;
  const t = nt(a), s = t ? a.offsetWidth : e, i = t ? a.offsetHeight : l, u = oa(e) !== s || oa(l) !== i;
  return u && (e = s, l = i), {
    width: e,
    height: l,
    $: u
  };
}
function Za(a) {
  return ut(a) ? a : a.contextElement;
}
function St(a) {
  const o = Za(a);
  if (!nt(o))
    return mt(1);
  const e = o.getBoundingClientRect(), {
    width: l,
    height: t,
    $: s
  } = Ql(o);
  let i = (s ? oa(e.width) : e.width) / l, u = (s ? oa(e.height) : e.height) / t;
  return (!i || !Number.isFinite(i)) && (i = 1), (!u || !Number.isFinite(u)) && (u = 1), {
    x: i,
    y: u
  };
}
const us = /* @__PURE__ */ mt(0);
function eo(a) {
  const o = qe(a);
  return !Ya() || !o.visualViewport ? us : {
    x: o.visualViewport.offsetLeft,
    y: o.visualViewport.offsetTop
  };
}
function ds(a, o, e) {
  return o === void 0 && (o = !1), !e || o && e !== qe(a) ? !1 : o;
}
function gt(a, o, e, l) {
  o === void 0 && (o = !1), e === void 0 && (e = !1);
  const t = a.getBoundingClientRect(), s = Za(a);
  let i = mt(1);
  o && (l ? ut(l) && (i = St(l)) : i = St(a));
  const u = ds(s, e, l) ? eo(s) : mt(0);
  let r = (t.left + u.x) / i.x, d = (t.top + u.y) / i.y, c = t.width / i.x, f = t.height / i.y;
  if (s) {
    const m = qe(s), v = l && ut(l) ? qe(l) : l;
    let y = m, h = y.frameElement;
    for (; h && l && v !== y; ) {
      const C = St(h), p = h.getBoundingClientRect(), B = Qe(h), g = p.left + (h.clientLeft + parseFloat(B.paddingLeft)) * C.x, S = p.top + (h.clientTop + parseFloat(B.paddingTop)) * C.y;
      r *= C.x, d *= C.y, c *= C.x, f *= C.y, r += g, d += S, y = qe(h), h = y.frameElement;
    }
  }
  return At({
    width: c,
    height: f,
    x: r,
    y: d
  });
}
const cs = [":popover-open", ":modal"];
function to(a) {
  return cs.some((o) => {
    try {
      return a.matches(o);
    } catch {
      return !1;
    }
  });
}
function fs(a) {
  let {
    elements: o,
    rect: e,
    offsetParent: l,
    strategy: t
  } = a;
  const s = t === "fixed", i = vt(l), u = o ? to(o.floating) : !1;
  if (l === i || u && s)
    return e;
  let r = {
    scrollLeft: 0,
    scrollTop: 0
  }, d = mt(1);
  const c = mt(0), f = nt(l);
  if ((f || !f && !s) && ((it(l) !== "body" || Wt(i)) && (r = ya(l)), nt(l))) {
    const m = gt(l);
    d = St(l), c.x = m.x + l.clientLeft, c.y = m.y + l.clientTop;
  }
  return {
    width: e.width * d.x,
    height: e.height * d.y,
    x: e.x * d.x - r.scrollLeft * d.x + c.x,
    y: e.y * d.y - r.scrollTop * d.y + c.y
  };
}
function vs(a) {
  return Array.from(a.getClientRects());
}
function ao(a) {
  return gt(vt(a)).left + ya(a).scrollLeft;
}
function ps(a) {
  const o = vt(a), e = ya(a), l = a.ownerDocument.body, t = Ne(o.scrollWidth, o.clientWidth, l.scrollWidth, l.clientWidth), s = Ne(o.scrollHeight, o.clientHeight, l.scrollHeight, l.clientHeight);
  let i = -e.scrollLeft + ao(a);
  const u = -e.scrollTop;
  return Qe(l).direction === "rtl" && (i += Ne(o.clientWidth, l.clientWidth) - t), {
    width: t,
    height: s,
    x: i,
    y: u
  };
}
function ms(a, o) {
  const e = qe(a), l = vt(a), t = e.visualViewport;
  let s = l.clientWidth, i = l.clientHeight, u = 0, r = 0;
  if (t) {
    s = t.width, i = t.height;
    const d = Ya();
    (!d || d && o === "fixed") && (u = t.offsetLeft, r = t.offsetTop);
  }
  return {
    width: s,
    height: i,
    x: u,
    y: r
  };
}
function bs(a, o) {
  const e = gt(a, !0, o === "fixed"), l = e.top + a.clientTop, t = e.left + a.clientLeft, s = nt(a) ? St(a) : mt(1), i = a.clientWidth * s.x, u = a.clientHeight * s.y, r = t * s.x, d = l * s.y;
  return {
    width: i,
    height: u,
    x: r,
    y: d
  };
}
function hl(a, o, e) {
  let l;
  if (o === "viewport")
    l = ms(a, e);
  else if (o === "document")
    l = ps(vt(a));
  else if (ut(o))
    l = bs(o, e);
  else {
    const t = eo(a);
    l = {
      ...o,
      x: o.x - t.x,
      y: o.y - t.y
    };
  }
  return At(l);
}
function lo(a, o) {
  const e = Pt(a);
  return e === o || !ut(e) || ba(e) ? !1 : Qe(e).position === "fixed" || lo(e, o);
}
function ys(a, o) {
  const e = o.get(a);
  if (e)
    return e;
  let l = Rt(a, [], !1).filter((u) => ut(u) && it(u) !== "body"), t = null;
  const s = Qe(a).position === "fixed";
  let i = s ? Pt(a) : a;
  for (; ut(i) && !ba(i); ) {
    const u = Qe(i), r = Ka(i);
    !r && u.position === "fixed" && (t = null), (s ? !r && !t : !r && u.position === "static" && !!t && ["absolute", "fixed"].includes(t.position) || Wt(i) && !r && lo(a, i)) ? l = l.filter((c) => c !== i) : t = u, i = Pt(i);
  }
  return o.set(a, l), l;
}
function gs(a) {
  let {
    element: o,
    boundary: e,
    rootBoundary: l,
    strategy: t
  } = a;
  const i = [...e === "clippingAncestors" ? ys(o, this._c) : [].concat(e), l], u = i[0], r = i.reduce((d, c) => {
    const f = hl(o, c, t);
    return d.top = Ne(f.top, d.top), d.right = je(f.right, d.right), d.bottom = je(f.bottom, d.bottom), d.left = Ne(f.left, d.left), d;
  }, hl(o, u, t));
  return {
    width: r.right - r.left,
    height: r.bottom - r.top,
    x: r.left,
    y: r.top
  };
}
function hs(a) {
  const {
    width: o,
    height: e
  } = Ql(a);
  return {
    width: o,
    height: e
  };
}
function Bs(a, o, e) {
  const l = nt(o), t = vt(o), s = e === "fixed", i = gt(a, !0, s, o);
  let u = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const r = mt(0);
  if (l || !l && !s)
    if ((it(o) !== "body" || Wt(t)) && (u = ya(o)), l) {
      const f = gt(o, !0, s, o);
      r.x = f.x + o.clientLeft, r.y = f.y + o.clientTop;
    } else
      t && (r.x = ao(t));
  const d = i.left + u.scrollLeft - r.x, c = i.top + u.scrollTop - r.y;
  return {
    x: d,
    y: c,
    width: i.width,
    height: i.height
  };
}
function Bl(a, o) {
  return !nt(a) || Qe(a).position === "fixed" ? null : o ? o(a) : a.offsetParent;
}
function oo(a, o) {
  const e = qe(a);
  if (!nt(a) || to(a))
    return e;
  let l = Bl(a, o);
  for (; l && rs(l) && Qe(l).position === "static"; )
    l = Bl(l, o);
  return l && (it(l) === "html" || it(l) === "body" && Qe(l).position === "static" && !Ka(l)) ? e : l || is(a) || e;
}
const _s = async function(a) {
  const o = this.getOffsetParent || oo, e = this.getDimensions;
  return {
    reference: Bs(a.reference, await o(a.floating), a.strategy),
    floating: {
      x: 0,
      y: 0,
      ...await e(a.floating)
    }
  };
};
function ws(a) {
  return Qe(a).direction === "rtl";
}
const Cs = {
  convertOffsetParentRelativeRectToViewportRelativeRect: fs,
  getDocumentElement: vt,
  getClippingRect: gs,
  getOffsetParent: oo,
  getElementRects: _s,
  getClientRects: vs,
  getDimensions: hs,
  getScale: St,
  isElement: ut,
  isRTL: ws
};
function ks(a, o) {
  let e = null, l;
  const t = vt(a);
  function s() {
    var u;
    clearTimeout(l), (u = e) == null || u.disconnect(), e = null;
  }
  function i(u, r) {
    u === void 0 && (u = !1), r === void 0 && (r = 1), s();
    const {
      left: d,
      top: c,
      width: f,
      height: m
    } = a.getBoundingClientRect();
    if (u || o(), !f || !m)
      return;
    const v = Kt(c), y = Kt(t.clientWidth - (d + f)), h = Kt(t.clientHeight - (c + m)), C = Kt(d), B = {
      rootMargin: -v + "px " + -y + "px " + -h + "px " + -C + "px",
      threshold: Ne(0, je(1, r)) || 1
    };
    let g = !0;
    function S(w) {
      const x = w[0].intersectionRatio;
      if (x !== r) {
        if (!g)
          return i();
        x ? i(!1, x) : l = setTimeout(() => {
          i(!1, 1e-7);
        }, 100);
      }
      g = !1;
    }
    try {
      e = new IntersectionObserver(S, {
        ...B,
        // Handle <iframe>s
        root: t.ownerDocument
      });
    } catch {
      e = new IntersectionObserver(S, B);
    }
    e.observe(a);
  }
  return i(!0), s;
}
function no(a, o, e, l) {
  l === void 0 && (l = {});
  const {
    ancestorScroll: t = !0,
    ancestorResize: s = !0,
    elementResize: i = typeof ResizeObserver == "function",
    layoutShift: u = typeof IntersectionObserver == "function",
    animationFrame: r = !1
  } = l, d = Za(a), c = t || s ? [...d ? Rt(d) : [], ...Rt(o)] : [];
  c.forEach((p) => {
    t && p.addEventListener("scroll", e, {
      passive: !0
    }), s && p.addEventListener("resize", e);
  });
  const f = d && u ? ks(d, e) : null;
  let m = -1, v = null;
  i && (v = new ResizeObserver((p) => {
    let [B] = p;
    B && B.target === d && v && (v.unobserve(o), cancelAnimationFrame(m), m = requestAnimationFrame(() => {
      var g;
      (g = v) == null || g.observe(o);
    })), e();
  }), d && !r && v.observe(d), v.observe(o));
  let y, h = r ? gt(a) : null;
  r && C();
  function C() {
    const p = gt(a);
    h && (p.x !== h.x || p.y !== h.y || p.width !== h.width || p.height !== h.height) && e(), h = p, y = requestAnimationFrame(C);
  }
  return e(), () => {
    var p;
    c.forEach((B) => {
      t && B.removeEventListener("scroll", e), s && B.removeEventListener("resize", e);
    }), f == null || f(), (p = v) == null || p.disconnect(), v = null, r && cancelAnimationFrame(y);
  };
}
const Ts = Qn, so = ns, ro = es, io = ss, $s = ts, xs = Zn, Ss = ls, Vs = (a, o, e) => {
  const l = /* @__PURE__ */ new Map(), t = {
    platform: Cs,
    ...e
  }, s = {
    ...t.platform,
    _c: l
  };
  return Yn(a, o, {
    ...t,
    platform: s
  });
};
function As(a) {
  return a != null && typeof a == "object" && "$el" in a;
}
function Va(a) {
  if (As(a)) {
    const o = a.$el;
    return Xa(o) && it(o) === "#comment" ? null : o;
  }
  return a;
}
function Os(a) {
  return {
    name: "arrow",
    options: a,
    fn(o) {
      const e = Va(n(a.element));
      return e == null ? {} : xs({
        element: e,
        padding: a.padding
      }).fn(o);
    }
  };
}
function uo(a) {
  return typeof window > "u" ? 1 : (a.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function _l(a, o) {
  const e = uo(a);
  return Math.round(o * e) / e;
}
function co(a, o, e) {
  e === void 0 && (e = {});
  const l = e.whileElementsMounted, t = _(() => {
    var V;
    return (V = n(e.open)) != null ? V : !0;
  }), s = _(() => n(e.middleware)), i = _(() => {
    var V;
    return (V = n(e.placement)) != null ? V : "bottom";
  }), u = _(() => {
    var V;
    return (V = n(e.strategy)) != null ? V : "absolute";
  }), r = _(() => {
    var V;
    return (V = n(e.transform)) != null ? V : !0;
  }), d = _(() => Va(a.value)), c = _(() => Va(o.value)), f = F(0), m = F(0), v = F(u.value), y = F(i.value), h = Vt({}), C = F(!1), p = _(() => {
    const V = {
      position: v.value,
      left: "0",
      top: "0"
    };
    if (!c.value)
      return V;
    const G = _l(c.value, f.value), W = _l(c.value, m.value);
    return r.value ? {
      ...V,
      transform: "translate(" + G + "px, " + W + "px)",
      ...uo(c.value) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: v.value,
      left: G + "px",
      top: W + "px"
    };
  });
  let B;
  function g() {
    d.value == null || c.value == null || Vs(d.value, c.value, {
      middleware: s.value,
      placement: i.value,
      strategy: u.value
    }).then((V) => {
      f.value = V.x, m.value = V.y, v.value = V.strategy, y.value = V.placement, h.value = V.middlewareData, C.value = !0;
    });
  }
  function S() {
    typeof B == "function" && (B(), B = void 0);
  }
  function w() {
    if (S(), l === void 0) {
      g();
      return;
    }
    if (d.value != null && c.value != null) {
      B = l(d.value, c.value, g);
      return;
    }
  }
  function x() {
    t.value || (C.value = !1);
  }
  return fe([s, i, u], g, {
    flush: "sync"
  }), fe([d, c], w, {
    flush: "sync"
  }), fe(t, x, {
    flush: "sync"
  }), Ml() && Dl(S), {
    x: kt(f),
    y: kt(m),
    strategy: kt(v),
    placement: kt(y),
    middlewareData: kt(h),
    isPositioned: kt(C),
    floatingStyles: p,
    update: g
  };
}
const Ps = /* @__PURE__ */ new Set([
  "background",
  "cite",
  "href",
  "itemtype",
  "longdesc",
  "poster",
  "src",
  "xlink:href"
]), Ns = /^aria-[\w-]*$/i, Is = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i, Es = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i, Fs = (a, o) => {
  const e = a.nodeName.toLowerCase();
  return o.includes(e) ? Ps.has(e) ? !!(Is.test(a.nodeValue || "") || Es.test(a.nodeValue || "")) : !0 : o.filter((l) => l instanceof RegExp).some((l) => l.test(e));
}, Tt = {
  // Global attributes allowed on any supplied element below.
  "*": ["class", "dir", "id", "lang", "role", Ns],
  a: ["target", "href", "title", "rel"],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  div: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ["src", "srcset", "alt", "title", "width", "height"],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
}, $t = (a, o, e) => {
  if (!a.length)
    return a;
  if (e && typeof e == "function")
    return e(a);
  const t = new window.DOMParser().parseFromString(a, "text/html"), s = t.body.querySelectorAll("*");
  for (const i of s) {
    const u = i.nodeName.toLowerCase();
    if (!Object.keys(o).includes(u)) {
      i.remove();
      continue;
    }
    const r = i.attributes, d = [...o["*"] || [], ...o[u] || []];
    for (const c of r)
      Fs(c, d) || i.removeAttribute(c.nodeName);
  }
  return t.body.innerHTML;
};
function dt(a) {
  return Ml() ? (Dl(a), !0) : !1;
}
function Ls(a, o) {
  if (typeof Symbol < "u") {
    const e = { ...a };
    return Object.defineProperty(e, Symbol.iterator, {
      enumerable: !1,
      value() {
        let l = 0;
        return {
          next: () => ({
            value: o[l++],
            done: l > o.length
          })
        };
      }
    }), e;
  } else
    return Object.assign([...o], a);
}
function ze(a) {
  return typeof a == "function" ? a() : n(a);
}
const ra = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const fo = (a) => a != null, zs = Object.prototype.toString, Rs = (a) => zs.call(a) === "[object Object]", Ze = () => {
}, Aa = /* @__PURE__ */ Hs();
function Hs() {
  var a, o;
  return ra && ((a = window == null ? void 0 : window.navigator) == null ? void 0 : a.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((o = window == null ? void 0 : window.navigator) == null ? void 0 : o.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function vo(a, o) {
  function e(...l) {
    return new Promise((t, s) => {
      Promise.resolve(a(() => o.apply(this, l), { fn: o, thisArg: this, args: l })).then(t).catch(s);
    });
  }
  return e;
}
const po = (a) => a();
function Ms(a, o = {}) {
  let e, l, t = Ze;
  const s = (u) => {
    clearTimeout(u), t(), t = Ze;
  };
  return (u) => {
    const r = ze(a), d = ze(o.maxWait);
    return e && s(e), r <= 0 || d !== void 0 && d <= 0 ? (l && (s(l), l = null), Promise.resolve(u())) : new Promise((c, f) => {
      t = o.rejectOnCancel ? f : c, d && !l && (l = setTimeout(() => {
        e && s(e), l = null, c(u());
      }, d)), e = setTimeout(() => {
        l && s(l), l = null, c(u());
      }, r);
    });
  };
}
function Ds(a = po) {
  const o = F(!0);
  function e() {
    o.value = !1;
  }
  function l() {
    o.value = !0;
  }
  const t = (...s) => {
    o.value && a(...s);
  };
  return { isActive: Ye(o), pause: e, resume: l, eventFilter: t };
}
function js(a) {
  const o = /* @__PURE__ */ Object.create(null);
  return (e) => o[e] || (o[e] = a(e));
}
const Ws = /-(\w)/g, qs = js((a) => a.replace(Ws, (o, e) => e ? e.toUpperCase() : ""));
function Gs(a) {
  return a || ht();
}
function mo(...a) {
  if (a.length !== 1)
    return k(...a);
  const o = a[0];
  return typeof o == "function" ? Ye(On(() => ({ get: o, set: Ze }))) : F(o);
}
function Us(a, o = 200, e = {}) {
  return vo(
    Ms(o, e),
    a
  );
}
function Xs(a, o, e = {}) {
  const {
    eventFilter: l = po,
    ...t
  } = e;
  return fe(
    a,
    vo(
      l,
      o
    ),
    t
  );
}
function Oa(a, o, e = {}) {
  const {
    eventFilter: l,
    ...t
  } = e, { eventFilter: s, pause: i, resume: u, isActive: r } = Ds(l);
  return { stop: Xs(
    a,
    o,
    {
      ...t,
      eventFilter: s
    }
  ), pause: i, resume: u, isActive: r };
}
function Pa(a, o, ...[e]) {
  const {
    flush: l = "sync",
    deep: t = !1,
    immediate: s = !0,
    direction: i = "both",
    transform: u = {}
  } = e || {}, r = [], d = "ltr" in u && u.ltr || ((m) => m), c = "rtl" in u && u.rtl || ((m) => m);
  return (i === "both" || i === "ltr") && r.push(Oa(
    a,
    (m) => {
      r.forEach((v) => v.pause()), o.value = d(m), r.forEach((v) => v.resume());
    },
    { flush: l, deep: t, immediate: s }
  )), (i === "both" || i === "rtl") && r.push(Oa(
    o,
    (m) => {
      r.forEach((v) => v.pause()), a.value = c(m), r.forEach((v) => v.resume());
    },
    { flush: l, deep: t, immediate: s }
  )), () => {
    r.forEach((m) => m.stop());
  };
}
function bo(a, o = !0, e) {
  Gs() ? Ue(a, e) : o ? a() : Ie(a);
}
function yo(a, o = 1e3, e = {}) {
  const {
    immediate: l = !0,
    immediateCallback: t = !1
  } = e;
  let s = null;
  const i = F(!1);
  function u() {
    s && (clearInterval(s), s = null);
  }
  function r() {
    i.value = !1, u();
  }
  function d() {
    const c = ze(o);
    c <= 0 || (i.value = !0, t && a(), u(), s = setInterval(a, c));
  }
  if (l && ra && d(), An(o) || typeof o == "function") {
    const c = fe(o, () => {
      i.value && ra && d();
    });
    dt(c);
  }
  return dt(r), {
    isActive: i,
    pause: r,
    resume: d
  };
}
function he(a, o = {}) {
  const {
    method: e = "parseFloat",
    radix: l,
    nanToZero: t
  } = o;
  return _(() => {
    let s = ze(a);
    return typeof s == "string" && (s = Number[e](s, l)), t && Number.isNaN(s) && (s = 0), s;
  });
}
function ia(a = {}) {
  const {
    inheritAttrs: o = !0
  } = a, e = Vt(), l = /* @__PURE__ */ z({
    setup(s, { slots: i }) {
      return () => {
        e.value = i.default;
      };
    }
  }), t = /* @__PURE__ */ z({
    inheritAttrs: o,
    setup(s, { attrs: i, slots: u }) {
      return () => {
        var r;
        if (!e.value && process.env.NODE_ENV !== "production")
          throw new Error("[VueUse] Failed to find the definition of reusable template");
        const d = (r = e.value) == null ? void 0 : r.call(e, { ...Ks(i), $slots: u });
        return o && (d == null ? void 0 : d.length) === 1 ? d[0] : d;
      };
    }
  });
  return Ls(
    { define: l, reuse: t },
    [l, t]
  );
}
function Ks(a) {
  const o = {};
  for (const e in a)
    o[qs(e)] = a[e];
  return o;
}
function We(a) {
  var o;
  const e = ze(a);
  return (o = e == null ? void 0 : e.$el) != null ? o : e;
}
const Ge = ra ? window : void 0;
function $e(...a) {
  let o, e, l, t;
  if (typeof a[0] == "string" || Array.isArray(a[0]) ? ([e, l, t] = a, o = Ge) : [o, e, l, t] = a, !o)
    return Ze;
  Array.isArray(e) || (e = [e]), Array.isArray(l) || (l = [l]);
  const s = [], i = () => {
    s.forEach((c) => c()), s.length = 0;
  }, u = (c, f, m, v) => (c.addEventListener(f, m, v), () => c.removeEventListener(f, m, v)), r = fe(
    () => [We(o), ze(t)],
    ([c, f]) => {
      if (i(), !c)
        return;
      const m = Rs(f) ? { ...f } : f;
      s.push(
        ...e.flatMap((v) => l.map((y) => u(c, v, y, m)))
      );
    },
    { immediate: !0, flush: "post" }
  ), d = () => {
    r(), i();
  };
  return dt(d), d;
}
let wl = !1;
function go(a, o, e = {}) {
  const { window: l = Ge, ignore: t = [], capture: s = !0, detectIframe: i = !1 } = e;
  if (!l)
    return Ze;
  Aa && !wl && (wl = !0, Array.from(l.document.body.children).forEach((m) => m.addEventListener("click", Ze)), l.document.documentElement.addEventListener("click", Ze));
  let u = !0;
  const r = (m) => t.some((v) => {
    if (typeof v == "string")
      return Array.from(l.document.querySelectorAll(v)).some((y) => y === m.target || m.composedPath().includes(y));
    {
      const y = We(v);
      return y && (m.target === y || m.composedPath().includes(y));
    }
  }), c = [
    $e(l, "click", (m) => {
      const v = We(a);
      if (!(!v || v === m.target || m.composedPath().includes(v))) {
        if (m.detail === 0 && (u = !r(m)), !u) {
          u = !0;
          return;
        }
        o(m);
      }
    }, { passive: !0, capture: s }),
    $e(l, "pointerdown", (m) => {
      const v = We(a);
      u = !r(m) && !!(v && !m.composedPath().includes(v));
    }, { passive: !0 }),
    i && $e(l, "blur", (m) => {
      setTimeout(() => {
        var v;
        const y = We(a);
        ((v = l.document.activeElement) == null ? void 0 : v.tagName) === "IFRAME" && !(y != null && y.contains(l.document.activeElement)) && o(m);
      }, 0);
    })
  ].filter(Boolean);
  return () => c.forEach((m) => m());
}
function Ys(a) {
  return typeof a == "function" ? a : typeof a == "string" ? (o) => o.key === a : Array.isArray(a) ? (o) => a.includes(o.key) : () => !0;
}
function De(...a) {
  let o, e, l = {};
  a.length === 3 ? (o = a[0], e = a[1], l = a[2]) : a.length === 2 ? typeof a[1] == "object" ? (o = !0, e = a[0], l = a[1]) : (o = a[0], e = a[1]) : (o = !0, e = a[0]);
  const {
    target: t = Ge,
    eventName: s = "keydown",
    passive: i = !1,
    dedupe: u = !1
  } = l, r = Ys(o);
  return $e(t, s, (c) => {
    c.repeat && ze(u) || r(c) && e(c);
  }, i);
}
function Zs() {
  const a = F(!1), o = ht();
  return o && Ue(() => {
    a.value = !0;
  }, o), a;
}
function Ja(a) {
  const o = Zs();
  return _(() => (o.value, !!a()));
}
function Js(a, o, e = {}) {
  const { window: l = Ge, ...t } = e;
  let s;
  const i = Ja(() => l && "MutationObserver" in l), u = () => {
    s && (s.disconnect(), s = void 0);
  }, r = _(() => {
    const m = ze(a), v = (Array.isArray(m) ? m : [m]).map(We).filter(fo);
    return new Set(v);
  }), d = fe(
    () => r.value,
    (m) => {
      u(), i.value && m.size && (s = new MutationObserver(o), m.forEach((v) => s.observe(v, t)));
    },
    { immediate: !0, flush: "post" }
  ), c = () => s == null ? void 0 : s.takeRecords(), f = () => {
    u(), d();
  };
  return dt(f), {
    isSupported: i,
    stop: f,
    takeRecords: c
  };
}
function Qs(a, o = {}) {
  const { window: e = Ge } = o, l = Ja(() => e && "matchMedia" in e && typeof e.matchMedia == "function");
  let t;
  const s = F(!1), i = (d) => {
    s.value = d.matches;
  }, u = () => {
    t && ("removeEventListener" in t ? t.removeEventListener("change", i) : t.removeListener(i));
  }, r = Nt(() => {
    l.value && (u(), t = e.matchMedia(ze(a)), "addEventListener" in t ? t.addEventListener("change", i) : t.addListener(i), s.value = t.matches);
  });
  return dt(() => {
    r(), u(), t = void 0;
  }), s;
}
const Yt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Zt = "__vueuse_ssr_handlers__", er = /* @__PURE__ */ tr();
function tr() {
  return Zt in Yt || (Yt[Zt] = Yt[Zt] || {}), Yt[Zt];
}
function Qa(a, o) {
  return er[a] || o;
}
function ar(a) {
  return a == null ? "any" : a instanceof Set ? "set" : a instanceof Map ? "map" : a instanceof Date ? "date" : typeof a == "boolean" ? "boolean" : typeof a == "string" ? "string" : typeof a == "object" ? "object" : Number.isNaN(a) ? "any" : "number";
}
const lr = {
  boolean: {
    read: (a) => a === "true",
    write: (a) => String(a)
  },
  object: {
    read: (a) => JSON.parse(a),
    write: (a) => JSON.stringify(a)
  },
  number: {
    read: (a) => Number.parseFloat(a),
    write: (a) => String(a)
  },
  any: {
    read: (a) => a,
    write: (a) => String(a)
  },
  string: {
    read: (a) => a,
    write: (a) => String(a)
  },
  map: {
    read: (a) => new Map(JSON.parse(a)),
    write: (a) => JSON.stringify(Array.from(a.entries()))
  },
  set: {
    read: (a) => new Set(JSON.parse(a)),
    write: (a) => JSON.stringify(Array.from(a))
  },
  date: {
    read: (a) => new Date(a),
    write: (a) => a.toISOString()
  }
}, Cl = "vueuse-storage";
function or(a, o, e, l = {}) {
  var t;
  const {
    flush: s = "pre",
    deep: i = !0,
    listenToStorageChanges: u = !0,
    writeDefaults: r = !0,
    mergeDefaults: d = !1,
    shallow: c,
    window: f = Ge,
    eventFilter: m,
    onError: v = (P) => {
      console.error(P);
    },
    initOnMounted: y
  } = l, h = (c ? Vt : F)(typeof o == "function" ? o() : o);
  if (!e)
    try {
      e = Qa("getDefaultStorage", () => {
        var P;
        return (P = Ge) == null ? void 0 : P.localStorage;
      })();
    } catch (P) {
      v(P);
    }
  if (!e)
    return h;
  const C = ze(o), p = ar(C), B = (t = l.serializer) != null ? t : lr[p], { pause: g, resume: S } = Oa(
    h,
    () => x(h.value),
    { flush: s, deep: i, eventFilter: m }
  );
  f && u && bo(() => {
    $e(f, "storage", G), $e(f, Cl, W), y && G();
  }), y || G();
  function w(P, Y) {
    f && f.dispatchEvent(new CustomEvent(Cl, {
      detail: {
        key: a,
        oldValue: P,
        newValue: Y,
        storageArea: e
      }
    }));
  }
  function x(P) {
    try {
      const Y = e.getItem(a);
      if (P == null)
        w(Y, null), e.removeItem(a);
      else {
        const ae = B.write(P);
        Y !== ae && (e.setItem(a, ae), w(Y, ae));
      }
    } catch (Y) {
      v(Y);
    }
  }
  function V(P) {
    const Y = P ? P.newValue : e.getItem(a);
    if (Y == null)
      return r && C != null && e.setItem(a, B.write(C)), C;
    if (!P && d) {
      const ae = B.read(Y);
      return typeof d == "function" ? d(ae, C) : p === "object" && !Array.isArray(ae) ? { ...C, ...ae } : ae;
    } else
      return typeof Y != "string" ? Y : B.read(Y);
  }
  function G(P) {
    if (!(P && P.storageArea !== e)) {
      if (P && P.key == null) {
        h.value = C;
        return;
      }
      if (!(P && P.key !== a)) {
        g();
        try {
          (P == null ? void 0 : P.newValue) !== B.write(h.value) && (h.value = V(P));
        } catch (Y) {
          v(Y);
        } finally {
          P ? Ie(S) : S();
        }
      }
    }
  }
  function W(P) {
    G(P.detail);
  }
  return h;
}
function nr(a) {
  return Qs("(prefers-color-scheme: dark)", a);
}
function sr(a = {}) {
  const {
    selector: o = "html",
    attribute: e = "class",
    initialValue: l = "auto",
    window: t = Ge,
    storage: s,
    storageKey: i = "vueuse-color-scheme",
    listenToStorageChanges: u = !0,
    storageRef: r,
    emitAuto: d,
    disableTransition: c = !0
  } = a, f = {
    auto: "",
    light: "light",
    dark: "dark",
    ...a.modes || {}
  }, m = nr({ window: t }), v = _(() => m.value ? "dark" : "light"), y = r || (i == null ? mo(l) : or(i, l, s, { window: t, listenToStorageChanges: u })), h = _(() => y.value === "auto" ? v.value : y.value), C = Qa(
    "updateHTMLAttrs",
    (S, w, x) => {
      const V = typeof S == "string" ? t == null ? void 0 : t.document.querySelector(S) : We(S);
      if (!V)
        return;
      let G;
      if (c && (G = t.document.createElement("style"), G.appendChild(document.createTextNode("*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}")), t.document.head.appendChild(G)), w === "class") {
        const W = x.split(/\s/g);
        Object.values(f).flatMap((P) => (P || "").split(/\s/g)).filter(Boolean).forEach((P) => {
          W.includes(P) ? V.classList.add(P) : V.classList.remove(P);
        });
      } else
        V.setAttribute(w, x);
      c && (t.getComputedStyle(G).opacity, document.head.removeChild(G));
    }
  );
  function p(S) {
    var w;
    C(o, e, (w = f[S]) != null ? w : S);
  }
  function B(S) {
    a.onChanged ? a.onChanged(S, p) : p(S);
  }
  fe(h, B, { flush: "post", immediate: !0 }), bo(() => B(h.value));
  const g = _({
    get() {
      return d ? y.value : h.value;
    },
    set(S) {
      y.value = S;
    }
  });
  try {
    return Object.assign(g, { store: y, system: v, state: h });
  } catch {
    return g;
  }
}
function el(a, o = {}) {
  const {
    delayEnter: e = 0,
    delayLeave: l = 0,
    window: t = Ge
  } = o, s = F(!1);
  let i;
  const u = (r) => {
    const d = r ? e : l;
    i && (clearTimeout(i), i = void 0), d ? i = setTimeout(() => s.value = r, d) : s.value = r;
  };
  return t && ($e(a, "mouseenter", () => u(!0), { passive: !0 }), $e(a, "mouseleave", () => u(!1), { passive: !0 })), s;
}
function rr(a, o, e = {}) {
  const {
    root: l,
    rootMargin: t = "0px",
    threshold: s = 0.1,
    window: i = Ge,
    immediate: u = !0
  } = e, r = Ja(() => i && "IntersectionObserver" in i), d = _(() => {
    const y = ze(a);
    return (Array.isArray(y) ? y : [y]).map(We).filter(fo);
  });
  let c = Ze;
  const f = F(u), m = r.value ? fe(
    () => [d.value, We(l), f.value],
    ([y, h]) => {
      if (c(), !f.value || !y.length)
        return;
      const C = new IntersectionObserver(
        o,
        {
          root: We(h),
          rootMargin: t,
          threshold: s
        }
      );
      y.forEach((p) => p && C.observe(p)), c = () => {
        C.disconnect(), c = Ze;
      };
    },
    { immediate: u, flush: "post" }
  ) : Ze, v = () => {
    c(), m(), f.value = !1;
  };
  return dt(v), {
    isSupported: r,
    isActive: f,
    pause() {
      c(), f.value = !1;
    },
    resume() {
      f.value = !0;
    },
    stop: v
  };
}
function Fe(a, o = {}) {
  const { initialValue: e = !1, focusVisible: l = !1 } = o, t = F(!1), s = _(() => We(a));
  $e(s, "focus", (u) => {
    var r, d;
    (!l || (d = (r = u.target).matches) != null && d.call(r, ":focus-visible")) && (t.value = !0);
  }), $e(s, "blur", () => t.value = !1);
  const i = _({
    get: () => t.value,
    set(u) {
      var r, d;
      !u && t.value ? (r = s.value) == null || r.blur() : u && !t.value && ((d = s.value) == null || d.focus());
    }
  });
  return fe(
    s,
    () => {
      i.value = e;
    },
    { immediate: !0, flush: "post" }
  ), { focused: i };
}
function _a(a) {
  return typeof Window < "u" && a instanceof Window ? a.document.documentElement : typeof Document < "u" && a instanceof Document ? a.documentElement : a;
}
const ir = {
  page: (a) => [a.pageX, a.pageY],
  client: (a) => [a.clientX, a.clientY],
  screen: (a) => [a.screenX, a.screenY],
  movement: (a) => a instanceof Touch ? null : [a.movementX, a.movementY]
};
function ur(a = {}) {
  const {
    type: o = "page",
    touch: e = !0,
    resetOnTouchEnds: l = !1,
    initialValue: t = { x: 0, y: 0 },
    window: s = Ge,
    target: i = s,
    scroll: u = !0,
    eventFilter: r
  } = a;
  let d = null;
  const c = F(t.x), f = F(t.y), m = F(null), v = typeof o == "function" ? o : ir[o], y = (w) => {
    const x = v(w);
    d = w, x && ([c.value, f.value] = x, m.value = "mouse");
  }, h = (w) => {
    if (w.touches.length > 0) {
      const x = v(w.touches[0]);
      x && ([c.value, f.value] = x, m.value = "touch");
    }
  }, C = () => {
    if (!d || !s)
      return;
    const w = v(d);
    d instanceof MouseEvent && w && (c.value = w[0] + s.scrollX, f.value = w[1] + s.scrollY);
  }, p = () => {
    c.value = t.x, f.value = t.y;
  }, B = r ? (w) => r(() => y(w), {}) : (w) => y(w), g = r ? (w) => r(() => h(w), {}) : (w) => h(w), S = r ? () => r(() => C(), {}) : () => C();
  if (i) {
    const w = { passive: !0 };
    $e(i, ["mousemove", "dragover"], B, w), e && o !== "movement" && ($e(i, ["touchstart", "touchmove"], g, w), l && $e(i, "touchend", p, w)), u && o === "page" && $e(s, "scroll", S, { passive: !0 });
  }
  return {
    x: c,
    y: f,
    sourceType: m
  };
}
function kl(a, o = {}) {
  const {
    handleOutside: e = !0,
    window: l = Ge
  } = o, t = o.type || "page", { x: s, y: i, sourceType: u } = ur(o), r = F(a ?? (l == null ? void 0 : l.document.body)), d = F(0), c = F(0), f = F(0), m = F(0), v = F(0), y = F(0), h = F(!0);
  let C = () => {
  };
  return l && (C = fe(
    [r, s, i],
    () => {
      const p = We(r);
      if (!p)
        return;
      const {
        left: B,
        top: g,
        width: S,
        height: w
      } = p.getBoundingClientRect();
      f.value = B + (t === "page" ? l.pageXOffset : 0), m.value = g + (t === "page" ? l.pageYOffset : 0), v.value = w, y.value = S;
      const x = s.value - f.value, V = i.value - m.value;
      h.value = S === 0 || w === 0 || x < 0 || V < 0 || x > S || V > w, (e || !h.value) && (d.value = x, c.value = V);
    },
    { immediate: !0 }
  ), $e(document, "mouseleave", () => {
    h.value = !0;
  })), {
    x: s,
    y: i,
    sourceType: u,
    elementX: d,
    elementY: c,
    elementPositionX: f,
    elementPositionY: m,
    elementHeight: v,
    elementWidth: y,
    isOutside: h,
    stop: C
  };
}
function ho(a) {
  const o = window.getComputedStyle(a);
  if (o.overflowX === "scroll" || o.overflowY === "scroll" || o.overflowX === "auto" && a.clientWidth < a.scrollWidth || o.overflowY === "auto" && a.clientHeight < a.scrollHeight)
    return !0;
  {
    const e = a.parentNode;
    return !e || e.tagName === "BODY" ? !1 : ho(e);
  }
}
function dr(a) {
  const o = a || window.event, e = o.target;
  return ho(e) ? !1 : o.touches.length > 1 ? !0 : (o.preventDefault && o.preventDefault(), !1);
}
const wa = /* @__PURE__ */ new WeakMap();
function cr(a, o = !1) {
  const e = F(o);
  let l = null, t = "";
  fe(mo(a), (u) => {
    const r = _a(ze(u));
    if (r) {
      const d = r;
      if (wa.get(d) || wa.set(d, d.style.overflow), d.style.overflow !== "hidden" && (t = d.style.overflow), d.style.overflow === "hidden")
        return e.value = !0;
      if (e.value)
        return d.style.overflow = "hidden";
    }
  }, {
    immediate: !0
  });
  const s = () => {
    const u = _a(ze(a));
    !u || e.value || (Aa && (l = $e(
      u,
      "touchmove",
      (r) => {
        dr(r);
      },
      { passive: !1 }
    )), u.style.overflow = "hidden", e.value = !0);
  }, i = () => {
    const u = _a(ze(a));
    !u || !e.value || (Aa && (l == null || l()), u.style.overflow = t, wa.delete(u), e.value = !1);
  };
  return dt(i), _({
    get() {
      return e.value;
    },
    set(u) {
      u ? s() : i();
    }
  });
}
function fr(a, o = {}) {
  const {
    threshold: e = 50,
    onSwipe: l,
    onSwipeEnd: t,
    onSwipeStart: s,
    passive: i = !0,
    window: u = Ge
  } = o, r = cl({ x: 0, y: 0 }), d = cl({ x: 0, y: 0 }), c = _(() => r.x - d.x), f = _(() => r.y - d.y), { max: m, abs: v } = Math, y = _(() => m(v(c.value), v(f.value)) >= e), h = F(!1), C = _(() => y.value ? v(c.value) > v(f.value) ? c.value > 0 ? "left" : "right" : f.value > 0 ? "up" : "down" : "none"), p = (W) => [W.touches[0].clientX, W.touches[0].clientY], B = (W, P) => {
    r.x = W, r.y = P;
  }, g = (W, P) => {
    d.x = W, d.y = P;
  };
  let S;
  const w = vr(u == null ? void 0 : u.document);
  i ? S = w ? { passive: !0 } : { capture: !1 } : S = w ? { passive: !1, capture: !0 } : { capture: !0 };
  const x = (W) => {
    h.value && (t == null || t(W, C.value)), h.value = !1;
  }, V = [
    $e(a, "touchstart", (W) => {
      if (W.touches.length !== 1)
        return;
      S.capture && !S.passive && W.preventDefault();
      const [P, Y] = p(W);
      B(P, Y), g(P, Y), s == null || s(W);
    }, S),
    $e(a, "touchmove", (W) => {
      if (W.touches.length !== 1)
        return;
      const [P, Y] = p(W);
      g(P, Y), !h.value && y.value && (h.value = !0), h.value && (l == null || l(W));
    }, S),
    $e(a, ["touchend", "touchcancel"], x, S)
  ];
  return {
    isPassiveEventSupported: w,
    isSwiping: h,
    direction: C,
    coordsStart: r,
    coordsEnd: d,
    lengthX: c,
    lengthY: f,
    stop: () => V.forEach((W) => W())
  };
}
function vr(a) {
  if (!a)
    return !1;
  let o = !1;
  const e = {
    get passive() {
      return o = !0, !1;
    }
  };
  return a.addEventListener("x", Ze, e), a.removeEventListener("x", Ze), o;
}
const pr = ["id"], mr = ["id"], br = ["innerHTML"], yr = ["innerHTML"], tl = /* @__PURE__ */ z({
  inheritAttrs: !1,
  __name: "BPopover",
  props: /* @__PURE__ */ ye({
    boundary: { default: "clippingAncestors" },
    boundaryPadding: { default: void 0 },
    click: { type: Boolean, default: !1 },
    content: { default: void 0 },
    customClass: { default: "" },
    delay: { default: () => ({ show: 100, hide: 300 }) },
    floatingMiddleware: { default: void 0 },
    html: { type: Boolean, default: !1 },
    id: { default: void 0 },
    inline: { type: Boolean, default: !1 },
    manual: { type: Boolean, default: !1 },
    modelValue: { type: Boolean },
    noAutoClose: { type: Boolean, default: !1 },
    noFade: { type: Boolean, default: !1 },
    noFlip: { type: Boolean, default: !1 },
    noHide: { type: Boolean, default: !1 },
    noShift: { type: Boolean, default: !1 },
    noSize: { type: Boolean, default: !1 },
    noninteractive: { type: Boolean, default: !1 },
    offset: { default: null },
    placement: { default: "top" },
    persistent: { type: Boolean, default: !1 },
    realtime: { type: Boolean, default: !1 },
    reference: { default: null },
    strategy: { default: "absolute" },
    target: { default: null },
    title: { default: void 0 },
    tooltip: { type: Boolean, default: !1 },
    variant: { default: null },
    teleportDisabled: { default: !1 },
    teleportTo: { default: void 0 }
  }, {
    modelValue: { type: Boolean, default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ ye(["hidden", "hide", "hide-prevented", "show", "show-prevented", "shown"], ["update:modelValue"]),
  setup(a, { expose: o, emit: e }) {
    const t = j(a, "BPopover"), s = e, i = _e(a, "modelValue"), u = F(i.value), r = F(i.value);
    Nt(() => {
      i.value = u.value;
    }), fe(i, (q) => {
      q !== u.value && (q ? R() : H(new Event("update:modelValue")));
    });
    const d = we(() => t.id, "popover"), c = F(!1), f = F(null), m = F(null), v = F(null), y = F(null), h = F(null), C = _(
      () => t.title ? $t(t.title, Tt) : ""
    ), p = _(
      () => t.content ? $t(t.content, Tt) : ""
    ), B = k(() => t.placement.startsWith("auto")), g = he(() => t.offset ?? NaN), S = _(
      () => t.boundary === "document" || t.boundary === "viewport" ? void 0 : t.boundary
    ), w = _(
      () => t.boundary === "document" || t.boundary === "viewport" ? t.boundary : void 0
    ), x = F({}), V = _(() => {
      if (t.floatingMiddleware !== void 0)
        return t.floatingMiddleware;
      const q = t.offset !== null ? g.value : t.tooltip ? 6 : 8, oe = [Zl(q)];
      return t.noFlip === !1 && !B.value && oe.push(
        ro({
          boundary: S.value,
          rootBoundary: w.value,
          padding: t.boundaryPadding
        })
      ), B.value && oe.push(
        Ts({
          alignment: t.placement.split("-")[1] || void 0,
          boundary: S.value,
          rootBoundary: w.value,
          padding: t.boundaryPadding
        })
      ), t.noShift === !1 && oe.push(
        so({
          boundary: S.value,
          rootBoundary: w.value,
          padding: t.boundaryPadding
        })
      ), t.noHide === !1 && oe.push(
        $s({
          boundary: S.value,
          rootBoundary: w.value,
          padding: t.boundaryPadding
        })
      ), t.inline === !0 && oe.push(Ss()), oe.push(Os({ element: v, padding: 10 })), t.noSize === !1 && oe.push(
        io({
          boundary: S.value,
          rootBoundary: w.value,
          padding: t.boundaryPadding,
          apply({ availableWidth: de, availableHeight: ee }) {
            x.value = {
              maxHeight: ee ? `${ee}px` : void 0,
              maxWidth: de ? `${de}px` : void 0
            };
          }
        })
      ), oe;
    }), G = k(
      () => B.value ? void 0 : t.placement
    ), { floatingStyles: W, middlewareData: P, placement: Y, update: ae } = co(m, f, {
      placement: G,
      middleware: V,
      strategy: k(() => t.strategy),
      whileElementsMounted: (...q) => no(...q, { animationFrame: t.realtime })
    }), ne = F({ position: "absolute" });
    fe(P, () => {
      var q;
      if (t.noHide === !1 && ((q = P.value.hide) != null && q.referenceHidden ? c.value = !0 : c.value = !1), P.value.arrow) {
        const { x: oe, y: de } = P.value.arrow;
        ne.value = {
          position: "absolute",
          top: de ? `${de}px` : "",
          left: oe ? `${oe}px` : ""
        };
      }
    });
    const U = _(() => {
      const q = t.tooltip ? "tooltip" : "popover";
      return [
        q,
        `b-${q}`,
        {
          [`b-${q}-${t.variant}`]: t.variant !== null,
          show: u.value && !c.value,
          "pe-none": !u.value,
          fade: !t.noFade,
          "d-none": !u.value && t.noFade,
          [`${t.customClass}`]: t.customClass !== void 0,
          [`bs-${q}-${hr(Y.value)}`]: Y.value !== void 0
        }
      ];
    }), { isOutside: T } = kl(f), { isOutside: A } = kl(y), E = (q) => {
      const oe = q ?? new Event("click");
      u.value ? H(oe) : R();
    }, M = (q, oe = {}) => new _t(q, {
      cancelable: !1,
      target: f.value || null,
      relatedTarget: null,
      trigger: null,
      ...oe,
      componentId: d.value
    });
    let Z;
    const R = () => {
      const q = M("show", { cancelable: !0 });
      if (s("show", q), q.defaultPrevented) {
        s("show-prevented");
        return;
      }
      r.value = !0, Ie(() => {
        var oe;
        ae(), Z = setTimeout(
          () => {
            ae(), u.value = !0, Ie(() => {
              s("shown", M("shown"));
            });
          },
          typeof t.delay == "number" ? t.delay : ((oe = t.delay) == null ? void 0 : oe.show) || 0
        );
      });
    }, H = (q) => {
      var ee;
      const oe = M("hide", { cancelable: !0 });
      if (s("hide", oe), oe.defaultPrevented) {
        s("hide-prevented");
        return;
      }
      Z && (clearTimeout(Z), Z = void 0);
      const de = typeof t.delay == "number" ? t.delay : ((ee = t.delay) == null ? void 0 : ee.hide) || 0;
      setTimeout(() => {
        var re, ie;
        (q == null ? void 0 : q.type) === "click" || (q == null ? void 0 : q.type) === "forceHide" || (q == null ? void 0 : q.type) === "update:modelValue" && t.manual || !t.noninteractive && T.value && A.value && !((re = f.value) != null && re.contains(document == null ? void 0 : document.activeElement)) && !((ie = y.value) != null && ie.contains(document == null ? void 0 : document.activeElement)) || t.noninteractive && A.value ? (u.value = !1, Ie(() => {
          setTimeout(
            () => {
              r.value = !1;
            },
            f.value ? xa(f.value) : 150
          ), s("hidden", M("hidden"));
        })) : setTimeout(
          () => {
            H(q);
          },
          de < 50 ? 50 : de
        );
      }, de);
    };
    o({
      hide: H,
      show: R,
      toggle: E
    });
    const ce = () => {
      var q;
      if (t.target) {
        const oe = yt(t.target);
        oe ? y.value = oe : console.warn("Target element not found", t.target);
      } else
        y.value = (q = h.value) == null ? void 0 : q.nextElementSibling;
      if (t.reference) {
        const oe = yt(t.reference);
        oe ? m.value = oe : console.warn("Reference element not found", t.reference);
      } else
        m.value = y.value;
      if (!(!y.value || t.manual) && Wa) {
        if (y.value.addEventListener("forceHide", H), t.click) {
          y.value.addEventListener("click", E);
          return;
        }
        y.value.addEventListener("pointerenter", R), y.value.addEventListener("pointerleave", H), y.value.addEventListener("focus", R), y.value.addEventListener("blur", H);
      }
    }, le = () => {
      y.value && (y.value.removeEventListener("forceHide", H), y.value.removeEventListener("click", E), y.value.removeEventListener("pointerenter", R), y.value.removeEventListener("pointerleave", H), y.value.removeEventListener("focus", R), y.value.removeEventListener("blur", H));
    };
    return go(
      f,
      () => {
        u.value && t.click && !t.noAutoClose && !t.manual && H(new Event("clickOutside"));
      },
      { ignore: [y] }
    ), fe([() => t.click, () => t.target, () => t.reference], () => {
      le(), ce();
    }), Ue(ce), Da(le), (q, oe) => (b(), O(pe, null, [
      Q("span", {
        id: n(d) + "_placeholder",
        ref_key: "placeholder",
        ref: h
      }, null, 8, pr),
      $(q.$slots, "target", {
        show: R,
        hide: H,
        toggle: E,
        showState: u.value
      }),
      (b(), N(Bt, {
        to: n(t).teleportTo,
        disabled: !n(t).teleportTo || n(t).teleportDisabled
      }, [
        r.value || n(t).persistent ? (b(), O("div", K({
          key: 0,
          id: n(d)
        }, q.$attrs, {
          ref_key: "element",
          ref: f,
          class: U.value,
          role: "tooltip",
          tabindex: "-1",
          style: n(W)
        }), [
          Q("div", {
            ref_key: "arrow",
            ref: v,
            class: D(`${n(t).tooltip ? "tooltip" : "popover"}-arrow`),
            style: Le(ne.value),
            "data-popper-arrow": ""
          }, null, 6),
          Q("div", {
            class: "overflow-auto",
            style: Le(x.value)
          }, [
            n(t).title || q.$slots.title ? (b(), O(pe, { key: 0 }, [
              n(t).html ? (b(), O("div", {
                key: 1,
                class: D(["position-sticky top-0", n(t).tooltip ? "tooltip-inner" : "popover-header"]),
                innerHTML: C.value
              }, null, 10, br)) : (b(), O("div", {
                key: 0,
                class: D(["position-sticky top-0", n(t).tooltip ? "tooltip-inner" : "popover-header"])
              }, [
                $(q.$slots, "title", {}, () => [
                  se(J(n(t).title), 1)
                ])
              ], 2))
            ], 64)) : te("", !0),
            n(t).tooltip && !q.$slots.title && !n(t).title || !n(t).tooltip ? (b(), O(pe, { key: 1 }, [
              n(t).html ? (b(), O("div", {
                key: 1,
                class: D(n(t).tooltip ? "tooltip-inner" : "popover-body"),
                innerHTML: p.value
              }, null, 10, yr)) : (b(), O("div", {
                key: 0,
                class: D(n(t).tooltip ? "tooltip-inner" : "popover-body")
              }, [
                $(q.$slots, "default", {}, () => [
                  se(J(n(t).content), 1)
                ])
              ], 2))
            ], 64)) : te("", !0)
          ], 4)
        ], 16, mr)) : te("", !0)
      ], 8, ["to", "disabled"]))
    ], 64));
  }
}), gr = ({
  top: a,
  end: o,
  start: e,
  alignCenter: l,
  alignEnd: t
}) => {
  const s = a ? "top" : e ? "left" : o ? "right" : "bottom", i = t ? "end" : l ? null : "start";
  return `${s}${i ? `-${i}` : ""}`;
}, hr = (a) => {
  const [o] = a.split("-");
  switch (o) {
    case "left":
      return "start";
    case "right":
      return "end";
    default:
      return o;
  }
}, Ht = (a) => typeof a != "object" || a.active !== !1, ua = (a, o) => {
  if (!Ht(a))
    return {};
  const l = typeof a > "u" || typeof a == "object" && !a.title && !a.content, t = o.getAttribute("title") || o.getAttribute("data-original-title");
  return l ? t ? (o.removeAttribute("title"), o.setAttribute("data-original-title", t), {
    content: $t(t, Tt)
  }) : {} : typeof a == "string" ? {
    content: $t(a, Tt)
  } : {
    title: a != null && a.title ? $t(a == null ? void 0 : a.title, Tt) : void 0,
    content: a != null && a.content ? $t(a == null ? void 0 : a.content, Tt) : void 0
  };
}, da = (a, o) => ({
  target: o,
  modelValue: a.modifiers.show,
  inline: a.modifiers.inline,
  click: a.modifiers.click,
  realtime: a.modifiers.realtime,
  persistent: a.modifiers.persistent,
  placement: a.modifiers.left ? "left" : a.modifiers.right ? "right" : a.modifiers.bottom ? "bottom" : a.modifiers.top ? "top" : void 0,
  html: !0,
  ...typeof a.value == "object" ? a.value : {},
  ...a.modifiers.interactive ? { noninteractive: !1 } : {},
  title: null,
  content: null
}), ca = (a, o, e) => {
  var t;
  const l = document.createElement("span");
  o.modifiers.body ? document.body.appendChild(l) : o.modifiers.child ? a.appendChild(l) : (t = a.parentNode) == null || t.insertBefore(l, a.nextSibling), jl(Pe(tl, e), l), a.$__element = l;
}, fa = (a) => {
  const o = a.$__element;
  o && jl(null, o), setTimeout(() => {
    o == null || o.remove();
  }, 0), delete a.$__element;
}, Na = (a, o, e) => {
  const l = Ee(a, o);
  return e && typeof e == "function" ? e(l, o, a) : l;
}, Jt = (a, o, e, l = e) => o.reduce((t, s) => (a[s] && t.push(
  [l, s.replace(e, ""), a[s]].filter((i) => i && typeof i != "boolean").join("-").toLowerCase()
), t), []), yt = (a) => {
  if (a)
    return typeof a == "string" ? typeof document > "u" ? void 0 : document.getElementById(a) ?? document.querySelector(a) ?? void 0 : a.$el ?? a;
}, Br = (a, o) => ((a == null ? void 0 : a()) ?? []).reduce((e, l) => (typeof l.type == "symbol" ? e = e.concat(l.children) : e.push(l), e), []).filter((e) => {
  var l;
  return ((l = e.type) == null ? void 0 : l.__name) === o;
}), Bo = /_/g, _o = /([a-z])([A-Z])/g, _r = /^[0-9]*\.?[0-9]+$/, wr = /(\s|^)(\w)/g, Cr = /(\s|^)(\w)/, Qt = /\s+/, kr = /^#/, Tr = /^#[A-Za-z]+[\w\-:.]*$/, $r = /[-/\\^$*+?.()|[\]{}]/g, xr = /[\s\uFEFF\xA0]+/g, Ca = (a) => a.replace(Bo, " ").replace(_o, (o, e, l) => `${e} ${l}`).replace(Cr, (o, e, l) => e + l.toUpperCase()), Tl = (a) => a.replace(Bo, " ").replace(_o, (o, e, l) => `${e} ${l}`).replace(wr, (o, e, l) => e + l.toUpperCase()), Sr = (a) => {
  const o = a.trim();
  return o.charAt(0).toUpperCase() + o.slice(1);
}, Vr = (a) => a.replace($r, "\\$&"), Ar = (a) => Vr(a).replace(xr, "\\s"), ea = (a) => typeof a == "string" ? Tl(a) : a.label !== void 0 ? a.label : typeof a.key == "string" ? Tl(a.key) : a.key, Or = (a) => !!(a.href || a.to), wo = Symbol("bvn::carousel"), Co = Symbol("bvn::tabs"), ko = Symbol("bvn::progress"), To = Symbol("bvn::listGroup"), $o = Symbol("bvn::avatarGroup"), xo = Symbol("bvn::accordion"), So = Symbol("bvn::checkboxGroup"), Vo = Symbol("bvn::radioGroup"), al = Symbol("bvn::collapse"), Ao = Symbol("bvn::collapse"), ll = Symbol("bvn::navbar"), Oo = Symbol("bvn::toastPlugin"), Po = Symbol("bvn::rtlPlugin"), No = Symbol("bvn::breadcrumbPlugin"), Io = Symbol("bvn::modalControllerPlugin"), Eo = Symbol("bvn::modalManagerPlugin"), Fo = Symbol("bvn::idPluginKey"), ta = Symbol("bvn::defaults"), Lo = Symbol("bvn::inputGroup"), Ft = (a, o = {}, e = {}) => {
  const l = [a];
  let t;
  for (let s = 0; s < l.length && !t; s++) {
    const i = l[s];
    t = e[i];
  }
  return t && typeof t == "function" ? t(o) : t;
}, ga = (a, o) => Object.keys(a).filter((e) => !o.map((l) => l.toString()).includes(e)).reduce((e, l) => ({ ...e, [l]: a[l] }), {}), ol = (a, o) => [...o].reduce(
  (e, l) => (e[l] = a[l], e),
  {}
), Ee = (a, o, e) => {
  const l = o.split(/[.[\]]/g);
  let t = a;
  for (const s of l) {
    if (t === null || t === void 0)
      return e;
    s.trim() !== "" && (t = t[s]);
  }
  return t === void 0 ? e : t;
}, Pr = (a, o, e) => {
  const l = (r) => {
    if (((f) => f == null || typeof f != "object" && typeof f != "function")(r))
      return r;
    if (typeof r == "function")
      return r.bind({});
    const c = new r.constructor();
    return Object.getOwnPropertyNames(r).forEach((f) => {
      c[f] = r[f];
    }), c;
  }, t = (r, d) => {
    const c = d === void 0 ? 0 : d;
    if (r == null)
      return c;
    const f = Number.parseInt(r);
    return Number.isNaN(f) ? c : f;
  };
  if (!a)
    return {};
  if (!o || e === void 0)
    return a;
  const s = o.split(/[.[\]]/g).filter((r) => !!r.trim()), i = (r) => {
    if (s.length > 1) {
      const d = s.shift(), c = t(s[0], null) !== null;
      r[d] = r[d] === void 0 ? c ? [] : {} : r[d], i(r[d]);
    } else
      r[s[0]] = e;
  }, u = l(a);
  return i(u), u;
}, va = (a, o) => {
  const { all: e, ...l } = a, t = {};
  e && o.forEach((i) => {
    t[i] = e;
  });
  const s = { ...t, ...l };
  return Object.entries(s).filter(([i, u]) => !!u && o.includes(i)).map(([i]) => i);
}, $l = (a, o) => o + (a ? Sr(a) : ""), Nr = {
  "top-start": "top-0 start-0",
  "top-center": "top-0 start-50 translate-middle-x",
  "top-end": "top-0 end-0",
  "middle-start": "top-50 start-0 translate-middle-y",
  "middle-center": "top-50 start-50 translate-middle",
  "middle-end": "top-50 end-0 translate-middle-y",
  "bottom-start": "bottom-0 start-0",
  "bottom-center": "bottom-0 start-50 translate-middle-x",
  "bottom-end": "bottom-0 end-0"
}, wt = (a, o) => {
  const e = k(o), l = k(a), t = k(() => Or(l.value)), s = _(
    () => t.value ? ol(
      l.value,
      e.value ?? [
        "active",
        "activeClass",
        "append",
        "href",
        "rel",
        "replace",
        "routerComponentName",
        "target",
        "to",
        "variant",
        "opacity",
        "opacityHover",
        "underlineVariant",
        "underlineOffset",
        "underlineOffsetHover",
        "underlineOpacity",
        "underlineOpacityHover"
      ]
    ) : {}
  );
  return { computedLink: t, computedLinkProps: s };
}, zo = () => ({ ...Ve(No) }), Ir = (a = {}) => {
  const o = a.persist ?? !1, e = "data-bs-theme", l = "body";
  return sr({
    attribute: e,
    selector: l,
    storageKey: o === !0 ? `bv-color-${a.attribute ?? e}-${a.selector ?? l}` : null,
    ...a
  });
}, ot = (a) => _(() => {
  let o = Te(a);
  return o = {
    ...o,
    variant: o.variant ?? null,
    bgVariant: o.bgVariant ?? null,
    textVariant: o.textVariant ?? null
  }, {
    [`text-bg-${o.variant}`]: o.variant !== null,
    [`text-${o.textVariant}`]: o.textVariant !== null && o.variant === null,
    [`bg-${o.bgVariant}`]: o.bgVariant !== null && o.variant === null
  };
}), Er = (a) => _(() => {
  const o = Te(a);
  return {
    container: o === !0,
    [`container-${o}`]: typeof o == "string"
  };
}), Ro = (a, o = F(1e3), e = {}) => {
  const l = Ye(k(a)), t = Ye(k(o)), s = F(!1), i = F(0), u = k(() => Math.ceil(l.value / t.value)), r = k(
    () => f.value || s.value ? Math.round(l.value - i.value * t.value) : 0
  ), { pause: d, resume: c, isActive: f } = yo(
    () => {
      i.value = i.value + 1;
    },
    o,
    e
  ), m = () => {
    s.value = !1, i.value = 0, c();
  }, v = () => {
    s.value = !1, i.value = u.value;
  };
  Nt(() => {
    i.value > u.value && (i.value = u.value), i.value === u.value && d();
  }), fe([t, l], () => {
    v(), m();
  });
  const y = () => {
    f.value !== !1 && (s.value = !0, d());
  }, h = () => {
    i.value !== u.value && (s.value = !1, c());
  };
  return {
    isActive: Ye(f),
    isPaused: Ye(s),
    restart: m,
    stop: v,
    pause: y,
    resume: h,
    value: r
  };
};
function Fr(a, o = Ho("injectSelf")) {
  const { provides: e } = o;
  if (e && a in e)
    return e[a];
}
function Ho(a, o) {
  const e = ht();
  if (!e)
    throw new Error(`[Bvn] ${a} ${o || "must be called from inside a setup function"}`);
  return e;
}
const Lr = (a = "") => a.replace(/[^a-z]/gi, "-").replace(/\B([A-Z])/g, "-$1").toLowerCase(), xl = (a) => a !== null && typeof a == "object" && !Array.isArray(a);
function Mo(a = {}, o = {}, e) {
  const l = {};
  for (const t in a)
    l[t] = a[t];
  for (const t in o) {
    const s = a[t], i = o[t];
    if (xl(s) && xl(i)) {
      l[t] = Mo(s, i, e);
      continue;
    }
    if (Array.isArray(s) && Array.isArray(i) && e) {
      l[t] = e(s, i);
      continue;
    }
    l[t] = i;
  }
  return l;
}
const zr = (a, o) => {
  var e, l;
  return typeof ((e = a.props) == null ? void 0 : e[o]) < "u" || typeof ((l = a.props) == null ? void 0 : l[Lr(o)]) < "u";
};
function Rr(a = {}, o) {
  const e = Ve(ta, F({})), l = Ho("useDefaults");
  if (o = o ?? l.type.name ?? l.type.__name, !o)
    throw new Error("[Bvn] Could not determine component name");
  const t = _(() => {
    var r;
    return (r = e.value) == null ? void 0 : r[a._as ?? o];
  }), s = new Proxy(a, {
    get(r, d) {
      var f, m, v, y;
      const c = Reflect.get(r, d);
      return d === "class" || d === "style" ? [(f = t.value) == null ? void 0 : f[d], c].filter((h) => h != null) : typeof d == "string" && !zr(l.vnode, d) ? ((m = t.value) == null ? void 0 : m[d]) ?? ((y = (v = e.value) == null ? void 0 : v.global) == null ? void 0 : y[d]) ?? c : c;
    }
  }), i = Vt();
  Nt(() => {
    if (t.value) {
      const r = Object.entries(t.value).filter(
        ([d]) => d.startsWith(d[0].toUpperCase())
      );
      i.value = r.length ? Object.fromEntries(r) : void 0;
    } else
      i.value = void 0;
  });
  function u() {
    const r = Fr(ta, l);
    Xe(
      ta,
      _(
        () => i.value ? Mo((r == null ? void 0 : r.value) ?? {}, i.value) : r == null ? void 0 : r.value
      )
    );
  }
  return { props: s, provideSubDefaults: u };
}
function j(a, o) {
  const { props: e, provideSubDefaults: l } = Rr(a, o);
  return l(), e;
}
const Ct = (a) => _(() => {
  const o = Te(a);
  return o === !0 ? "is-valid" : o === !1 ? "is-invalid" : null;
}), Do = (a) => _(() => {
  const o = Te(a);
  return {
    "form-check": o.plain === !1 && o.button === !1 && o.hasDefaultSlot,
    "form-check-reverse": o.reverse === !0,
    "form-check-inline": o.inline === !0,
    "form-switch": o.switch === !0,
    [`form-control-${o.size}`]: o.size !== void 0 && o.size !== "md" && o.button === !1
  };
}), jo = (a) => {
  const o = k(a), e = Ct(() => o.value.state ?? null);
  return _(() => [
    e.value,
    {
      "form-check-input": o.value.plain === !1 && o.value.button === !1,
      "btn-check": o.value.button === !0
    }
  ]);
}, Wo = (a) => _(() => {
  const o = Te(a);
  return {
    "form-check-label": o.plain === !1 && o.button === !1,
    btn: o.button === !0,
    [`btn-${o.buttonVariant}`]: o.button === !0 && o.buttonVariant !== void 0 && o.buttonVariant !== null,
    [`btn-${o.size}`]: o.button && o.size && o.size !== "md"
  };
}), qo = (a) => {
  const o = k(a), e = ma(
    () => o.value.ariaInvalid,
    () => o.value.state
  );
  return _(() => ({
    "aria-invalid": e.value,
    "aria-required": o.value.required === !0 ? !0 : void 0
  }));
}, Go = (a) => _(() => {
  const o = Te(a);
  return {
    "was-validated": o.validated === !0,
    "btn-group": o.buttons === !0 && o.stacked === !1,
    "btn-group-vertical": o.stacked === !0 && o.buttons === !0,
    [`btn-group-${o.size}`]: o.size !== void 0
  };
}), we = (a, o) => _(() => Te(a) || Hr(o)), Hr = (a = "") => `__BVID__${Ve(Fo, () => Math.random().toString().slice(2, 8))()}___BV_${a}__`, Uo = (a, o, e) => {
  const l = F(null), t = we(() => a.id, "input"), s = he(() => a.debounce ?? 0), i = he(() => a.debounceMaxWait ?? NaN), u = Us(
    (p) => {
      o.value = p;
    },
    () => e.lazy === !0 ? 0 : s.value,
    { maxWait: () => e.lazy === !0 ? NaN : i.value }
  ), r = (p, B = !1) => {
    e.lazy === !0 && B === !1 || u(p);
  }, { focused: d } = Fe(l, {
    initialValue: a.autofocus
  }), c = (p, B, g = !1) => a.formatter !== void 0 && (!a.lazyFormatter || g) ? a.formatter(p, B) : p;
  Ue(() => {
    var p;
    l.value && (l.value.value = ((p = o.value) == null ? void 0 : p.toString()) ?? "");
  }), Pn(() => {
    Ie(() => {
      a.autofocus && (d.value = !0);
    });
  });
  const f = ma(
    () => a.ariaInvalid,
    () => a.state
  );
  return {
    input: l,
    computedId: t,
    computedAriaInvalid: f,
    onInput: (p) => {
      const { value: B } = p.target, g = c(B, p);
      if (p.defaultPrevented) {
        p.preventDefault();
        return;
      }
      r(g);
    },
    onChange: (p) => {
      const { value: B } = p.target, g = c(B, p);
      if (p.defaultPrevented) {
        p.preventDefault();
        return;
      }
      const S = g;
      o.value !== S && r(g, !0);
    },
    onBlur: (p) => {
      if (!e.lazy && !a.lazyFormatter)
        return;
      const { value: B } = p.target, g = c(B, p, !0), S = g;
      o.value !== S && r(g, !0);
    },
    focus: () => {
      a.disabled || (d.value = !0);
    },
    blur: () => {
      a.disabled || (d.value = !1);
    }
  };
}, Xo = (a, o) => {
  const e = (i) => typeof i == "object" && i !== null && "label" in i, l = (i) => {
    if (typeof i == "string")
      return { value: i, text: i };
    if (typeof i == "number")
      return { value: i, text: `${i}` };
    if (i instanceof Date)
      return { value: i, text: i.toLocaleString() };
    const u = Ee(i, o.valueField), r = Ee(i, o.textField), d = Ee(i, o.htmlField), c = Ee(i, o.disabledField), f = o.optionsField ? Ee(i, o.optionsField) : void 0;
    return f !== void 0 ? {
      label: Ee(i, o.labelField) || r,
      options: f
    } : {
      value: u,
      text: r,
      html: d,
      disabled: c
    };
  }, t = (i) => i.map((u) => l(u));
  return { normalizedOptions: _(() => t(Te(a))), isComplex: e };
}, ka = "modal-open", nl = () => {
  const a = Ve(Eo), o = (l) => {
    a == null || a.removeStack(l), a == null || a.removeRegistry(l);
  }, e = Qa("updateHTMLAttrs", (l, t, s) => {
    const i = typeof l == "string" ? window == null ? void 0 : window.document.querySelector(l) : We(l);
    i && (t === "class" ? i.classList.toggle(ka, s === ka) : i.setAttribute(t, s));
  });
  return dt(() => {
    e("body", "class", "");
  }), fe(
    () => a == null ? void 0 : a.countStack.value,
    (l) => {
      l !== void 0 && e("body", "class", l > 0 ? ka : "");
    }
  ), {
    ...a,
    dispose: o
  };
}, Mr = (a) => {
  const { pushRegistry: o, pushStack: e, removeStack: l, stack: t, dispose: s, countStack: i } = nl(), u = ht();
  if (!u || u.type.__name !== "BModal")
    throw new Error("useModalManager must only use in BModal component");
  return o == null || o(u), dt(() => {
    s(u);
  }), fe(
    a,
    (r, d) => {
      r ? e == null || e(u) : d && !r && (l == null || l(u));
    },
    { immediate: !0 }
  ), {
    activePosition: _(
      () => t == null ? void 0 : t.value.findIndex((r) => {
        var d, c;
        return ((d = r.exposed) == null ? void 0 : d.id) === ((c = u.exposed) == null ? void 0 : c.id);
      })
    ),
    activeModalCount: i
  };
}, Dr = (a = void 0) => {
  const { registry: o } = nl(), e = ht(), l = (i) => i.parent ? i.parent.type.__name === "BModal" ? i.parent : l(i.parent) : null, t = _(() => {
    const i = Te(a);
    return i ? (o == null ? void 0 : o.value.find((u) => {
      var r;
      return ((r = u.exposed) == null ? void 0 : r.id.value) === i;
    })) || null : e ? l(e) : null;
  }), s = k(() => {
    var i;
    return (i = t.value) == null ? void 0 : i.proxy;
  });
  return {
    show() {
      var i, u;
      (u = (i = t.value) == null ? void 0 : i.exposed) == null || u.show();
    },
    hide(i = "") {
      var u, r;
      (r = (u = t.value) == null ? void 0 : u.exposed) == null || r.hide(i);
    },
    modal: s
  };
}, Ko = () => {
  const { lastStack: a, stack: o } = nl();
  return {
    ...Ve(Io),
    hide: (s = "") => {
      var i;
      a != null && a.value && ((i = a == null ? void 0 : a.value.exposed) == null || i.hide(s));
    },
    hideAll: (s = "") => {
      o == null || o.value.forEach((i) => {
        var u;
        (u = i.exposed) == null || u.hide(s);
      });
    }
    // Todo: Supports listening events globally in the future
  };
}, pa = (a, o = "px") => _(() => {
  const e = Te(a), l = Te(o);
  return _r.test(String(e)) ? `${Number(e)}${l}` : e;
}), sl = (a) => {
  const o = (e, l) => {
    const t = l === null ? "" : `${l}-`;
    return e === "circle" ? `${t}rounded-circle` : e === "pill" ? `${t}rounded-pill` : typeof e == "number" || e === "0" || e === "1" || e === "2" || e === "3" || e === "4" || e === "5" ? `${t}rounded-${e}` : e === "none" ? `${t}rounded-0` : e === "sm" ? `${t}rounded-1` : e === "lg" ? `${t}rounded-5` : `${t}rounded`;
  };
  return _(() => {
    const e = Te(a);
    return {
      [`${o(e.rounded, null)}`]: !!e.rounded,
      [`${o(e.roundedTop, "top")}`]: !!e.roundedTop,
      [`${o(e.roundedBottom, "bottom")}`]: !!e.roundedBottom,
      [`${o(e.roundedStart, "start")}`]: !!e.roundedStart,
      [`${o(e.roundedEnd, "end")}`]: !!e.roundedEnd
    };
  });
}, jr = () => {
  const a = Ve(Po);
  return Ue(() => {
    fe(
      [() => a == null ? void 0 : a.isRtl.value, () => a == null ? void 0 : a.locale.value],
      ([o, e]) => {
        const l = document.documentElement;
        l.setAttribute("dir", o ?? !1 ? "rtl" : "ltr"), l.setAttribute("lang", e ?? "");
      },
      { immediate: !0 }
    );
  }), { ...a };
}, Yo = (a, o) => {
  const e = Ye(k(a)), l = Ye(k(o)), t = k(() => !l.value);
  Ue(() => {
    const s = cr(
      document.body,
      e.value && t.value
    );
    fe([e, t], ([i, u]) => {
      s.value = i && u;
    });
  });
}, Zo = (a, o, e = {}) => {
  const l = k(a), t = k(o), s = F(yt(l.value)), i = F(yt(t.value));
  fe([l, t], () => {
    B();
  });
  const {
    contentQuery: u = ":scope > [id]",
    targetQuery: r = "[href]",
    manual: d = !1,
    root: c,
    rootMargin: f = "0px 0px -25%",
    threshold: m = [0.1, 0.5, 1],
    watchChanges: v = !0
  } = e, y = F(null), h = F([]), C = F([]);
  ht() ? Ue(() => {
    Pa(l, s, {
      transform: {
        ltr: (P) => yt(P)
      },
      direction: "ltr",
      immediate: !0
    }), Pa(t, i, {
      transform: {
        ltr: (P) => yt(P)
      },
      direction: "ltr",
      immediate: !0
    }), B();
  }) : Ie(() => {
    B();
  });
  const B = () => {
    C.value = s.value ? Array.from(s.value.querySelectorAll(u)) : [], h.value = C.value.map((P) => ({
      id: P.id,
      el: P,
      visible: !1,
      text: P.textContent
    }));
  };
  let g = !0, S = 0;
  const w = _(
    () => s.value && getComputedStyle(s.value).overflowY === "visible" ? null : s.value
  ), x = rr(
    C,
    (P) => {
      var ne, U, T, A;
      const Y = (ne = w.value || (document == null ? void 0 : document.documentElement)) == null ? void 0 : ne.scrollTop;
      g = Y > S, S = Y, P.forEach((E) => {
        if (E.isIntersecting) {
          h.value.forEach((M) => {
            M.el === E.target && (M.visible = !0);
          });
          return;
        }
        h.value.forEach((M) => {
          M.el === E.target && (M.visible = !1);
        });
      });
      let ae = null;
      g ? ae = ((U = [...h.value].reverse().find((E) => E.visible)) == null ? void 0 : U.id) || null : ae = ((T = h.value.find((E) => E.visible)) == null ? void 0 : T.id) || null, ae !== null && (y.value = ae), y.value || (y.value = ((A = h.value[0]) == null ? void 0 : A.id) || null);
    },
    {
      root: c ? yt(c) : w,
      rootMargin: f,
      threshold: m
    }
  );
  fe(y, (P) => {
    var U;
    if (d)
      return;
    const Y = (U = i.value) == null ? void 0 : U.querySelectorAll(r);
    if (Y === void 0)
      return;
    let ae = !1, ne = null;
    Y.forEach((T) => {
      var E, M, Z, R, H, ce, le, q, oe, de, ee;
      const A = T.closest(".dropdown");
      if ((E = T.getAttribute("href")) != null && E.includes(`#${P}`)) {
        ne = T, T.classList.add("active"), A && ((M = A == null ? void 0 : A.querySelector(".dropdown-toggle")) == null || M.classList.add("active"), ae = !0);
        let re = (Z = T.closest(".nav")) == null ? void 0 : Z.previousSibling;
        for (; (R = re == null ? void 0 : re.classList) != null && R.contains("nav-item"); )
          ae = !0, (H = re.querySelector(".nav-link")) == null || H.classList.add("active"), re = (ce = re.closest(".nav")) == null ? void 0 : ce.previousSibling;
      } else if (T.classList.remove("active"), A && !ae && ((le = A == null ? void 0 : A.querySelector(".dropdown-toggle")) == null || le.classList.remove("active")), !ae) {
        let re = (q = T.closest(".nav")) == null ? void 0 : q.previousSibling;
        for (; (oe = re == null ? void 0 : re.classList) != null && oe.contains("nav-item"); )
          ae = !0, re.querySelector(".nav-link") !== ne && ((de = re.querySelector(".nav-link")) == null || de.classList.remove("active")), re = (ee = re.closest(".nav")) == null ? void 0 : ee.previousSibling;
      }
    });
  });
  const V = v ? Js(
    s,
    () => {
      B();
    },
    {
      childList: !0
    }
  ) : { stop: () => {
  } }, G = (P, Y = !1) => {
    var U, T;
    P.preventDefault();
    const ae = (T = (U = P.target) == null ? void 0 : U.getAttribute) == null ? void 0 : T.call(U, "href"), ne = ae ? document == null ? void 0 : document.querySelector(ae) : null;
    ne && s.value && (s.value.scrollTo ? s.value.scrollTo({ top: ne.offsetTop, behavior: Y ? "smooth" : "auto" }) : s.value.scrollTop = ne.offsetTop);
  }, W = () => {
    x.stop(), V.stop();
  };
  return {
    current: Ye(y),
    list: h,
    content: s,
    target: i,
    scrollIntoView: G,
    updateList: B,
    cleanup: W
  };
}, Jo = () => ({ ...Ve(Oo) }), Wr = (a) => _(() => {
  const o = {
    name: "",
    enterActiveClass: "",
    enterToClass: "",
    leaveActiveClass: "",
    leaveToClass: "showing",
    enterFromClass: "showing",
    leaveFromClass: "",
    css: !0
  }, e = {
    ...o,
    name: "fade",
    enterActiveClass: "fade showing",
    leaveActiveClass: "fade showing"
  };
  return Te(a) ? o : e;
}), qt = /* @__PURE__ */ z({
  __name: "BTransition",
  props: {
    appear: { type: Boolean, default: !1 },
    mode: { default: void 0 },
    noFade: { type: Boolean, default: !1 },
    transProps: { default: void 0 }
  },
  emits: ["after-appear", "after-enter", "after-leave", "appear", "before-appear", "before-enter", "before-leave", "enter", "appear-cancelled", "enter-cancelled", "leave", "leave-cancelled"],
  setup(a, { emit: o }) {
    const l = j(a, "BTransition"), t = o, s = _(() => {
      const u = {
        name: "",
        enterActiveClass: "",
        enterToClass: "",
        leaveActiveClass: "",
        leaveToClass: "showing",
        enterFromClass: "showing",
        leaveFromClass: ""
      }, r = {
        ...u,
        enterActiveClass: "fade showing",
        leaveActiveClass: "fade showing"
      };
      return l.noFade ? u : r;
    }), i = _(() => ({ mode: l.mode, css: !0, ...s.value }));
    return (u, r) => (b(), N(Wl, K({ ...i.value, ...n(l).transProps }, {
      appear: n(l).appear,
      onAfterAppear: r[0] || (r[0] = (d) => t("after-appear", d)),
      onAfterEnter: r[1] || (r[1] = (d) => t("after-enter", d)),
      onAfterLeave: r[2] || (r[2] = (d) => t("after-leave", d)),
      onAppear: r[3] || (r[3] = (d) => t("appear", d)),
      onBeforeAppear: r[4] || (r[4] = (d) => t("before-appear", d)),
      onBeforeEnter: r[5] || (r[5] = (d) => t("before-enter", d)),
      onBeforeLeave: r[6] || (r[6] = (d) => t("before-leave", d)),
      onEnter: r[7] || (r[7] = (d) => t("enter", d)),
      onAppearCancelled: r[8] || (r[8] = (d) => t("appear-cancelled", d)),
      onEnterCancelled: r[9] || (r[9] = (d) => t("enter-cancelled", d)),
      onLeave: r[10] || (r[10] = (d) => t("leave", d)),
      onLeaveCancelled: r[11] || (r[11] = (d) => t("leave-cancelled", d))
    }), {
      default: I(() => [
        $(u.$slots, "default")
      ]),
      _: 3
    }, 16, ["appear"]));
  }
}), qr = ["type", "disabled", "aria-label"], Et = /* @__PURE__ */ z({
  __name: "BCloseButton",
  props: {
    ariaLabel: { default: "Close" },
    disabled: { type: Boolean, default: !1 },
    type: { default: "button" }
  },
  emits: ["click"],
  setup(a, { emit: o }) {
    const l = j(a, "BCloseButton"), t = o;
    return (s, i) => (b(), O("button", {
      type: n(l).type,
      class: "btn-close",
      disabled: n(l).disabled,
      "aria-label": n(l).ariaLabel,
      onClick: i[0] || (i[0] = (u) => t("click", u))
    }, null, 8, qr));
  }
}), Sl = "active", st = /* @__PURE__ */ z({
  __name: "BLink",
  props: {
    active: { type: Boolean, default: void 0 },
    activeClass: { default: "router-link-active" },
    disabled: { type: Boolean, default: !1 },
    exactActiveClass: { default: "router-link-exact-active" },
    href: { default: void 0 },
    icon: { type: Boolean, default: !1 },
    stretched: { type: Boolean, default: !1 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: !1 },
    routerComponentName: { default: "router-link" },
    routerTag: { default: "a" },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: null },
    variant: { default: null },
    prefetch: { type: Boolean },
    noPrefetch: { type: Boolean },
    prefetchedClass: {},
    noRel: { type: Boolean }
  },
  emits: ["click"],
  setup(a, { emit: o }) {
    const l = j(a, "BLink"), t = o, s = Mt(), i = Ve(al, null), u = Ve(ll, null), r = ht(), d = _(() => {
      const h = l.routerComponentName.split("-").map((p) => p.charAt(0).toUpperCase() + p.slice(1)).join("");
      return !((r == null ? void 0 : r.appContext.app.component(h)) !== void 0) || l.disabled || !l.to ? "a" : l.routerComponentName;
    }), c = _(() => {
      const h = "#";
      if (l.href)
        return l.href;
      if (typeof l.to == "string")
        return l.to || h;
      const { to: C } = l;
      if (C !== void 0 && "path" in C) {
        const p = C.path || "", B = C.query ? `?${Object.keys(C.query).map((S) => {
          var w;
          return `${S}=${(w = C.query) == null ? void 0 : w[S]}`;
        }).join("=")}` : "", g = !C.hash || C.hash.charAt(0) === "#" ? C.hash || "" : `#${C.hash}`;
        return `${p}${B}${g}` || h;
      }
      return h;
    }), f = _(() => ({
      [`link-${l.variant}`]: l.variant !== null,
      [`link-opacity-${l.opacity}`]: l.opacity !== void 0,
      [`link-opacity-${l.opacityHover}-hover`]: l.opacityHover !== void 0,
      [`link-underline-${l.underlineVariant}`]: l.underlineVariant !== null,
      [`link-offset-${l.underlineOffset}`]: l.underlineOffset !== void 0,
      [`link-offset-${l.underlineOffsetHover}-hover`]: l.underlineOffsetHover !== void 0,
      [`link-underline-opacity-${l.underlineOpacity}`]: l.underlineOpacity !== void 0,
      [`link-underline-opacity-${l.underlineOpacityHover}-hover`]: l.underlineOpacityHover !== void 0,
      "icon-link": l.icon === !0,
      "stretched-link": l.stretched === !0
    })), m = _(() => ({
      class: f.value,
      to: l.to,
      replace: l.replace,
      href: c.value,
      target: l.target,
      rel: l.target === "_blank" ? l.rel ?? "noopener" : void 0,
      tabindex: l.disabled ? "-1" : typeof s.tabindex > "u" ? null : s.tabindex,
      "aria-disabled": l.disabled ? !0 : null
    })), v = _(() => ({
      [Sl]: l.active,
      disabled: l.disabled
    })), y = (h) => {
      var C, p, B;
      if (l.disabled) {
        h.preventDefault(), h.stopImmediatePropagation();
        return;
      }
      (((C = i == null ? void 0 : i.isNav) == null ? void 0 : C.value) === !0 && u === null || u !== null && ((p = u.autoClose) == null ? void 0 : p.value) === !0) && ((B = i == null ? void 0 : i.hide) == null || B.call(i)), t("click", h);
    };
    return (h, C) => d.value === "router-link" ? (b(), N(ue(d.value), K({ key: 0 }, m.value, { custom: "" }), {
      default: I(({ href: p, navigate: B, isActive: g, isExactActive: S }) => [
        (b(), N(ue(n(l).routerTag), K({
          href: p,
          class: {
            [Sl]: n(l).active,
            [n(l).activeClass]: g,
            [n(l).exactActiveClass]: S
          }
        }, h.$attrs, {
          onClick: (w) => {
            B(w), y(w);
          }
        }), {
          default: I(() => [
            $(h.$slots, "default")
          ]),
          _: 2
        }, 1040, ["href", "class", "onClick"]))
      ]),
      _: 3
    }, 16)) : (b(), N(ue(d.value), K({
      key: 1,
      class: v.value
    }, m.value, { onClick: y }), {
      default: I(() => [
        $(h.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Gr = ["aria-valuenow", "aria-valuemax"], Qo = /* @__PURE__ */ z({
  __name: "BProgressBar",
  props: {
    animated: { type: Boolean, default: !1 },
    label: { default: void 0 },
    labelHtml: { default: void 0 },
    max: { default: void 0 },
    precision: { default: 0 },
    showProgress: { type: Boolean, default: !1 },
    showValue: { type: Boolean, default: !1 },
    striped: { type: Boolean, default: !1 },
    value: { default: 0 },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(a) {
    const e = j(a, "BProgressBar"), l = Ve(ko, null), t = ot(e), s = _(() => [
      t.value,
      {
        "progress-bar-animated": e.animated || (l == null ? void 0 : l.animated.value),
        "progress-bar-striped": e.striped || (l == null ? void 0 : l.striped.value) || e.animated || (l == null ? void 0 : l.animated.value)
      }
    ]), i = he(() => e.precision), u = he(() => e.value), r = he(() => e.max ?? NaN), d = he(() => (l == null ? void 0 : l.max.value) ?? NaN), c = _(
      () => e.labelHtml !== void 0 ? e.labelHtml : e.showValue || l != null && l.showValue.value ? u.value.toFixed(i.value) : e.showProgress || l != null && l.showProgress.value ? (u.value * 100 / (r.value || 100)).toFixed(i.value) : e.label !== void 0 ? e.label : ""
    ), f = _(
      () => d.value ? `${u.value * 100 / d.value}%` : r.value ? `${u.value * 100 / r.value}%` : typeof e.value == "string" ? e.value : `${e.value}%`
    );
    return (m, v) => (b(), O("div", {
      class: D(["progress-bar", s.value]),
      role: "progressbar",
      "aria-valuenow": n(e).value,
      "aria-valuemin": "0",
      "aria-valuemax": n(e).max,
      style: Le({ width: f.value })
    }, [
      $(m.$slots, "default", {}, () => [
        se(J(c.value), 1)
      ])
    ], 14, Gr));
  }
}), en = /* @__PURE__ */ z({
  __name: "BProgress",
  props: {
    height: { default: void 0 },
    animated: { type: Boolean, default: void 0 },
    max: { default: 100 },
    precision: { default: void 0 },
    showProgress: { type: Boolean, default: void 0 },
    showValue: { type: Boolean, default: void 0 },
    striped: { type: Boolean, default: void 0 },
    value: { default: void 0 },
    variant: { default: void 0 },
    bgVariant: { default: void 0 },
    textVariant: { default: void 0 }
  },
  setup(a) {
    const e = j(a, "BProgress");
    return Xe(ko, {
      animated: k(() => e.animated),
      max: k(() => e.max),
      showProgress: k(() => e.showProgress),
      showValue: k(() => e.showValue),
      striped: k(() => e.striped)
    }), (l, t) => (b(), O("div", {
      class: "progress",
      style: Le({ height: n(e).height })
    }, [
      $(l.$slots, "default", {}, () => [
        be(Qo, {
          animated: n(e).animated,
          max: n(e).max,
          precision: n(e).precision,
          "show-progress": n(e).showProgress,
          "show-value": n(e).showValue,
          striped: n(e).striped,
          value: n(e).value,
          variant: n(e).variant,
          "text-variant": n(e).textVariant,
          "bg-variant": n(e).bgVariant
        }, null, 8, ["animated", "max", "precision", "show-progress", "show-value", "striped", "value", "variant", "text-variant", "bg-variant"])
      ])
    ], 4));
  }
}), Ur = ["id", "role", "aria-live", "aria-atomic"], Xr = { class: "me-auto" }, tn = /* @__PURE__ */ z({
  __name: "BToast",
  props: /* @__PURE__ */ ye({
    body: { default: void 0 },
    bodyClass: { default: void 0 },
    headerClass: { default: void 0 },
    headerTag: { default: "div" },
    id: { default: void 0 },
    interval: { default: 1e3 },
    isStatus: { type: Boolean, default: !1 },
    modelValue: { type: [Boolean, Number] },
    noCloseButton: { type: Boolean, default: !1 },
    noFade: { type: Boolean, default: !1 },
    noHoverPause: { type: Boolean, default: !1 },
    progressProps: { default: void 0 },
    showOnPause: { type: Boolean, default: !0 },
    solid: { type: Boolean, default: !1 },
    title: { default: void 0 },
    toastClass: { default: void 0 },
    transProps: { default: void 0 },
    variant: { default: void 0 },
    bgVariant: { default: null },
    textVariant: { default: null },
    active: { type: Boolean, default: void 0 },
    activeClass: { default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    stretched: { type: Boolean, default: !1 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    prefetch: { type: Boolean },
    noPrefetch: { type: Boolean },
    prefetchedClass: {},
    noRel: { type: Boolean }
  }, {
    modelValue: { type: [Boolean, Number], default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ ye(["close", "close-countdown", "hide", "hidden", "show", "shown", "show-prevented", "hide-prevented"], ["update:modelValue"]),
  setup(a, { expose: o, emit: e }) {
    const t = j(a, "BToast"), s = e, i = F(null), u = el(i), r = _e(a, "modelValue"), { computedLink: d, computedLinkProps: c } = wt(t), f = he(() => t.interval), m = ot(t), v = k(() => typeof r.value == "boolean" ? 0 : r.value), {
      isActive: y,
      pause: h,
      restart: C,
      resume: p,
      stop: B,
      isPaused: g,
      value: S
    } = Ro(v, f, {
      immediate: typeof r.value == "number"
    });
    Nt(() => {
      s("close-countdown", S.value);
    });
    const w = k(() => d.value ? st : "div"), x = k(
      () => typeof r.value == "boolean" ? r.value : y.value || t.showOnPause && g.value
    ), V = _(() => [
      m.value,
      {
        show: x.value
      }
    ]), G = () => {
      t.noHoverPause || h();
    };
    fe(u, (T) => {
      if (T) {
        G();
        return;
      }
      p();
    });
    const W = (T, A = {}) => new _t(T, {
      cancelable: !1,
      target: i.value || null,
      relatedTarget: null,
      trigger: null,
      ...A,
      componentId: t.id
    }), P = () => {
      const T = W("show", { cancelable: !0 });
      if (s("show", T), T.defaultPrevented) {
        r.value && (r.value = !1), s("show-prevented");
        return;
      }
      r.value || (r.value = !0);
    }, Y = (T = "") => {
      const A = W("hide", { cancelable: T !== "", trigger: T });
      if (s("hide", A), T === "close" && s("close", A), A.defaultPrevented) {
        s("hide-prevented"), r.value || (r.value = !0);
        return;
      }
      typeof r.value == "boolean" ? r.value = !1 : (r.value = 0, B());
    }, ae = () => {
      P();
    }, ne = () => {
      s("shown", W("shown"));
    }, U = () => {
      s("hidden", W("hidden"));
    };
    return fe(y, (T) => {
      T === !1 && g.value === !1 && r.value && Y();
    }), Da(B), o({
      pause: h,
      restart: C,
      resume: p,
      stop: B
    }), (T, A) => (b(), N(qt, K({
      "no-fade": n(t).noFade
    }, n(t).transProps, {
      onBeforeEnter: ae,
      onAfterEnter: ne,
      onAfterLeave: U
    }), {
      default: I(() => [
        x.value ? (b(), O("div", {
          key: 0,
          id: n(t).id,
          ref_key: "element",
          ref: i,
          class: D(["toast", [n(t).toastClass, V.value]]),
          tabindex: "0",
          role: x.value ? n(t).isStatus ? "status" : "alert" : void 0,
          "aria-live": x.value ? n(t).isStatus ? "polite" : "assertive" : void 0,
          "aria-atomic": x.value ? !0 : void 0
        }, [
          T.$slots.title || n(t).title ? (b(), N(ue(n(t).headerTag), {
            key: 0,
            class: "toast-header"
          }, {
            default: I(() => [
              $(T.$slots, "title", { hide: Y }, () => [
                Q("strong", Xr, J(n(t).title), 1)
              ]),
              n(t).noCloseButton ? te("", !0) : (b(), N(Et, {
                key: 0,
                onClick: A[0] || (A[0] = (E) => Y("close"))
              }))
            ]),
            _: 3
          })) : te("", !0),
          T.$slots.default || n(t).body ? (b(), N(ue(w.value), K({
            key: 1,
            class: ["toast-body", n(t).bodyClass],
            style: { display: "block" }
          }, n(c), {
            onClick: A[1] || (A[1] = (E) => n(d) ? Y() : () => {
            })
          }), {
            default: I(() => [
              $(T.$slots, "default", { hide: Y }, () => [
                se(J(n(t).body), 1)
              ])
            ]),
            _: 3
          }, 16, ["class"])) : te("", !0),
          typeof r.value == "number" && n(t).progressProps !== void 0 ? (b(), N(en, {
            key: 2,
            animated: n(t).progressProps.animated,
            precision: n(t).progressProps.precision,
            "show-progress": n(t).progressProps.showProgress,
            "show-value": n(t).progressProps.showValue,
            striped: n(t).progressProps.striped,
            variant: n(t).progressProps.variant,
            max: r.value,
            value: n(S),
            height: "4px"
          }, null, 8, ["animated", "precision", "show-progress", "show-value", "striped", "variant", "max", "value"])) : te("", !0)
        ], 10, Ur)) : te("", !0)
      ]),
      _: 3
    }, 16, ["no-fade"]));
  }
}), Kr = "top-end", Yr = {
  install(a) {
    const o = F([]), e = F(!1), l = (u) => {
      e.value = u;
    }, t = (u) => {
      var f;
      const r = Symbol(), d = F(((f = Te(u.props)) == null ? void 0 : f.value) || 5e3), c = _({
        get: () => {
          const m = Te(u.props);
          return {
            component: Te(u.component) ?? tn,
            props: {
              ...m,
              pos: (m == null ? void 0 : m.pos) || Kr,
              _modelValue: d.value,
              _self: r
            }
          };
        },
        set: (m) => {
          d.value = m.props._modelValue;
        }
      });
      return (c.value.props.appendToast !== void 0 ? c.value.props.appendToast : e.value) ? o.value.push(c) : o.value.unshift(c), r;
    }, s = (u) => {
      o.value = o.value.filter((r) => r.value.props._self !== u);
    }, i = (u) => {
      const r = o.value.find((d) => d.value.props._self === u);
      r !== void 0 && (r.value = {
        ...r.value,
        props: {
          ...r.value.props,
          _modelValue: !1
        }
      });
    };
    a.provide(Oo, {
      _setIsAppend: l,
      toasts: o,
      show: t,
      remove: s,
      leave: i
    });
  }
}, Zr = {
  install(a) {
    const o = F([]), e = () => {
      o.value.splice(0, o.value.length);
    };
    a.provide(No, { items: o, reset: e });
  }
}, Jr = {
  install(a, o) {
    (o == null ? void 0 : o.id) instanceof Object && typeof o.id.getId == "function" && a.provide(Fo, o.id.getId);
  }
}, Qr = {
  key: 0,
  class: "visually-hidden"
}, ha = /* @__PURE__ */ z({
  __name: "BSpinner",
  props: {
    label: { default: void 0 },
    role: { default: "status" },
    small: { type: Boolean, default: !1 },
    tag: { default: "span" },
    type: { default: "border" },
    variant: { default: null }
  },
  setup(a) {
    const e = j(a, "BSpinner"), l = Re(), t = _(() => [
      `spinner-${e.type}`,
      {
        [`spinner-${e.type}-sm`]: e.small,
        [`text-${e.variant}`]: e.variant !== null
      }
    ]), s = k(() => !Ae(l.label));
    return (i, u) => (b(), N(ue(n(e).tag), {
      class: D(t.value),
      role: n(e).label || s.value ? n(e).role : null,
      "aria-hidden": n(e).label || s.value ? null : !0
    }, {
      default: I(() => [
        n(e).label || s.value ? (b(), O("span", Qr, [
          $(i.$slots, "label", {}, () => [
            se(J(n(e).label), 1)
          ])
        ])) : te("", !0)
      ]),
      _: 3
    }, 8, ["class", "role", "aria-hidden"]));
  }
}), pt = /* @__PURE__ */ z({
  __name: "BButton",
  props: /* @__PURE__ */ ye({
    loading: { type: Boolean, default: !1 },
    loadingFill: { type: Boolean, default: !1 },
    loadingText: { default: "Loading..." },
    pill: { type: Boolean, default: !1 },
    pressed: { type: Boolean },
    size: { default: "md" },
    squared: { type: Boolean, default: !1 },
    tag: { default: "button" },
    type: { default: "button" },
    variant: { default: "secondary" },
    active: { type: Boolean, default: !1 },
    activeClass: { default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    stretched: { type: Boolean, default: !1 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    routerTag: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    prefetch: { type: Boolean },
    noPrefetch: { type: Boolean },
    prefetchedClass: {},
    noRel: { type: Boolean }
  }, {
    pressed: { type: Boolean, default: void 0 },
    pressedModifiers: {}
  }),
  emits: /* @__PURE__ */ ye(["click"], ["update:pressed"]),
  setup(a, { emit: o }) {
    const l = j(a, "BButton"), t = o, s = _e(a, "pressed"), { computedLink: i, computedLinkProps: u } = wt(l, [
      "active-class",
      "exact-active-class",
      "replace",
      "routerComponentName",
      "routerTag"
    ]), r = k(() => typeof l.pressed == "boolean"), d = k(
      () => l.tag === "button" && l.href === void 0 && l.to === void 0
    ), c = k(() => l.to !== void 0), f = k(() => l.href !== void 0 ? !1 : !d.value), m = _(() => c.value ? u.value : []), v = _(() => [
      [`btn-${l.size}`],
      {
        [`btn-${l.variant}`]: l.variant !== null,
        active: l.active || l.pressed,
        "rounded-pill": l.pill,
        "rounded-0": l.squared,
        disabled: l.disabled
      }
    ]), y = k(() => c.value ? st : l.href ? "a" : l.tag), h = (C) => {
      if (l.disabled) {
        C.preventDefault(), C.stopPropagation();
        return;
      }
      t("click", C), r.value && (s.value = !l.pressed);
    };
    return (C, p) => (b(), N(ue(y.value), K({ class: "btn" }, m.value, {
      class: v.value,
      "aria-disabled": f.value ? n(l).disabled : null,
      "aria-pressed": r.value ? n(l).pressed : null,
      autocomplete: r.value ? "off" : null,
      disabled: d.value ? n(l).disabled : null,
      href: n(l).href,
      rel: n(i) ? n(l).rel : null,
      role: f.value || n(i) ? "button" : null,
      target: n(i) ? n(l).target : null,
      type: d.value ? n(l).type : null,
      to: d.value ? null : n(l).to,
      onClick: h
    }), {
      default: I(() => [
        n(l).loading ? $(C.$slots, "loading", { key: 0 }, () => [
          n(l).loadingFill ? te("", !0) : (b(), O(pe, { key: 0 }, [
            se(J(n(l).loadingText), 1)
          ], 64)),
          $(C.$slots, "loading-spinner", {}, () => [
            be(ha, {
              small: n(l).size !== "lg",
              label: n(l).loadingFill ? n(l).loadingText : void 0
            }, null, 8, ["small", "label"])
          ])
        ]) : $(C.$slots, "default", { key: 1 })
      ]),
      _: 3
    }, 16, ["class", "aria-disabled", "aria-pressed", "autocomplete", "disabled", "href", "rel", "role", "target", "type", "to"]));
  }
}), Gt = z({
  name: "RenderComponentOrSkip",
  inheritAttrs: !1,
  slots: Object,
  props: {
    tag: {
      type: String,
      default: "div"
    },
    to: {
      type: [String, Object],
      default: null
    },
    skip: {
      type: Boolean,
      default: !1
    }
  },
  setup(a, { slots: o, attrs: e }) {
    return () => {
      var l, t, s;
      return a.skip ? (l = o.default) == null ? void 0 : l.call(o) : a.tag === "Teleport" ? Pe(Bt, { to: a.to }, [(t = o.default) == null ? void 0 : t.call(o)]) : Pe(a.tag, { ...e }, [(s = o.default) == null ? void 0 : s.call(o)]);
    };
  }
}), Ba = /* @__PURE__ */ z({
  __name: "BOverlay",
  props: {
    bgColor: { default: void 0 },
    blur: { default: "2px" },
    fixed: { type: Boolean, default: !1 },
    noCenter: { type: Boolean, default: !1 },
    noFade: { type: Boolean, default: !1 },
    noSpinner: { type: Boolean, default: !1 },
    noWrap: { type: Boolean, default: !1 },
    opacity: { default: 0.85 },
    overlayTag: { default: "div" },
    show: { type: Boolean, default: !1 },
    spinnerSmall: { type: Boolean, default: !1 },
    spinnerType: { default: "border" },
    spinnerVariant: { default: void 0 },
    variant: { default: "light" },
    wrapTag: { default: "div" },
    zIndex: { default: 10 },
    rounded: { type: [Boolean, String, Number], default: !1 },
    roundedTop: { type: [Boolean, String, Number], default: void 0 },
    roundedBottom: { type: [Boolean, String, Number], default: void 0 },
    roundedStart: { type: [Boolean, String, Number], default: void 0 },
    roundedEnd: { type: [Boolean, String, Number], default: void 0 }
  },
  emits: ["click", "hidden", "shown"],
  setup(a, { emit: o }) {
    const l = j(a, "BOverlay"), t = o, s = { top: 0, left: 0, bottom: 0, right: 0 }, i = sl(() => ({
      rounded: l.rounded,
      roundedTop: l.roundedTop,
      roundedBottom: l.roundedBottom,
      roundedStart: l.roundedStart,
      roundedEnd: l.roundedEnd
    })), u = k(
      () => l.variant !== null && !l.bgColor ? `bg-${l.variant}` : ""
    ), r = k(() => l.show ? !0 : null), d = _(() => ({
      type: l.spinnerType,
      variant: l.spinnerVariant,
      small: l.spinnerSmall
    })), c = _(() => ({
      ...s,
      zIndex: l.zIndex || 10
    })), f = _(() => ({
      "position-absolute": !l.noWrap || !l.fixed,
      "position-fixed": l.noWrap && l.fixed
    })), m = _(() => [u.value, i.value]), v = _(() => ({
      ...s,
      opacity: l.opacity,
      backgroundColor: l.bgColor || void 0,
      backdropFilter: l.blur ? `blur(${l.blur})` : void 0
    })), y = _(
      () => l.noCenter ? s : {
        top: "50%",
        left: "50%",
        transform: "translateX(-50%) translateY(-50%)"
      }
    );
    return (h, C) => (b(), N(Gt, {
      tag: n(l).wrapTag,
      class: "b-overlay-wrap position-relative",
      "aria-busy": r.value,
      skip: n(l).noWrap
    }, {
      default: I(() => [
        $(h.$slots, "default"),
        be(qt, {
          "no-fade": n(l).noFade,
          "trans-props": { enterToClass: "show" },
          name: "fade",
          onAfterEnter: C[1] || (C[1] = (p) => t("shown")),
          onAfterLeave: C[2] || (C[2] = (p) => t("hidden"))
        }, {
          default: I(() => [
            n(l).show ? (b(), N(ue(n(l).overlayTag), {
              key: 0,
              class: D(["b-overlay", f.value]),
              style: Le(c.value),
              onClick: C[0] || (C[0] = (p) => t("click", p))
            }, {
              default: I(() => [
                Q("div", {
                  class: D(["position-absolute", m.value]),
                  style: Le(v.value)
                }, null, 6),
                Q("div", {
                  class: "position-absolute",
                  style: Le(y.value)
                }, [
                  $(h.$slots, "overlay", Be(Ce(d.value)), () => [
                    n(l).noSpinner ? te("", !0) : (b(), N(ha, Be(K({ key: 0 }, d.value)), null, 16))
                  ])
                ], 4)
              ]),
              _: 3
            }, 8, ["class", "style"])) : te("", !0)
          ]),
          _: 3
        }, 8, ["no-fade"])
      ]),
      _: 3
    }, 8, ["tag", "aria-busy", "skip"]));
  }
}), ei = ["id", "aria-labelledby", "aria-describedby"], ti = ["id"], Vl = 1056, ai = /* @__PURE__ */ z({
  inheritAttrs: !1,
  __name: "BModal",
  props: /* @__PURE__ */ ye({
    autoFocus: { type: Boolean, default: !0 },
    autoFocusButton: { default: void 0 },
    body: { default: void 0 },
    backdropVariant: { default: void 0 },
    bodyAttrs: { default: void 0 },
    bodyBgVariant: { default: null },
    bodyClass: { default: null },
    bodyScrolling: { type: Boolean, default: !1 },
    bodyTextVariant: { default: null },
    bodyVariant: { default: null },
    busy: { type: Boolean, default: !1 },
    buttonSize: { default: "md" },
    cancelDisabled: { type: Boolean, default: !1 },
    cancelTitle: { default: "Cancel" },
    cancelVariant: { default: "secondary" },
    centered: { type: Boolean, default: !1 },
    contentClass: { default: void 0 },
    dialogClass: { default: void 0 },
    footerBgVariant: { default: null },
    footerBorderVariant: { default: null },
    footerClass: { default: void 0 },
    footerTextVariant: { default: null },
    footerVariant: { default: null },
    fullscreen: { type: [Boolean, String], default: !1 },
    headerBgVariant: { default: null },
    headerBorderVariant: { default: null },
    headerClass: { default: void 0 },
    headerCloseClass: { default: void 0 },
    headerCloseLabel: { default: "Close" },
    headerCloseVariant: { default: "secondary" },
    headerTextVariant: { default: null },
    headerVariant: { default: null },
    hideBackdrop: { type: Boolean, default: !1 },
    hideFooter: { type: Boolean, default: !1 },
    hideHeader: { type: Boolean, default: !1 },
    hideHeaderClose: { type: Boolean, default: !1 },
    id: { default: void 0 },
    lazy: { type: Boolean, default: !1 },
    modalClass: { default: void 0 },
    modelValue: { type: Boolean },
    noCloseOnBackdrop: { type: Boolean, default: !1 },
    noCloseOnEsc: { type: Boolean, default: !1 },
    noFade: { type: Boolean, default: !1 },
    okDisabled: { type: Boolean, default: !1 },
    okOnly: { type: Boolean, default: !1 },
    okTitle: { default: "Ok" },
    okVariant: { default: "primary" },
    scrollable: { type: Boolean, default: !1 },
    size: { default: "md" },
    title: { default: void 0 },
    titleClass: { default: void 0 },
    titleSrOnly: { type: Boolean, default: !1 },
    titleTag: { default: "h5" },
    transProps: { default: void 0 },
    teleportDisabled: { default: !1 },
    teleportTo: { default: "body" }
  }, {
    modelValue: { type: Boolean, default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ ye(["cancel", "close", "hidden", "hide", "hide-prevented", "ok", "show", "show-prevented", "shown"], ["update:modelValue"]),
  setup(a, { expose: o, emit: e }) {
    const t = j(a, "BModal"), s = e, i = Re(), u = we(() => t.id, "modal"), r = _e(a, "modelValue"), d = F(null), c = F(null), f = F(null), m = F(null), v = F(!1), y = F(!1), h = Wr(!0);
    De(
      "Escape",
      () => {
        R("esc");
      },
      { target: d }
    ), Yo(r, () => t.bodyScrolling);
    const { focused: C } = Fe(d, {
      initialValue: r.value && t.autoFocusButton === void 0
    }), { focused: p } = Fe(c, {
      initialValue: r.value && t.autoFocusButton === "ok"
    }), { focused: B } = Fe(f, {
      initialValue: r.value && t.autoFocusButton === "cancel"
    }), { focused: g } = Fe(m, {
      initialValue: r.value && t.autoFocusButton === "close"
    }), S = _(() => [
      t.modalClass,
      {
        fade: !t.noFade,
        show: v.value
      }
    ]), w = k(
      () => t.lazy === !1 || t.lazy === !0 && y.value === !0 || t.lazy === !0 && r.value === !0
    ), x = k(
      () => t.backdropVariant !== void 0 ? t.backdropVariant : t.hideBackdrop ? "transparent" : "dark"
    ), V = k(() => !Ae(i["header-close"])), G = _(() => [
      t.dialogClass,
      {
        "modal-fullscreen": t.fullscreen === !0,
        [`modal-fullscreen-${t.fullscreen}-down`]: typeof t.fullscreen == "string",
        [`modal-${t.size}`]: t.size !== "md",
        "modal-dialog-centered": t.centered,
        "modal-dialog-scrollable": t.scrollable
      }
    ]), W = ot(() => ({
      bgVariant: t.bodyBgVariant,
      textVariant: t.bodyTextVariant,
      variant: t.bodyVariant
    })), P = _(() => [t.bodyClass, W.value]), Y = ot(() => ({
      bgVariant: t.headerBgVariant,
      textVariant: t.headerTextVariant,
      variant: t.headerVariant
    })), ae = _(() => [
      t.headerClass,
      Y.value,
      {
        [`border-${t.headerBorderVariant}`]: t.headerBorderVariant !== null
      }
    ]), ne = _(() => ({
      variant: V.value ? t.headerCloseVariant : void 0,
      class: t.headerCloseClass
    })), U = ot(() => ({
      bgVariant: t.footerBgVariant,
      textVariant: t.footerTextVariant,
      variant: t.footerVariant
    })), T = _(() => [
      t.footerClass,
      U.value,
      {
        [`border-${t.footerBorderVariant}`]: t.footerBorderVariant !== null
      }
    ]), A = _(() => [
      t.titleClass,
      {
        "visually-hidden": t.titleSrOnly
      }
    ]), E = k(() => t.cancelDisabled || t.busy), M = k(() => t.okDisabled || t.busy), Z = (L, X = {}) => new _t(L, {
      cancelable: !1,
      target: d.value || null,
      relatedTarget: null,
      trigger: null,
      ...X,
      componentId: u.value
    });
    fe(r, (L, X) => {
      L !== X && (L === !0 ? H() : R());
    });
    const R = (L = "") => {
      if (L === "backdrop" && t.noCloseOnBackdrop || L === "esc" && t.noCloseOnEsc) {
        s("hide-prevented");
        return;
      }
      const X = Z("hide", { cancelable: L !== "", trigger: L });
      if (L === "ok" && s(L, X), L === "cancel" && s(L, X), L === "close" && s(L, X), s("hide", X), X.defaultPrevented) {
        s("hide-prevented"), r.value || (r.value = !0);
        return;
      }
      r.value && (r.value = !1);
    }, H = () => {
      if (v.value)
        return;
      const L = Z("show", { cancelable: !0 });
      if (s("show", L), L.defaultPrevented) {
        r.value && (r.value = !1), s("show-prevented");
        return;
      }
      r.value || (r.value = !0);
    }, ce = () => {
      t.autoFocus !== !1 && (t.autoFocusButton === "ok" ? p.value = !0 : t.autoFocusButton === "close" ? g.value = !0 : t.autoFocusButton === "cancel" ? B.value = !0 : C.value = !0);
    }, le = () => {
      H();
    }, q = () => {
      v.value = !0, ce(), s("shown", Z("shown")), t.lazy === !0 && (y.value = !0);
    }, oe = () => {
      v.value = !1;
    }, de = () => {
      s("hidden", Z("hidden")), t.lazy === !0 && (y.value = !1);
    }, { activePosition: ee, activeModalCount: re } = Mr(v), ie = _(() => ({
      // Make sure that newly opened modals have a higher z-index than currently active ones.
      // All active modals have a z-index of ('defaultZIndex' - 'stackSize' - 'positionInStack').
      //
      // This means inactive modals will already be higher than active ones when opened.
      "z-index": v.value ? Vl - (((re == null ? void 0 : re.value) ?? 0) - ((ee == null ? void 0 : ee.value) ?? 0)) : Vl
    }));
    $e(d, "bv-toggle", () => {
      r.value ? R() : H();
    });
    const ve = _(() => ({
      cancel: () => {
        R("cancel");
      },
      close: () => {
        R("close");
      },
      hide: R,
      ok: () => {
        R("ok");
      },
      visible: r.value
    }));
    return o({
      hide: R,
      id: u,
      show: H
    }), (L, X) => (b(), N(Bt, {
      to: n(t).teleportTo,
      disabled: n(t).teleportDisabled
    }, [
      be(Wl, K({ ...n(h), ...n(t).transProps, enterToClass: "show" }, {
        appear: r.value,
        onBeforeEnter: le,
        onAfterEnter: q,
        onLeave: oe,
        onAfterLeave: de
      }), {
        default: I(() => [
          ct(Q("div", K({
            id: n(u),
            ref_key: "element",
            ref: d,
            class: ["modal", S.value],
            role: "dialog",
            "aria-labelledby": n(t).hideHeader ? void 0 : `${n(u)}-label`,
            "aria-describedby": `${n(u)}-body`,
            tabindex: "-1"
          }, L.$attrs, { style: ie.value }), [
            Q("div", {
              class: D(["modal-dialog", G.value])
            }, [
              w.value ? (b(), O("div", {
                key: 0,
                class: D(["modal-content", n(t).contentClass])
              }, [
                n(t).hideHeader ? te("", !0) : (b(), O("div", {
                  key: 0,
                  class: D(["modal-header", ae.value])
                }, [
                  $(L.$slots, "header", Be(Ce(ve.value)), () => [
                    (b(), N(ue(n(t).titleTag), {
                      id: `${n(u)}-label`,
                      class: D(["modal-title", A.value])
                    }, {
                      default: I(() => [
                        $(L.$slots, "title", Be(Ce(ve.value)), () => [
                          se(J(n(t).title), 1)
                        ], !0)
                      ]),
                      _: 3
                    }, 8, ["id", "class"])),
                    n(t).hideHeaderClose ? te("", !0) : (b(), O(pe, { key: 0 }, [
                      V.value ? (b(), N(pt, K({ key: 0 }, ne.value, {
                        onClick: X[0] || (X[0] = (ge) => R("close"))
                      }), {
                        default: I(() => [
                          $(L.$slots, "header-close", {}, void 0, !0)
                        ]),
                        _: 3
                      }, 16)) : (b(), N(Et, K({
                        key: 1,
                        "aria-label": n(t).headerCloseLabel
                      }, ne.value, {
                        onClick: X[1] || (X[1] = (ge) => R("close"))
                      }), null, 16, ["aria-label"]))
                    ], 64))
                  ], !0)
                ], 2)),
                Q("div", K({
                  id: `${n(u)}-body`,
                  class: ["modal-body", P.value]
                }, n(t).bodyAttrs), [
                  $(L.$slots, "default", Be(Ce(ve.value)), () => [
                    se(J(n(t).body), 1)
                  ], !0)
                ], 16, ti),
                n(t).hideFooter ? te("", !0) : (b(), O("div", {
                  key: 1,
                  class: D(["modal-footer", T.value])
                }, [
                  $(L.$slots, "footer", Be(Ce(ve.value)), () => [
                    $(L.$slots, "cancel", Be(Ce(ve.value)), () => [
                      n(t).okOnly ? te("", !0) : (b(), N(pt, {
                        key: 0,
                        ref_key: "cancelButton",
                        ref: f,
                        disabled: E.value,
                        size: n(t).buttonSize,
                        variant: n(t).cancelVariant,
                        onClick: X[2] || (X[2] = (ge) => R("cancel"))
                      }, {
                        default: I(() => [
                          se(J(n(t).cancelTitle), 1)
                        ]),
                        _: 1
                      }, 8, ["disabled", "size", "variant"]))
                    ], !0),
                    $(L.$slots, "ok", Be(Ce(ve.value)), () => [
                      be(pt, {
                        ref_key: "okButton",
                        ref: c,
                        disabled: M.value,
                        size: n(t).buttonSize,
                        variant: n(t).okVariant,
                        onClick: X[3] || (X[3] = (ge) => R("ok"))
                      }, {
                        default: I(() => [
                          se(J(n(t).okTitle), 1)
                        ]),
                        _: 1
                      }, 8, ["disabled", "size", "variant"])
                    ], !0)
                  ], !0)
                ], 2))
              ], 2)) : te("", !0)
            ], 2),
            $(L.$slots, "backdrop", {}, () => [
              be(Ba, {
                variant: x.value,
                show: r.value,
                "no-spinner": "",
                fixed: "",
                "no-wrap": "",
                blur: null,
                onClick: X[4] || (X[4] = (ge) => R("backdrop"))
              }, null, 8, ["variant", "show"])
            ], !0)
          ], 16, ei), [
            [Dt, r.value]
          ])
        ]),
        _: 3
      }, 16, ["appear"])
    ], 8, ["to", "disabled"]));
  }
}), an = (a, o) => {
  const e = a.__vccOpts || a;
  for (const [l, t] of o)
    e[l] = t;
  return e;
}, Ia = /* @__PURE__ */ an(ai, [["__scopeId", "data-v-0f0f4678"]]), li = {
  install(a) {
    const o = F([]), e = () => {
      let r = () => {
      };
      return {
        value: new Promise((c) => {
          r = c;
        }),
        resolve: r
      };
    }, l = () => [e(), Symbol(), F(!0)], t = (r) => {
      const [d, c, f] = l();
      return o.value.push(
        _({
          get: () => ({
            component: Te(r.component) ?? Ia,
            props: {
              ...Te(r.props),
              _isConfirm: !1,
              _promise: d,
              _self: c,
              _modelValue: f.value
            }
          }),
          set: (m) => {
            f.value = m.props._modelValue;
          }
        })
      ), d.value;
    }, s = (r) => {
      const [d, c, f] = l();
      return o.value.push(
        _({
          get: () => ({
            component: Te(r.component) ?? Ia,
            props: {
              ...Te(r.props),
              _isConfirm: !0,
              _promise: d,
              _self: c,
              _modelValue: f.value
            }
          }),
          set: (m) => {
            f.value = m.props._modelValue;
          }
        })
      ), d.value;
    }, i = (r) => {
      const d = o.value.find((c) => c.value.props._self === r);
      d !== void 0 && (d.value = {
        ...d.value,
        props: {
          ...d.value.props,
          _modelValue: !1
        }
      });
    }, u = (r) => {
      o.value = o.value.filter((d) => d.value.props._self !== r);
    };
    a.provide(Io, {
      modals: o,
      remove: u,
      show: t,
      confirm: s,
      leave: i
    });
  }
}, oi = {
  install(a) {
    const o = Vt([]), e = k(() => o.value.length), l = k(() => o.value[o.value.length - 1]), t = (d) => {
      o.value = [...o.value, d];
    }, s = (d) => {
      o.value = o.value.filter((c) => c.uid !== d.uid);
    }, i = Vt([]), u = (d) => {
      i.value = [...i.value, d];
    }, r = (d) => {
      i.value = i.value.filter((c) => c.uid !== d.uid);
    };
    a.provide(Eo, {
      stack: o,
      countStack: e,
      lastStack: l,
      registry: i,
      pushStack: t,
      removeStack: s,
      pushRegistry: u,
      removeRegistry: r
    });
  }
}, ni = {
  install(a, o) {
    var r, d;
    const t = typeof (o == null ? void 0 : o.rtl) == "boolean" ? !1 : ((r = o == null ? void 0 : o.rtl) == null ? void 0 : r.rtlInitial) ?? !1, s = typeof (o == null ? void 0 : o.rtl) == "boolean" ? void 0 : ((d = o == null ? void 0 : o.rtl) == null ? void 0 : d.localeInitial) ?? void 0, i = F(t), u = F(s);
    a.provide(Po, { isRtl: i, locale: u });
  }
}, si = {
  install(a, o) {
    const e = (o == null ? void 0 : o.components) ?? {};
    a.provide(ta, F(e));
  }
}, ri = ["id"], ii = /* @__PURE__ */ z({
  __name: "BAccordion",
  props: /* @__PURE__ */ ye({
    flush: { type: Boolean, default: !1 },
    free: { type: Boolean, default: !1 },
    id: { default: void 0 },
    modelValue: {}
  }, {
    modelValue: {
      default: void 0
    },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(a) {
    const e = j(a, "BAccordion"), l = _e(a, "modelValue"), t = we(() => e.id, "accordion"), s = _(() => ({
      "accordion-flush": e.flush
    }));
    return Xe(xo, {
      openItem: Ye(l),
      free: k(() => e.free),
      setOpenItem: (i) => {
        l.value = i;
      }
    }), (i, u) => (b(), O("div", {
      id: n(t),
      class: D(["accordion", s.value])
    }, [
      $(i.$slots, "default")
    ], 10, ri));
  }
}), ln = /* @__PURE__ */ z({
  inheritAttrs: !1,
  __name: "BCollapse",
  props: /* @__PURE__ */ ye({
    horizontal: { type: Boolean, default: !1 },
    id: { default: void 0 },
    isNav: { type: Boolean, default: !1 },
    modelValue: { type: Boolean },
    skipAnimation: { type: Boolean, default: !1 },
    tag: { default: "div" },
    toggle: { type: Boolean, default: !1 },
    visible: { type: Boolean, default: !1 }
  }, {
    modelValue: { type: Boolean, default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ ye(["hidden", "hide", "hide-prevented", "show", "show-prevented", "shown"], ["update:modelValue"]),
  setup(a, { expose: o, emit: e }) {
    const t = j(a, "BCollapse"), s = e, i = (x, V = {}) => new _t(x, {
      cancelable: !1,
      target: d.value || null,
      relatedTarget: null,
      trigger: null,
      ...V,
      componentId: r.value
    }), u = _e(a, "modelValue"), r = we(() => t.id, "collapse"), d = F(null), c = F(!1), f = F(u.value), m = _(() => ({
      show: f.value,
      "navbar-collapse": t.isNav,
      collapsing: c.value,
      closing: f.value && !u.value,
      "collapse-horizontal": t.horizontal
    })), v = () => {
      u.value = !1;
    }, y = () => {
      u.value = !0;
    }, h = () => {
      u.value = !u.value;
    }, C = _(() => ({
      toggle: h,
      show: y,
      hide: v,
      id: r.value,
      visible: u.value
    }));
    let p, B, g = t.skipAnimation;
    const S = () => {
      const x = i("show", { cancelable: !0 });
      if (s("show", x), x.defaultPrevented) {
        s("show-prevented");
        return;
      }
      clearTimeout(B), clearTimeout(p), f.value = !0, !g && (c.value = !0, Ie(() => {
        d.value !== null && (t.horizontal ? d.value.style.width = `${d.value.scrollWidth}px` : d.value.style.height = `${d.value.scrollHeight}px`, p = setTimeout(() => {
          c.value = !1, s("shown"), d.value !== null && (d.value.style.height = "", d.value.style.width = "");
        }, xa(d.value)));
      }));
    }, w = () => {
      const x = i("hide", { cancelable: !0 });
      if (s("hide", x), x.defaultPrevented) {
        s("hide-prevented");
        return;
      }
      if (clearTimeout(p), clearTimeout(B), d.value !== null) {
        if (g) {
          f.value = !1;
          return;
        }
        c.value ? (d.value.style.height = "", d.value.style.width = "") : t.horizontal ? d.value.style.width = `${d.value.scrollWidth}px` : d.value.style.height = `${d.value.scrollHeight}px`, d.value.offsetHeight, c.value = !0, Ie(() => {
          d.value !== null && (d.value.style.height = "", d.value.style.width = "", B = setTimeout(() => {
            f.value = !1, c.value = !1, s("hidden");
          }, xa(d.value)));
        });
      }
    };
    return fe(u, () => {
      u.value ? S() : w();
    }), Ue(() => {
      d.value !== null && !u.value && t.toggle && Ie(() => {
        u.value = !0;
      });
    }), fe(
      () => t.skipAnimation,
      (x) => {
        g = x;
      }
    ), t.visible && (g = !0, u.value = !0, Ie(() => {
      g = t.skipAnimation;
    })), fe(
      () => t.visible,
      (x) => {
        g = !0, x ? y() : v(), Ie(() => {
          g = t.skipAnimation;
        });
      }
    ), $e(d, "bv-toggle", () => {
      u.value = !u.value;
    }), o({
      hide: v,
      isNav: t.isNav,
      show: y,
      toggle: h,
      visible: Ye(f)
    }), Xe(al, {
      id: r,
      hide: v,
      show: y,
      toggle: h,
      visible: Ye(f),
      isNav: k(() => t.isNav)
    }), (x, V) => (b(), O(pe, null, [
      $(x.$slots, "header", Be(Ce(C.value))),
      (b(), N(ue(n(t).tag), K({
        id: n(r),
        ref_key: "element",
        ref: d,
        class: ["collapse", m.value],
        "is-nav": n(t).isNav
      }, x.$attrs), {
        default: I(() => [
          $(x.$slots, "default", Be(Ce(C.value)))
        ]),
        _: 3
      }, 16, ["id", "class", "is-nav"])),
      $(x.$slots, "footer", Be(Ce(C.value)))
    ], 64));
  }
}), ui = ["aria-expanded", "aria-controls", "onClick"], di = /* @__PURE__ */ z({
  inheritAttrs: !1,
  __name: "BAccordionItem",
  props: /* @__PURE__ */ ye({
    bodyAttrs: { default: void 0 },
    bodyClass: { default: void 0 },
    buttonAttrs: { default: void 0 },
    buttonClass: { default: void 0 },
    collapseClass: { default: void 0 },
    headerAttrs: { default: void 0 },
    headerClass: { default: void 0 },
    headerTag: { default: "h2" },
    horizontal: { type: Boolean, default: void 0 },
    id: { default: void 0 },
    isNav: { type: Boolean, default: void 0 },
    modelValue: { type: Boolean },
    tag: { default: void 0 },
    title: { default: void 0 },
    toggle: { type: Boolean, default: void 0 },
    visible: { type: Boolean, default: !1 },
    wrapperAttrs: { default: void 0 }
  }, {
    modelValue: { type: Boolean, default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ ye(["hidden", "hide", "hide-prevented", "show", "show-prevented", "shown"], ["update:modelValue"]),
  setup(a, { emit: o }) {
    const { class: e, ...l } = Mt(), s = j(a, "BAccordionItem"), i = o, u = _e(a, "modelValue"), r = Ve(xo, null), d = we(() => s.id, "accordion_item");
    return Ue(() => {
      u.value && !(r != null && r.free.value) && (r == null || r.setOpenItem(d.value)), !u.value && (r == null ? void 0 : r.openItem.value) === d.value && (u.value = !0);
    }), fe(
      () => r == null ? void 0 : r.openItem.value,
      () => u.value = (r == null ? void 0 : r.openItem.value) === d.value && !(r != null && r.free.value)
    ), fe(u, () => {
      u.value && !(r != null && r.free.value) && (r == null || r.setOpenItem(d.value));
    }), (c, f) => (b(), O("div", K({ class: "accordion-item" }, n(s).wrapperAttrs, { class: n(e) }), [
      be(ln, K({
        id: n(d),
        modelValue: u.value,
        "onUpdate:modelValue": f[0] || (f[0] = (m) => u.value = m),
        class: ["accordion-collapse", n(s).collapseClass],
        "aria-labelledby": `${n(d)}-heading`
      }, l, {
        tag: n(s).tag,
        toggle: n(s).toggle,
        horizontal: n(s).horizontal,
        visible: n(s).visible,
        "is-nav": n(s).isNav,
        onShow: f[1] || (f[1] = (m) => i("show", m)),
        onShown: f[2] || (f[2] = (m) => i("shown")),
        onHide: f[3] || (f[3] = (m) => i("hide", m)),
        onHidden: f[4] || (f[4] = (m) => i("hidden")),
        onHidePrevented: f[5] || (f[5] = (m) => i("hide-prevented")),
        onShowPrevented: f[6] || (f[6] = (m) => i("show-prevented"))
      }), {
        header: I(({ visible: m, toggle: v }) => [
          (b(), N(ue(n(s).headerTag), K({
            id: `${n(d)}-heading`,
            class: ["accordion-header", n(s).headerClass]
          }, n(s).headerAttrs), {
            default: I(() => [
              Q("button", K({ class: "accordion-button" }, n(s).buttonAttrs, {
                class: [{ collapsed: !m }, n(s).buttonClass],
                type: "button",
                "aria-expanded": m ? "true" : "false",
                "aria-controls": n(d),
                onClick: v
              }), [
                $(c.$slots, "title", {}, () => [
                  se(J(n(s).title), 1)
                ])
              ], 16, ui)
            ]),
            _: 2
          }, 1040, ["id", "class"]))
        ]),
        default: I(() => [
          Q("div", K({ class: "accordion-body" }, n(s).bodyAttrs, {
            class: n(s).bodyClass
          }), [
            $(c.$slots, "default")
          ], 16)
        ]),
        _: 3
      }, 16, ["id", "modelValue", "class", "aria-labelledby", "tag", "toggle", "horizontal", "visible", "is-nav"])
    ], 16));
  }
}), ci = /* @__PURE__ */ z({
  __name: "BAlert",
  props: /* @__PURE__ */ ye({
    closeClass: { default: void 0 },
    closeContent: { default: void 0 },
    closeLabel: { default: "Close" },
    closeVariant: { default: "secondary" },
    dismissible: { type: Boolean, default: !1 },
    fade: { type: Boolean, default: !1 },
    immediate: { type: Boolean, default: !0 },
    interval: { default: 1e3 },
    modelValue: { type: [Boolean, Number] },
    noHoverPause: { type: Boolean, default: !1 },
    showOnPause: { type: Boolean, default: !0 },
    variant: { default: "info" }
  }, {
    modelValue: { type: [Boolean, Number], default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ ye(["close", "close-countdown", "closed"], ["update:modelValue"]),
  setup(a, { expose: o, emit: e }) {
    const t = j(a, "BAlert"), s = e, i = Re(), u = F(null), r = _e(a, "modelValue"), d = el(u), c = he(() => t.interval), f = k(() => !Ae(i.close)), m = k(() => typeof r.value == "boolean" ? 0 : r.value), v = _(() => ({
      [`alert-${t.variant}`]: t.variant !== null,
      "alert-dismissible": t.dismissible
    })), y = _(() => [t.closeClass, { "btn-close-custom": f.value }]), {
      isActive: h,
      pause: C,
      restart: p,
      resume: B,
      stop: g,
      isPaused: S,
      value: w
    } = Ro(m, c, {
      immediate: typeof r.value == "number" && t.immediate
    }), x = k(
      () => typeof r.value == "boolean" ? r.value : h.value || t.showOnPause && S.value
    ), V = _(() => ({
      variant: f.value ? t.closeVariant : void 0,
      class: y.value
    }));
    Nt(() => {
      s("close-countdown", w.value);
    });
    const G = () => {
      s("close"), typeof r.value == "boolean" ? r.value = !1 : (r.value = 0, g()), s("closed");
    }, W = () => {
      t.noHoverPause || C();
    };
    return fe(d, (P) => {
      if (P) {
        W();
        return;
      }
      B();
    }), Da(g), o({
      pause: C,
      restart: p,
      resume: B,
      stop: g
    }), (P, Y) => (b(), N(qt, {
      "no-fade": !n(t).fade,
      "trans-props": { enterToClass: "show" }
    }, {
      default: I(() => [
        x.value ? (b(), O("div", {
          key: 0,
          ref_key: "element",
          ref: u,
          class: D(["alert", v.value]),
          role: "alert",
          "aria-live": "polite",
          "aria-atomic": "true"
        }, [
          $(P.$slots, "default", {}, void 0, !0),
          n(t).dismissible ? (b(), O(pe, { key: 0 }, [
            f.value || n(t).closeContent ? (b(), N(pt, K({ key: 0 }, V.value, { onClick: G }), {
              default: I(() => [
                $(P.$slots, "close", {}, () => [
                  se(J(n(t).closeContent), 1)
                ], !0)
              ]),
              _: 3
            }, 16)) : (b(), N(Et, K({
              key: 1,
              "aria-label": n(t).closeLabel
            }, V.value, { onClick: G }), null, 16, ["aria-label"]))
          ], 64)) : te("", !0)
        ], 2)) : te("", !0)
      ]),
      _: 3
    }, 8, ["no-fade"]));
  }
}), fi = /* @__PURE__ */ an(ci, [["__scopeId", "data-v-96a91b13"]]), on = /* @__PURE__ */ z({
  __name: "BBadge",
  props: {
    dotIndicator: { type: Boolean, default: !1 },
    pill: { type: Boolean, default: !1 },
    tag: { default: "span" },
    textIndicator: { type: Boolean },
    placement: { default: void 0 },
    active: { type: Boolean, default: void 0 },
    activeClass: { default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    stretched: { type: Boolean, default: !1 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: "secondary" },
    prefetch: { type: Boolean },
    noPrefetch: { type: Boolean },
    prefetchedClass: {},
    noRel: { type: Boolean },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(a) {
    const e = j(a, "BBadge"), l = ot(e), { computedLink: t, computedLinkProps: s } = wt(e, [
      "active",
      "activeClass",
      "append",
      "disabled",
      "href",
      "rel",
      "replace",
      "routerComponentName",
      "target",
      "to",
      "opacity",
      "opacityHover",
      "underlineVariant",
      "underlineOffset",
      "underlineOffsetHover",
      "underlineOpacity",
      "underlineOpacityHover",
      "icon"
    ]), i = k(() => t.value ? st : e.tag), u = _(() => {
      const d = e.placement ?? (e.dotIndicator ? "top-end" : void 0);
      return [
        "position-absolute",
        "translate-middle",
        {
          "start-0 top-0": d === "top-start",
          "start-0 top-50": d === "start",
          "start-0 top-100": d === "bottom-start",
          "start-50 top-0": d === "top",
          "start-50 top-100": d === "bottom",
          "start-100 top-0": d === "top-end",
          "start-100 top-50": d === "end",
          "start-100 top-100": d === "bottom-end"
        }
      ];
    }), r = _(() => [
      l.value,
      e.placement !== void 0 || e.dotIndicator === !0 ? u.value : void 0,
      {
        active: e.active,
        disabled: e.disabled,
        "rounded-pill": e.pill,
        "p-2 border border-light rounded-circle": e.dotIndicator,
        "text-decoration-none": t.value
      }
    ]);
    return (d, c) => (b(), N(ue(i.value), K({
      class: ["badge", r.value]
    }, n(s)), {
      default: I(() => [
        be(Gt, K({
          skip: n(e).dotIndicator !== !0,
          tag: "span"
        }, n(e).dotIndicator ? { class: "visually-hidden" } : {}), {
          default: I(() => [
            $(d.$slots, "default")
          ]),
          _: 3
        }, 16, ["skip"])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), vi = {
  key: 0,
  class: "b-avatar-custom"
}, pi = {
  key: 1,
  class: "b-avatar-img"
}, mi = ["src", "alt"], Al = 0.4, bi = /* @__PURE__ */ z({
  __name: "BAvatar",
  props: {
    alt: { default: "avatar" },
    badge: { type: [Boolean, String], default: !1 },
    badgeBgVariant: { default: null },
    badgePlacement: { default: "top-end" },
    badgeTextVariant: { default: null },
    badgeVariant: { default: "primary" },
    badgePill: { type: Boolean, default: !1 },
    badgeDotIndicator: { type: Boolean, default: !1 },
    button: { type: Boolean, default: !1 },
    buttonType: { default: "button" },
    size: { default: void 0 },
    square: { type: Boolean, default: !1 },
    src: { default: void 0 },
    text: { default: void 0 },
    active: { type: Boolean, default: void 0 },
    activeClass: { default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    stretched: { type: Boolean, default: !1 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: "secondary" },
    prefetch: { type: Boolean },
    noPrefetch: { type: Boolean },
    prefetchedClass: {},
    noRel: { type: Boolean },
    bgVariant: { default: null },
    textVariant: { default: null },
    rounded: { type: [Boolean, String, Number], default: !1 },
    roundedTop: { type: [Boolean, String, Number], default: void 0 },
    roundedBottom: { type: [Boolean, String, Number], default: void 0 },
    roundedStart: { type: [Boolean, String, Number], default: void 0 },
    roundedEnd: { type: [Boolean, String, Number], default: void 0 }
  },
  emits: ["click", "img-error"],
  setup(a, { emit: o }) {
    const e = a, l = o, t = Re(), { computedLink: s, computedLinkProps: i } = wt(e), u = Ve($o, null), r = ["sm", null, "lg"], d = Al * 0.7, c = k(() => !Ae(t.default)), f = k(() => !Ae(t.badge)), m = k(() => !!e.badge || e.badge === "" || f.value), v = k(() => (u == null ? void 0 : u.square.value) || e.square), y = pa(() => e.size), h = pa(() => u == null ? void 0 : u.size.value), C = _(() => h.value ?? y.value), p = k(() => (u == null ? void 0 : u.variant.value) ?? e.variant), B = k(() => (u == null ? void 0 : u.rounded.value) ?? e.rounded), g = k(() => (u == null ? void 0 : u.roundedTop.value) ?? e.roundedTop), S = k(() => (u == null ? void 0 : u.roundedBottom.value) ?? e.roundedBottom), w = k(() => (u == null ? void 0 : u.roundedStart.value) ?? e.roundedStart), x = k(() => (u == null ? void 0 : u.roundedEnd.value) ?? e.roundedEnd), V = sl(() => ({
      rounded: B.value,
      roundedTop: g.value,
      roundedBottom: S.value,
      roundedStart: w.value,
      roundedEnd: x.value
    })), G = k(() => e.badge === !0 ? "" : e.badge), W = _(() => !G.value && !f.value), P = k(() => (u == null ? void 0 : u.textVariant.value) ?? e.textVariant), Y = k(() => (u == null ? void 0 : u.bgVariant.value) ?? e.bgVariant), ae = ot(() => ({
      bgVariant: Y.value,
      textVariant: P.value,
      variant: p.value
    })), ne = _(() => [
      ae.value,
      // Square overwrites all else
      v.value === !0 ? void 0 : V.value,
      {
        [`b-avatar-${e.size}`]: !!e.size && r.indexOf(y.value) !== -1,
        [`btn-${p.value}`]: e.button ? p.value !== null : !1,
        badge: !e.button && p.value !== null && c.value,
        btn: e.button,
        // Square is the same as rounded-0 class
        "rounded-0": v.value === !0
      }
    ]), U = _(() => ({
      fontSize: r.indexOf(C.value || null) === -1 ? `calc(${C.value} * ${d})` : ""
    })), T = _(() => {
      const H = r.indexOf(C.value || null) === -1 ? `calc(${C.value} * ${Al})` : null;
      return H ? { fontSize: H } : {};
    }), A = _(() => {
      var le;
      const H = ((le = u == null ? void 0 : u.overlapScale) == null ? void 0 : le.value) || 0, ce = C.value && H ? `calc(${C.value} * -${H})` : null;
      return ce ? { marginLeft: ce, marginRight: ce } : {};
    }), E = k(() => s.value ? st : e.button ? "button" : "span"), M = _(() => ({
      ...A.value,
      width: C.value ?? void 0,
      height: C.value ?? void 0
    })), Z = (H) => {
      !e.disabled && (s.value || e.button) && l("click", H);
    }, R = (H) => {
      l("img-error", H);
    };
    return (H, ce) => (b(), N(ue(E.value), K({
      class: ["b-avatar", ne.value],
      style: M.value
    }, n(i), {
      type: e.button && !n(s) ? e.buttonType : void 0,
      disabled: e.disabled || null,
      onClick: Z
    }), {
      default: I(() => [
        c.value ? (b(), O("span", vi, [
          $(H.$slots, "default")
        ])) : e.src ? (b(), O("span", pi, [
          Q("img", {
            src: e.src,
            alt: e.alt,
            onError: R
          }, null, 40, mi)
        ])) : e.text ? (b(), O("span", {
          key: 2,
          class: "b-avatar-text",
          style: Le(T.value)
        }, J(e.text), 5)) : te("", !0),
        m.value ? (b(), N(on, {
          key: 3,
          pill: e.badgePill,
          "dot-indicator": e.badgeDotIndicator || W.value,
          variant: e.badgeVariant,
          "bg-variant": e.badgeBgVariant,
          "text-variant": e.badgeTextVariant,
          style: Le(U.value),
          placement: e.badgePlacement
        }, {
          default: I(() => [
            $(H.$slots, "badge", {}, () => [
              se(J(G.value), 1)
            ])
          ]),
          _: 3
        }, 8, ["pill", "dot-indicator", "variant", "bg-variant", "text-variant", "style", "placement"])) : te("", !0)
      ]),
      _: 3
    }, 16, ["class", "style", "type", "disabled"]));
  }
}), yi = /* @__PURE__ */ z({
  __name: "BAvatarGroup",
  props: {
    overlap: { default: 0.3 },
    size: { default: void 0 },
    square: { type: Boolean, default: !1 },
    tag: { default: "div" },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null },
    rounded: { type: [Boolean, String, Number], default: !1 },
    roundedTop: { type: [Boolean, String, Number], default: void 0 },
    roundedBottom: { type: [Boolean, String, Number], default: void 0 },
    roundedStart: { type: [Boolean, String, Number], default: void 0 },
    roundedEnd: { type: [Boolean, String, Number], default: void 0 }
  },
  setup(a) {
    const e = j(a, "BAvatarGroup"), l = he(() => e.overlap), t = pa(() => e.size), s = k(() => Math.min(Math.max(l.value, 0), 1) / 2), i = _(() => {
      const u = t.value ? `calc(${t.value} * ${s.value})` : null;
      return u ? { paddingLeft: u, paddingRight: u } : {};
    });
    return Xe($o, {
      overlapScale: s,
      size: k(() => e.size),
      square: k(() => e.square),
      rounded: k(() => e.rounded),
      roundedTop: k(() => e.roundedTop),
      roundedBottom: k(() => e.roundedBottom),
      roundedStart: k(() => e.roundedStart),
      roundedEnd: k(() => e.roundedEnd),
      variant: k(() => e.variant),
      bgVariant: k(() => e.bgVariant),
      textVariant: k(() => e.textVariant)
    }), (u, r) => (b(), N(ue(n(e).tag), {
      class: "b-avatar-group",
      role: "group"
    }, {
      default: I(() => [
        Q("div", {
          class: "b-avatar-group-inner",
          style: Le(i.value)
        }, [
          $(u.$slots, "default")
        ], 4)
      ]),
      _: 3
    }));
  }
}), nn = /* @__PURE__ */ z({
  __name: "BBreadcrumbItem",
  props: {
    ariaCurrent: { default: "location" },
    text: { default: void 0 },
    active: { type: Boolean, default: !1 },
    activeClass: { default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    stretched: { type: Boolean, default: !1 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: void 0 },
    prefetch: { type: Boolean },
    noPrefetch: { type: Boolean },
    prefetchedClass: {},
    noRel: { type: Boolean }
  },
  emits: ["click"],
  setup(a, { emit: o }) {
    const l = j(a, "BBreadcrumbItem"), t = o, s = _(() => ({
      active: l.active
    })), i = k(() => l.active ? "span" : st), u = k(() => l.active ? l.ariaCurrent : void 0), r = _(
      () => i.value !== "span" ? ol(l, [
        "active",
        "activeClass",
        "append",
        "disabled",
        "href",
        "rel",
        "replace",
        "routerComponentName",
        "target",
        "to",
        "variant",
        "opacity",
        "opacityHover",
        "underlineVariant",
        "underlineOffset",
        "underlineOffsetHover",
        "underlineOpacity",
        "underlineOpacityHover",
        "icon"
      ]) : {}
    ), d = (c) => {
      if (l.disabled || l.active) {
        c.preventDefault(), c.stopImmediatePropagation();
        return;
      }
      l.disabled || t("click", c);
    };
    return (c, f) => (b(), O("li", {
      class: D(["breadcrumb-item", s.value])
    }, [
      (b(), N(ue(i.value), K({ "aria-current": u.value }, r.value, { onClick: d }), {
        default: I(() => [
          $(c.$slots, "default", {}, () => [
            se(J(n(l).text), 1)
          ])
        ]),
        _: 3
      }, 16, ["aria-current"]))
    ], 2));
  }
}), gi = { "aria-label": "breadcrumb" }, hi = { class: "breadcrumb" }, Bi = /* @__PURE__ */ z({
  __name: "BBreadcrumb",
  props: {
    items: { default: void 0 }
  },
  setup(a) {
    const e = j(a, "BBreadcrumb"), l = zo(), t = _(() => {
      var r;
      const s = e.items || ((r = l.items) == null ? void 0 : r.value) || [];
      let i = !1;
      return s.map((d, c) => (typeof d == "string" && (d = { text: d }, c < s.length - 1 && (d.href = "#")), d.active && (i = !0), !d.active && !i && (d.active = c + 1 === s.length), d));
    });
    return (s, i) => (b(), O("nav", gi, [
      Q("ol", hi, [
        $(s.$slots, "prepend"),
        (b(!0), O(pe, null, ke(t.value, (u, r) => (b(), N(nn, K({
          key: r,
          ref_for: !0
        }, u), {
          default: I(() => [
            se(J(u.text), 1)
          ]),
          _: 2
        }, 1040))), 128)),
        $(s.$slots, "default"),
        $(s.$slots, "append")
      ])
    ]));
  }
}), _i = /* @__PURE__ */ z({
  __name: "BButtonGroup",
  props: {
    ariaLabel: { default: "Group" },
    size: { default: "md" },
    tag: { default: "div" },
    vertical: { type: Boolean, default: !1 }
  },
  setup(a) {
    const e = j(a, "BButtonGroup"), l = _(() => ({
      "btn-group": !e.vertical,
      [`btn-group-${e.size}`]: e.size !== "md",
      "btn-group-vertical": e.vertical
    }));
    return (t, s) => (b(), N(ue(n(e).tag), {
      class: D(l.value),
      role: "group",
      "aria-label": n(e).ariaLabel
    }, {
      default: I(() => [
        $(t.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "aria-label"]));
  }
}), wi = ["role", "aria-label"], Ci = /* @__PURE__ */ z({
  __name: "BButtonToolbar",
  props: {
    ariaLabel: { default: "Group" },
    justify: { type: Boolean, default: !1 },
    role: { default: "toolbar" }
  },
  setup(a) {
    const e = j(a, "BButtonToolbar"), l = _(() => ({
      "justify-content-between": e.justify
    }));
    return (t, s) => (b(), O("div", {
      class: D([l.value, "btn-toolbar"]),
      role: n(e).role,
      "aria-label": n(e).ariaLabel
    }, [
      $(t.$slots, "default")
    ], 10, wi));
  }
}), rl = /* @__PURE__ */ z({
  __name: "BImg",
  props: {
    blank: { type: Boolean, default: !1 },
    blankColor: { default: "transparent" },
    block: { type: Boolean, default: !1 },
    fluid: { type: Boolean, default: !1 },
    fluidGrow: { type: Boolean, default: !1 },
    height: { default: void 0 },
    tag: { default: "img" },
    lazy: { type: Boolean, default: !1 },
    sizes: { default: void 0 },
    src: { default: void 0 },
    srcset: { default: void 0 },
    thumbnail: { type: Boolean, default: !1 },
    width: { default: void 0 },
    placement: { default: void 0 },
    rounded: { type: [Boolean, String, Number], default: !1 },
    roundedTop: { type: [Boolean, String, Number], default: void 0 },
    roundedBottom: { type: [Boolean, String, Number], default: void 0 },
    roundedStart: { type: [Boolean, String, Number], default: void 0 },
    roundedEnd: { type: [Boolean, String, Number], default: void 0 }
  },
  setup(a) {
    const e = j(a, "BImg"), l = he(() => e.height ?? NaN), t = he(() => e.width ?? NaN), s = sl(() => ({
      rounded: e.rounded,
      roundedTop: e.roundedTop,
      roundedBottom: e.roundedBottom,
      roundedStart: e.roundedStart,
      roundedEnd: e.roundedEnd
    })), i = _(
      () => typeof e.srcset == "string" ? e.srcset.split(",").filter((v) => v).join(",") : Array.isArray(e.srcset) ? e.srcset.filter((v) => v).join(",") : void 0
    ), u = _(
      () => typeof e.sizes == "string" ? e.sizes.split(",").filter((v) => v).join(",") : Array.isArray(e.sizes) ? e.sizes.filter((v) => v).join(",") : void 0
    ), r = _(() => {
      const v = Number.isNaN(t.value) ? void 0 : t.value, y = Number.isNaN(l.value) ? void 0 : l.value;
      if (e.blank) {
        if (v !== void 0 && y === void 0)
          return { height: v, width: v };
        if (v === void 0 && y !== void 0)
          return { height: y, width: y };
        if (v === void 0 && y === void 0)
          return { height: 1, width: 1 };
      }
      return {
        width: v,
        height: y
      };
    }), d = k(
      () => m(r.value.width, r.value.height, e.blankColor)
    ), c = _(() => ({
      "float-start": e.placement === "start",
      "float-end": e.placement === "end",
      "mx-auto": e.placement === "center"
    })), f = _(() => [
      s.value,
      c.value,
      {
        "img-thumbnail": e.thumbnail,
        "img-fluid": e.fluid || e.fluidGrow,
        "w-100": e.fluidGrow,
        "d-block": e.block || e.placement === "center"
      }
    ]), m = (v, y, h) => `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(`<svg width="${v}" height="${y}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${v} ${y}" preserveAspectRatio="none">
    <rect width="100%" height="100%" style="fill:${h};"></rect>
    </svg>`)}`;
    return (v, y) => (b(), N(ue(n(e).tag), {
      class: D(f.value),
      src: n(e).blank ? d.value : n(e).src,
      width: r.value.width || void 0,
      height: r.value.height || void 0,
      srcset: n(e).blank ? void 0 : i.value,
      sizes: n(e).blank ? void 0 : u.value,
      loading: n(e).lazy ? "lazy" : "eager"
    }, null, 8, ["class", "src", "width", "height", "srcset", "sizes", "loading"]));
  }
}), il = /* @__PURE__ */ z({
  __name: "BCardImg",
  props: {
    placement: { default: "top" },
    blank: { type: Boolean, default: void 0 },
    blankColor: { default: void 0 },
    block: { type: Boolean, default: void 0 },
    fluid: { type: Boolean, default: void 0 },
    fluidGrow: { type: Boolean, default: void 0 },
    height: { default: void 0 },
    tag: {},
    lazy: { type: Boolean, default: void 0 },
    sizes: { default: void 0 },
    src: { default: void 0 },
    srcset: { default: void 0 },
    thumbnail: { type: Boolean, default: void 0 },
    width: { default: void 0 },
    rounded: { type: [Boolean, String, Number], default: void 0 },
    roundedTop: { type: [Boolean, String, Number], default: void 0 },
    roundedBottom: { type: [Boolean, String, Number], default: void 0 },
    roundedStart: { type: [Boolean, String, Number], default: void 0 },
    roundedEnd: { type: [Boolean, String, Number], default: void 0 }
  },
  setup(a) {
    const e = j(a, "BCardImg"), l = _(() => ({
      "card-img-top": e.placement === "top",
      // TODO implement this class
      "card-img-end": e.placement === "end",
      "card-img-bottom": e.placement === "bottom",
      // TODO implement this class
      "card-img-start": e.placement === "start",
      "card-img": e.placement === "overlay"
    })), t = _(() => ga(e, ["placement"]));
    return (s, i) => (b(), N(rl, K(t.value, { class: l.value }), null, 16, ["class"]));
  }
}), ki = ["innerHTML"], sn = /* @__PURE__ */ z({
  __name: "BCardHeadFoot",
  props: {
    borderVariant: { default: null },
    html: { default: void 0 },
    tag: { default: "div" },
    text: { default: void 0 },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(a) {
    const o = a, e = ot(o), l = _(() => [
      e.value,
      {
        [`border-${o.borderVariant}`]: o.borderVariant !== null
      }
    ]);
    return (t, s) => (b(), N(ue(t.tag), {
      class: D(l.value)
    }, {
      default: I(() => [
        t.html ? (b(), O("div", {
          key: 0,
          innerHTML: t.html
        }, null, 8, ki)) : $(t.$slots, "default", { key: 1 }, () => [
          se(J(t.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), rn = /* @__PURE__ */ z({
  __name: "BCardHeader",
  props: {
    borderVariant: { default: void 0 },
    html: { default: void 0 },
    tag: { default: "div" },
    text: { default: void 0 },
    variant: { default: void 0 },
    bgVariant: { default: void 0 },
    textVariant: { default: void 0 }
  },
  setup(a) {
    const e = j(a, "BCardHeader");
    return (l, t) => (b(), N(sn, K({ class: "card-header" }, n(e)), {
      default: I(() => [
        $(l.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), un = /* @__PURE__ */ z({
  __name: "BCardTitle",
  props: {
    tag: { default: "h4" },
    text: { default: void 0 }
  },
  setup(a) {
    const e = j(a, "BCardTitle");
    return (l, t) => (b(), N(ue(n(e).tag), { class: "card-title" }, {
      default: I(() => [
        $(l.$slots, "default", {}, () => [
          se(J(n(e).text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), dn = /* @__PURE__ */ z({
  __name: "BCardSubtitle",
  props: {
    text: { default: void 0 },
    tag: { default: "h6" },
    textVariant: { default: "body-secondary" }
  },
  setup(a) {
    const e = j(a, "BCardSubtitle"), l = _(() => ({
      [`text-${e.textVariant}`]: e.textVariant !== null
    }));
    return (t, s) => (b(), N(ue(n(e).tag), {
      class: D(["card-subtitle mb-2", l.value])
    }, {
      default: I(() => [
        $(t.$slots, "default", {}, () => [
          se(J(n(e).text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), cn = /* @__PURE__ */ z({
  __name: "BCardBody",
  props: {
    overlay: { type: Boolean, default: !1 },
    subtitle: { default: void 0 },
    subtitleTag: { default: "h4" },
    subtitleTextVariant: { default: void 0 },
    tag: { default: "div" },
    text: { default: void 0 },
    title: { default: void 0 },
    titleTag: { default: "h4" },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(a) {
    const e = j(a, "BCardBody"), l = Re(), t = ot(e), s = k(() => !Ae(l.title)), i = k(() => !Ae(l.subtitle)), u = _(() => [
      t.value,
      e.overlay ? "card-img-overlay" : "card-body"
    ]);
    return (r, d) => (b(), N(ue(n(e).tag), {
      class: D(u.value)
    }, {
      default: I(() => [
        n(e).title || s.value ? (b(), N(un, {
          key: 0,
          tag: n(e).titleTag
        }, {
          default: I(() => [
            $(r.$slots, "title", {}, () => [
              se(J(n(e).title), 1)
            ])
          ]),
          _: 3
        }, 8, ["tag"])) : te("", !0),
        n(e).subtitle || i.value ? (b(), N(dn, {
          key: 1,
          tag: n(e).subtitleTag,
          "text-variant": n(e).subtitleTextVariant
        }, {
          default: I(() => [
            $(r.$slots, "subtitle", {}, () => [
              se(J(n(e).subtitle), 1)
            ])
          ]),
          _: 3
        }, 8, ["tag", "text-variant"])) : te("", !0),
        $(r.$slots, "default", {}, () => [
          se(J(n(e).text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), fn = /* @__PURE__ */ z({
  __name: "BCardFooter",
  props: {
    borderVariant: { default: void 0 },
    html: { default: void 0 },
    tag: { default: "div" },
    text: { default: void 0 },
    variant: { default: void 0 },
    bgVariant: { default: void 0 },
    textVariant: { default: void 0 }
  },
  setup(a) {
    const e = j(a, "BCardFooter");
    return (l, t) => (b(), N(sn, K({ class: "card-footer" }, n(e)), {
      default: I(() => [
        $(l.$slots, "default", {}, () => [
          se(J(n(e).text), 1)
        ])
      ]),
      _: 3
    }, 16));
  }
}), vn = /* @__PURE__ */ z({
  __name: "BCard",
  props: {
    align: { default: void 0 },
    bodyBgVariant: { default: void 0 },
    bodyClass: { default: void 0 },
    bodyTag: { default: "div" },
    bodyText: { default: "" },
    bodyTextVariant: { default: void 0 },
    borderVariant: { default: null },
    footer: { default: void 0 },
    footerBgVariant: { default: void 0 },
    footerBorderVariant: { default: void 0 },
    footerClass: { default: void 0 },
    footerHtml: { default: "" },
    footerTag: { default: "div" },
    footerTextVariant: { default: void 0 },
    footerVariant: { default: null },
    header: { default: void 0 },
    headerBgVariant: { default: void 0 },
    headerBorderVariant: { default: void 0 },
    headerClass: { default: void 0 },
    headerHtml: { default: "" },
    headerTag: { default: "div" },
    headerTextVariant: { default: void 0 },
    headerVariant: { default: null },
    imgAlt: { default: void 0 },
    imgPlacement: { default: "top" },
    imgHeight: { default: void 0 },
    imgSrc: { default: void 0 },
    imgWidth: { default: void 0 },
    noBody: { type: Boolean, default: !1 },
    subtitle: { default: void 0 },
    subtitleTag: { default: "h6" },
    subtitleTextVariant: { default: "body-secondary" },
    tag: { default: "div" },
    title: { default: void 0 },
    titleTag: { default: "h4" },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(a) {
    const e = j(a, "BCard"), l = Re(), t = k(() => !Ae(l.header)), s = k(() => !Ae(l.footer)), i = ot(e), u = _(() => [
      i.value,
      {
        [`text-${e.align}`]: e.align !== void 0,
        [`border-${e.borderVariant}`]: e.borderVariant !== null,
        "flex-row": e.imgPlacement === "start",
        "flex-row-reverse": e.imgPlacement === "end"
      }
    ]), r = _(() => ({
      src: e.imgSrc,
      alt: e.imgAlt,
      height: e.imgHeight,
      width: e.imgWidth,
      placement: e.imgPlacement
    })), d = ia();
    return (c, f) => (b(), N(ue(n(e).tag), {
      class: D(["card", u.value])
    }, {
      default: I(() => [
        be(n(d).define, null, {
          default: I(() => [
            $(c.$slots, "img", {}, () => [
              n(e).imgSrc ? (b(), N(il, Be(K({ key: 0 }, r.value)), null, 16)) : te("", !0)
            ])
          ]),
          _: 3
        }),
        n(e).imgPlacement !== "bottom" ? (b(), N(n(d).reuse, { key: 0 })) : te("", !0),
        n(e).header || t.value || n(e).headerHtml ? (b(), N(rn, {
          key: 1,
          "bg-variant": n(e).headerBgVariant,
          variant: n(e).headerVariant,
          "border-variant": n(e).headerBorderVariant,
          html: n(e).headerHtml,
          tag: n(e).headerTag,
          "text-variant": n(e).headerTextVariant,
          class: D(n(e).headerClass)
        }, {
          default: I(() => [
            $(c.$slots, "header", {}, () => [
              se(J(n(e).header), 1)
            ])
          ]),
          _: 3
        }, 8, ["bg-variant", "variant", "border-variant", "html", "tag", "text-variant", "class"])) : te("", !0),
        n(e).noBody ? $(c.$slots, "default", { key: 3 }, () => [
          se(J(n(e).bodyText), 1)
        ]) : (b(), N(cn, {
          key: 2,
          overlay: n(e).imgPlacement === "overlay",
          "bg-variant": n(e).bodyBgVariant,
          tag: n(e).bodyTag,
          "text-variant": n(e).bodyTextVariant,
          subtitle: n(e).subtitle,
          "subtitle-tag": n(e).subtitleTag,
          "subtitle-text-variant": n(e).subtitleTextVariant,
          title: n(e).title,
          "title-tag": n(e).titleTag,
          class: D(n(e).bodyClass)
        }, {
          default: I(() => [
            $(c.$slots, "default", {}, () => [
              se(J(n(e).bodyText), 1)
            ])
          ]),
          _: 3
        }, 8, ["overlay", "bg-variant", "tag", "text-variant", "subtitle", "subtitle-tag", "subtitle-text-variant", "title", "title-tag", "class"])),
        n(e).footer || s.value || n(e).footerHtml ? (b(), N(fn, {
          key: 4,
          "bg-variant": n(e).footerBgVariant,
          "border-variant": n(e).footerBorderVariant,
          variant: n(e).footerVariant,
          html: n(e).footerHtml,
          tag: n(e).footerTag,
          "text-variant": n(e).footerTextVariant,
          class: D(n(e).footerClass)
        }, {
          default: I(() => [
            $(c.$slots, "footer", {}, () => [
              se(J(n(e).footer), 1)
            ])
          ]),
          _: 3
        }, 8, ["bg-variant", "border-variant", "variant", "html", "tag", "text-variant", "class"])) : te("", !0),
        n(e).imgPlacement === "bottom" ? (b(), N(n(d).reuse, { key: 5 })) : te("", !0)
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Ti = /* @__PURE__ */ z({
  __name: "BCardGroup",
  props: {
    columns: { type: Boolean, default: !1 },
    deck: { type: Boolean, default: !1 },
    tag: { default: "div" }
  },
  setup(a) {
    const e = j(a, "BCardGroup"), l = k(
      () => e.deck ? "card-deck" : e.columns ? "card-columns" : "card-group"
    );
    return (t, s) => (b(), N(ue(n(e).tag), {
      class: D(l.value)
    }, {
      default: I(() => [
        $(t.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), $i = /* @__PURE__ */ z({
  __name: "BCardText",
  props: {
    tag: { default: "p" },
    text: { default: void 0 }
  },
  setup(a) {
    const e = j(a, "BCardText");
    return (l, t) => (b(), N(ue(n(e).tag), { class: "card-text" }, {
      default: I(() => [
        $(l.$slots, "default", {}, () => [
          se(J(n(e).text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), xi = ["id"], Si = {
  key: 0,
  class: "carousel-indicators"
}, Vi = ["aria-current", "aria-label", "onClick"], Ai = /* @__PURE__ */ Q("span", {
  class: "carousel-control-prev-icon",
  "aria-hidden": "true"
}, null, -1), Oi = { class: "visually-hidden" }, Pi = /* @__PURE__ */ Q("span", {
  class: "carousel-control-next-icon",
  "aria-hidden": "true"
}, null, -1), Ni = { class: "visually-hidden" }, Ii = /* @__PURE__ */ z({
  __name: "BCarousel",
  props: /* @__PURE__ */ ye({
    background: { default: void 0 },
    controls: { type: Boolean, default: !1 },
    controlsNextText: { default: "Next" },
    controlsPrevText: { default: "Previous" },
    fade: { type: Boolean, default: !1 },
    id: { default: void 0 },
    imgHeight: { default: void 0 },
    imgWidth: { default: void 0 },
    indicators: { type: Boolean, default: !1 },
    indicatorsButtonLabel: { default: "Slide" },
    interval: { default: 5e3 },
    keyboard: { type: Boolean, default: !0 },
    modelValue: {},
    noHoverPause: { type: Boolean, default: !1 },
    noTouch: { type: Boolean, default: !1 },
    noWrap: { type: Boolean, default: !1 },
    ride: { type: [Boolean, String], default: !1 },
    rideReverse: { type: Boolean, default: !1 },
    touchThreshold: { default: 50 }
  }, {
    modelValue: { default: 0 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ ye(["slide", "slid"], ["update:modelValue"]),
  setup(a, { expose: o, emit: e }) {
    const t = j(a, "BCarousel"), s = e, i = Re(), u = we(() => t.id, "carousel"), r = _e(a, "modelValue"), d = F(null), c = he(() => t.touchThreshold), f = F(null);
    Ue(() => {
      var le, q;
      f.value = ((q = (le = d.value) == null ? void 0 : le.find((oe) => oe.$el.style.display !== "none")) == null ? void 0 : q.$props.interval) ?? null;
    });
    const m = he(() => f.value ?? t.interval), v = F(!1), y = F(!1), h = F(!0), C = F(null), p = F(null), B = F(r.value), g = el(p), S = k(
      () => `carousel-item carousel-item-${h.value ? "prev" : "next"} carousel-item-${h.value ? "end" : "start"}`
    ), w = k(
      () => `carousel-item active carousel-item-${h.value ? "start" : "end"}`
    ), { pause: x, resume: V } = yo(
      () => {
        t.rideReverse ? ne() : U();
      },
      m,
      { immediate: t.ride === "carousel" }
    ), G = k(
      () => t.ride === !0 && y.value === !0 || t.ride === "carousel"
    ), W = _(() => Br(i.default, "BCarouselSlide")), P = _(() => ({ "carousel-fade": t.fade })), Y = (le) => {
      var q;
      return new Gl(le, {
        componentId: u.value,
        cancelable: !1,
        target: p.value,
        direction: h.value ? "right" : "left",
        from: B.value,
        to: r.value,
        relatedTarget: ((q = C.value) == null ? void 0 : q.children[r.value]) ?? null
      });
    }, ae = (le) => {
      if (v.value !== !0) {
        if (t.ride === !0 && (y.value = !0), G.value === !0 && V(), h.value = !(le < r.value), le >= W.value.length) {
          if (t.noWrap)
            return;
          r.value = 0;
          return;
        }
        if (le < 0) {
          if (t.noWrap)
            return;
          r.value = W.value.length - 1;
          return;
        }
        B.value = r.value, r.value = le;
      }
    }, ne = () => {
      ae(r.value - 1);
    }, U = () => {
      ae(r.value + 1);
    }, T = (le) => {
      t.keyboard !== !1 && le();
    }, A = () => {
      t.noHoverPause || x();
    }, E = () => {
      G.value && V();
    }, { lengthX: M } = fr(p, {
      passive: !0,
      onSwipeStart() {
        t.noTouch !== !0 && x();
      },
      onSwipeEnd() {
        if (t.noTouch === !0)
          return;
        const le = () => {
          G.value !== !1 && V();
        };
        if (M.value >= c.value) {
          U(), le();
          return;
        }
        M.value <= -c.value && (ne(), le());
      }
    }), Z = () => {
      s("slide", Y("slide")), v.value = !0;
    }, R = () => {
      s("slid", Y("slid")), v.value = !1;
    }, H = (le) => {
      r.value !== 0 && le.classList.add("carousel-item");
    }, ce = (le) => {
      var q, oe;
      f.value = ((oe = (q = d.value) == null ? void 0 : q.find((de) => de.$el === le)) == null ? void 0 : oe.$props.interval) ?? null;
    };
    return De(
      "ArrowLeft",
      () => {
        T(ne);
      },
      { target: p }
    ), De(
      "ArrowRight",
      () => {
        T(U);
      },
      { target: p }
    ), fe(
      () => t.ride,
      () => {
        y.value = !1;
      }
    ), fe(g, (le) => {
      if (le) {
        A();
        return;
      }
      E();
    }), o({
      next: U,
      pause: x,
      prev: ne,
      resume: V
    }), Xe(wo, {
      background: k(() => t.background),
      width: k(() => t.imgWidth),
      height: k(() => t.imgHeight)
    }), (le, q) => (b(), O("div", {
      id: n(u),
      ref_key: "element",
      ref: p,
      class: D(["carousel slide pointer-event", P.value])
    }, [
      n(t).indicators ? (b(), O("div", Si, [
        (b(!0), O(pe, null, ke(W.value.length, (oe, de) => (b(), O("button", {
          key: de,
          type: "button",
          "data-bs-target": "",
          class: D(de === r.value ? "active" : ""),
          "aria-current": de === r.value ? !0 : void 0,
          "aria-label": `${n(t).indicatorsButtonLabel} ${de}`,
          onClick: (ee) => ae(de)
        }, null, 10, Vi))), 128))
      ])) : te("", !0),
      Q("div", {
        ref_key: "relatedTarget",
        ref: C,
        class: "carousel-inner"
      }, [
        be(ql, {
          "enter-from-class": S.value,
          "enter-active-class": S.value,
          "enter-to-class": S.value,
          "leave-from-class": w.value,
          "leave-active-class": w.value,
          "leave-to-class": w.value,
          onBeforeLeave: Z,
          onAfterLeave: R,
          onAfterEnter: H,
          onEnter: ce
        }, {
          default: I(() => [
            (b(!0), O(pe, null, ke(W.value, (oe, de) => ct((b(), N(ue(oe), {
              key: de,
              ref_for: !0,
              ref_key: "slideValues",
              ref: d,
              class: D({ active: de === r.value && v.value === !1 })
            }, null, 8, ["class"])), [
              [Dt, de === r.value]
            ])), 128))
          ]),
          _: 1
        }, 8, ["enter-from-class", "enter-active-class", "enter-to-class", "leave-from-class", "leave-active-class", "leave-to-class"])
      ], 512),
      n(t).controls ? (b(), O(pe, { key: 1 }, [
        Q("button", {
          class: "carousel-control-prev",
          type: "button",
          onClick: ne
        }, [
          Ai,
          Q("span", Oi, J(n(t).controlsPrevText), 1)
        ]),
        Q("button", {
          class: "carousel-control-next",
          type: "button",
          onClick: U
        }, [
          Pi,
          Q("span", Ni, J(n(t).controlsNextText), 1)
        ])
      ], 64)) : te("", !0)
    ], 10, xi));
  }
}), Ei = ["innerHTML"], Fi = { key: 1 }, Li = ["innerHTML"], zi = { key: 1 }, Ri = /* @__PURE__ */ z({
  __name: "BCarouselSlide",
  props: {
    background: { default: void 0 },
    caption: { default: void 0 },
    captionHtml: { default: void 0 },
    captionTag: { default: "h3" },
    contentTag: { default: "div" },
    contentVisibleUp: { default: void 0 },
    id: { default: void 0 },
    imgAlt: { default: void 0 },
    imgBlank: { type: Boolean, default: !1 },
    imgBlankColor: { default: "transparent" },
    imgHeight: { default: void 0 },
    imgSrc: { default: void 0 },
    imgSrcset: { default: void 0 },
    imgWidth: { default: void 0 },
    interval: { default: void 0 },
    text: { default: void 0 },
    textHtml: { default: void 0 },
    textTag: { default: "p" }
  },
  setup(a) {
    const e = j(a, "BCarouselSlide"), l = Re(), t = Ve(wo, null), s = k(() => e.text || e.textHtml || !Ae(l.text)), i = k(() => e.caption || e.captionHtml || !Ae(l.caption)), u = k(() => s.value || i.value || !Ae(l.default)), r = _(() => ({
      background: `${e.background || (t == null ? void 0 : t.background.value) || "rgb(171, 171, 171)"} none repeat scroll 0% 0%`
    })), d = _(() => ({
      "d-none": e.contentVisibleUp !== void 0,
      [`d-${e.contentVisibleUp}-block`]: e.contentVisibleUp !== void 0
    }));
    return (c, f) => (b(), O("div", {
      class: "carousel-item",
      style: Le(r.value)
    }, [
      $(c.$slots, "img", {}, () => {
        var m, v;
        return [
          be(rl, {
            class: "d-block w-100",
            alt: n(e).imgAlt,
            srcset: n(e).imgSrcset,
            src: n(e).imgSrc,
            width: n(e).imgWidth || ((m = n(t)) == null ? void 0 : m.width.value),
            height: n(e).imgHeight || ((v = n(t)) == null ? void 0 : v.height.value),
            blank: n(e).imgBlank,
            "blank-color": n(e).imgBlankColor
          }, null, 8, ["alt", "srcset", "src", "width", "height", "blank", "blank-color"])
        ];
      }),
      u.value ? (b(), N(ue(n(e).contentTag), {
        key: 0,
        class: D(["carousel-caption", d.value])
      }, {
        default: I(() => [
          i.value ? (b(), N(ue(n(e).captionTag), { key: 0 }, {
            default: I(() => [
              $(c.$slots, "caption", {}, () => [
                n(e).captionHtml ? (b(), O("span", {
                  key: 0,
                  innerHTML: n(e).captionHtml
                }, null, 8, Ei)) : (b(), O("span", Fi, J(n(e).caption), 1))
              ])
            ]),
            _: 3
          })) : te("", !0),
          s.value ? (b(), N(ue(n(e).textTag), { key: 1 }, {
            default: I(() => [
              $(c.$slots, "text", {}, () => [
                n(e).textHtml ? (b(), O("span", {
                  key: 0,
                  innerHTML: n(e).textHtml
                }, null, 8, Li)) : (b(), O("span", zi, J(n(e).text), 1))
              ])
            ]),
            _: 3
          })) : te("", !0),
          $(c.$slots, "default")
        ]),
        _: 3
      }, 8, ["class"])) : te("", !0)
    ], 4));
  }
}), Lt = /* @__PURE__ */ z({
  __name: "BCol",
  props: {
    alignSelf: { default: void 0 },
    tag: { default: "div" },
    order: { default: void 0 },
    offset: { default: void 0 },
    cols: { default: void 0 },
    col: { type: Boolean, default: !1 },
    offsetSm: { default: void 0 },
    offsetMd: { default: void 0 },
    offsetLg: { default: void 0 },
    offsetXl: { default: void 0 },
    offsetXxl: { default: void 0 },
    orderSm: { default: void 0 },
    orderMd: { default: void 0 },
    orderLg: { default: void 0 },
    orderXl: { default: void 0 },
    orderXxl: { default: void 0 },
    sm: { type: [Boolean, Number, String], default: !1 },
    md: { type: [Boolean, Number, String], default: !1 },
    lg: { type: [Boolean, Number, String], default: !1 },
    xl: { type: [Boolean, Number, String], default: !1 },
    xxl: { type: [Boolean, Number, String], default: !1 }
  },
  setup(a) {
    const e = j(a, "BCol"), l = _(() => [
      ...Jt(
        {
          sm: e.sm,
          md: e.md,
          lg: e.lg,
          xl: e.xl,
          xxl: e.xxl
        },
        ["sm", "md", "lg", "xl", "xxl"],
        "col"
      ),
      ...Jt(
        {
          order: e.order,
          orderLg: e.orderLg,
          orderMd: e.orderMd,
          orderSm: e.orderSm,
          orderXl: e.orderXl,
          orderXxl: e.orderXxl
        },
        ["order", "orderLg", "orderMd", "orderSm", "orderXl", "orderXxl"],
        "order"
      ),
      ...Jt(
        {
          offset: e.offset,
          offsetLg: e.offsetLg,
          offsetMd: e.offsetMd,
          offsetSm: e.offsetSm,
          offsetXl: e.offsetXl,
          offsetXxl: e.offsetXxl
        },
        ["offset", "offsetLg", "offsetMd", "offsetSm", "offsetXl", "offsetXxl"],
        "offset"
      )
    ]), t = _(() => [
      l.value,
      {
        col: e.col || !l.value.some((s) => s.startsWith("col-")) && !e.cols,
        [`col-${e.cols}`]: e.cols !== void 0,
        [`offset-${e.offset}`]: e.offset !== void 0,
        [`order-${e.order}`]: e.order !== void 0,
        [`align-self-${e.alignSelf}`]: e.alignSelf !== void 0
      }
    ]);
    return (s, i) => (b(), N(ue(n(e).tag), {
      class: D(t.value)
    }, {
      default: I(() => [
        $(s.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Hi = /* @__PURE__ */ z({
  __name: "BContainer",
  props: {
    fluid: { type: [Boolean, String], default: !1 },
    gutterX: { default: void 0 },
    gutterY: { default: void 0 },
    tag: { default: "div" }
  },
  setup(a) {
    const e = j(a, "BContainer"), l = _(() => ({
      container: e.fluid === !1,
      "container-fluid": e.fluid === !0,
      [`container-${e.fluid}`]: typeof e.fluid == "string",
      [`gx-${e.gutterX}`]: e.gutterX !== void 0,
      [`gy-${e.gutterY}`]: e.gutterY !== void 0
    }));
    return (t, s) => (b(), N(ue(n(e).tag), {
      class: D(l.value)
    }, {
      default: I(() => [
        $(t.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Mi = { class: "visually-hidden" }, Di = ["aria-labelledby", "role"], pn = /* @__PURE__ */ z({
  __name: "BDropdown",
  props: /* @__PURE__ */ ye({
    ariaLabel: { default: void 0 },
    autoClose: { type: [Boolean, String], default: !0 },
    boundary: { default: "clippingAncestors" },
    boundaryPadding: { default: void 0 },
    center: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    dropend: { type: Boolean, default: !1 },
    dropstart: { type: Boolean, default: !1 },
    dropup: { type: Boolean, default: !1 },
    end: { type: Boolean, default: !1 },
    floatingMiddleware: { default: void 0 },
    id: { default: void 0 },
    isNav: { type: Boolean, default: !1 },
    lazy: { type: Boolean, default: !1 },
    menuClass: { default: void 0 },
    modelValue: { type: Boolean },
    noCaret: { type: Boolean, default: !1 },
    noFlip: { type: Boolean, default: !1 },
    noShift: { type: Boolean, default: !1 },
    noSize: { type: Boolean, default: !1 },
    offset: { default: 0 },
    role: { default: "menu" },
    size: { default: "md" },
    skipWrapper: { type: Boolean, default: !1 },
    split: { type: Boolean, default: !1 },
    splitButtonType: { default: "button" },
    splitClass: { default: void 0 },
    splitDisabled: { type: Boolean, default: void 0 },
    splitHref: { default: void 0 },
    splitTo: { default: void 0 },
    splitVariant: { default: void 0 },
    strategy: { default: "absolute" },
    text: { default: void 0 },
    toggleClass: { default: void 0 },
    toggleText: { default: "Toggle dropdown" },
    variant: { default: "secondary" },
    wrapperClass: { default: void 0 },
    teleportDisabled: { default: !1 },
    teleportTo: { default: void 0 }
  }, {
    modelValue: { type: Boolean, default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ ye(["click", "hidden", "hide", "hide-prevented", "show", "show-prevented", "shown", "toggle"], ["update:modelValue"]),
  setup(a, { expose: o, emit: e }) {
    const t = j(a, "BDropdown"), s = e, i = we(() => t.id, "dropdown"), u = _e(a, "modelValue"), r = Ve(Lo, !1), d = k(
      () => typeof t.offset == "string" || typeof t.offset == "number" ? t.offset : NaN
    ), c = he(d), f = F(null), m = F(null), v = F(null), y = F(null), h = _(
      () => t.boundary === "document" || t.boundary === "viewport" ? void 0 : t.boundary
    ), C = _(
      () => t.boundary === "document" || t.boundary === "viewport" ? t.boundary : void 0
    ), p = k(() => t.split ? m.value : v.value);
    De(
      "Escape",
      () => {
        u.value = !u.value;
      },
      { target: p }
    ), De(
      "Escape",
      () => {
        u.value = !u.value;
      },
      { target: f }
    );
    const B = (A, E) => {
      var Z, R, H, ce, le, q, oe;
      if ((R = f.value) != null && R.contains((Z = A.target) == null ? void 0 : Z.closest("form")) || /input|select|option|textarea|form/i.test((H = A.target) == null ? void 0 : H.tagName))
        return;
      if (A.preventDefault(), !u.value) {
        open(), Ie(() => B(A, E));
        return;
      }
      const M = (ce = f.value) == null ? void 0 : ce.querySelectorAll(".dropdown-item:not(.disabled):not(:disabled)");
      if (M)
        if ((le = f.value) != null && le.contains(document.activeElement)) {
          const de = f.value.querySelector(".dropdown-item:focus"), ee = Array.prototype.indexOf.call(M, de) + E;
          ee >= 0 && ee < (M == null ? void 0 : M.length) && ((q = M[ee]) == null || q.focus());
        } else
          (oe = M[E === -1 ? M.length - 1 : 0]) == null || oe.focus();
    };
    De("ArrowUp", (A) => B(A, -1), { target: p }), De("ArrowDown", (A) => B(A, 1), { target: p }), De("ArrowUp", (A) => B(A, -1), { target: f }), De("ArrowDown", (A) => B(A, 1), { target: f });
    const g = _(
      () => gr({
        top: t.dropup,
        start: t.dropstart,
        end: t.dropend,
        alignCenter: t.center,
        alignEnd: t.end
      })
    ), S = F({}), w = _(() => {
      if (t.floatingMiddleware !== void 0)
        return t.floatingMiddleware;
      const A = typeof t.offset == "string" || typeof t.offset == "number" ? c.value : t.offset, E = [Zl(A)];
      return t.noFlip === !1 && E.push(
        ro({
          boundary: h.value,
          rootBoundary: C.value,
          padding: t.boundaryPadding
        })
      ), t.noShift === !1 && E.push(
        so({
          boundary: h.value,
          rootBoundary: C.value,
          padding: t.boundaryPadding
        })
      ), t.noSize === !1 && E.push(
        io({
          boundary: h.value,
          rootBoundary: C.value,
          padding: t.boundaryPadding,
          apply({ availableWidth: M, availableHeight: Z }) {
            S.value = {
              maxHeight: Z && u.value ? `${Z}px` : void 0,
              maxWidth: M && u.value ? `${M}px` : void 0
            };
          }
        })
      ), E;
    }), { update: x, floatingStyles: V } = co(p, f, {
      placement: g,
      middleware: w,
      strategy: k(() => t.strategy),
      whileElementsMounted: no
    }), G = _(() => [
      t.wrapperClass,
      {
        "btn-group": !t.wrapperClass && t.split,
        dropdown: !t.wrapperClass && !t.split,
        dropup: t.dropup,
        dropend: t.dropend,
        dropstart: t.dropstart,
        "position-static": t.boundary !== "clippingAncestors" && !t.isNav
      }
    ]), W = _(() => [
      t.split ? t.splitClass : t.toggleClass,
      {
        "nav-link": t.isNav,
        "dropdown-toggle": !t.split,
        "dropdown-toggle-no-caret": t.noCaret && !t.split,
        show: t.split ? void 0 : u.value
      }
    ]), P = () => {
      T();
    }, Y = (A) => {
      t.split ? s("click", A) : P();
    };
    go(
      f,
      () => {
        u.value && (t.autoClose === !0 || t.autoClose === "outside") && T();
      },
      { ignore: [m, v] }
    );
    const ae = () => {
      u.value && (t.autoClose === !0 || t.autoClose === "inside") && T();
    }, ne = () => {
      u.value && T();
    }, U = () => {
      u.value || T();
    }, T = () => {
      var M, Z;
      s("toggle");
      const A = u.value, E = new _t(A ? "hide" : "show");
      if (s(A ? "hide" : "show", E), E.defaultPrevented) {
        s(A ? "hide-prevented" : "show-prevented");
        return;
      }
      u.value = !A, s(A ? "hidden" : "shown"), (Z = (M = y.value) == null ? void 0 : M.dispatchEvent) == null || Z.call(M, new Event("forceHide"));
    };
    return fe(u, () => {
      x();
    }), o({
      hide: ne,
      show: U,
      toggle: T
    }), Xe(Ao, {
      id: i,
      show: U,
      hide: ne,
      toggle: T,
      visible: k(() => u.value),
      isNav: k(() => t.isNav)
    }), (A, E) => (b(), N(Gt, {
      ref_key: "wrapper",
      ref: y,
      skip: n(r) || n(t).skipWrapper,
      class: D(G.value)
    }, {
      default: I(() => [
        be(pt, {
          id: n(i),
          ref_key: "splitButton",
          ref: v,
          variant: n(t).splitVariant || n(t).variant,
          size: n(t).size,
          class: D(W.value),
          disabled: n(t).splitDisabled || n(t).disabled,
          type: n(t).splitButtonType,
          "aria-label": n(t).ariaLabel,
          "aria-expanded": n(t).split ? void 0 : u.value,
          "aria-haspopup": n(t).split ? void 0 : "menu",
          href: n(t).split ? n(t).splitHref : void 0,
          to: n(t).split && n(t).splitTo ? n(t).splitTo : void 0,
          onClick: Y
        }, {
          default: I(() => [
            $(A.$slots, "button-content", {}, () => [
              se(J(n(t).text), 1)
            ])
          ]),
          _: 3
        }, 8, ["id", "variant", "size", "class", "disabled", "type", "aria-label", "aria-expanded", "aria-haspopup", "href", "to"]),
        n(t).split ? (b(), N(pt, {
          key: 0,
          ref_key: "button",
          ref: m,
          variant: n(t).variant,
          size: n(t).size,
          disabled: n(t).disabled,
          class: D([[n(t).toggleClass, { show: u.value }], "dropdown-toggle-split dropdown-toggle"]),
          "aria-expanded": u.value,
          "aria-haspopup": "menu",
          onClick: P
        }, {
          default: I(() => [
            Q("span", Mi, [
              $(A.$slots, "toggle-text", {}, () => [
                se(J(n(t).toggleText), 1)
              ])
            ])
          ]),
          _: 3
        }, 8, ["variant", "size", "disabled", "class", "aria-expanded"])) : te("", !0),
        (b(), N(Bt, {
          to: n(t).teleportTo,
          disabled: !n(t).teleportTo || n(t).teleportDisabled
        }, [
          !n(t).lazy || u.value ? ct((b(), O("ul", {
            key: 0,
            ref_key: "floating",
            ref: f,
            style: Le([n(V), S.value]),
            class: D(["dropdown-menu overflow-auto", [n(t).menuClass, { show: u.value }]]),
            "aria-labelledby": n(i),
            role: n(t).role,
            onClick: ae
          }, [
            $(A.$slots, "default", {
              hide: ne,
              show: U
            })
          ], 14, Di)), [
            [Dt, n(t).lazy || u.value]
          ]) : te("", !0)
        ], 8, ["to", "disabled"]))
      ]),
      _: 3
    }, 8, ["skip", "class"]));
  }
}), ji = { role: "presentation" }, Wi = /* @__PURE__ */ z({
  __name: "BDropdownDivider",
  props: {
    tag: { default: "hr" }
  },
  setup(a) {
    const e = j(a, "BDropdownDivider");
    return (l, t) => (b(), O("li", ji, [
      (b(), N(ue(n(e).tag), {
        class: "dropdown-divider",
        role: "separator",
        "aria-orientation": "horizontal"
      }))
    ]));
  }
}), qi = { role: "presentation" }, Gi = /* @__PURE__ */ z({
  __name: "BDropdownForm",
  setup(a) {
    return (o, e) => (b(), O("li", qi, [
      Q("form", K({ class: "dropdown-item-text" }, o.$attrs), [
        $(o.$slots, "default")
      ], 16)
    ]));
  }
}), Ui = { role: "presentation" }, Xi = ["id", "aria-describedby"], Ki = /* @__PURE__ */ z({
  inheritAttrs: !1,
  __name: "BDropdownGroup",
  props: {
    ariaDescribedby: { default: void 0 },
    header: { default: void 0 },
    headerClass: { default: void 0 },
    headerTag: { default: "header" },
    headerVariant: { default: null },
    id: { default: void 0 }
  },
  setup(a) {
    const e = j(a, "BDropdownGroup"), l = k(() => e.id ? `${e.id}_group_dd_header` : void 0), t = k(() => e.headerTag === "header" ? void 0 : "heading"), s = _(() => [
      e.headerClass,
      {
        [`text-${e.headerVariant}`]: e.headerVariant !== null
      }
    ]);
    return (i, u) => (b(), O("li", Ui, [
      (b(), N(ue(n(e).headerTag), {
        id: l.value,
        class: D(["dropdown-header", s.value]),
        role: t.value
      }, {
        default: I(() => [
          $(i.$slots, "header", {}, () => [
            se(J(n(e).header), 1)
          ])
        ]),
        _: 3
      }, 8, ["id", "class", "role"])),
      Q("ul", K({
        id: n(e).id,
        role: "group",
        class: "list-unstyled"
      }, i.$attrs, {
        "aria-describedby": n(e).ariaDescribedby || l.value
      }), [
        $(i.$slots, "default")
      ], 16, Xi)
    ]));
  }
}), Yi = { class: "dropdown-header" }, Zi = /* @__PURE__ */ z({
  __name: "BDropdownHeader",
  setup(a) {
    return (o, e) => (b(), O("li", null, [
      Q("h6", Yi, [
        $(o.$slots, "default")
      ])
    ]));
  }
}), Ji = /* @__PURE__ */ z({
  inheritAttrs: !1,
  __name: "BDropdownItem",
  props: {
    linkClass: { default: void 0 },
    wrapperAttrs: { default: void 0 },
    active: { type: Boolean, default: void 0 },
    activeClass: { default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    stretched: { type: Boolean, default: !1 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: null },
    prefetch: { type: Boolean },
    noPrefetch: { type: Boolean },
    prefetchedClass: {},
    noRel: { type: Boolean }
  },
  emits: ["click"],
  setup(a, { emit: o }) {
    const l = j(a, "BDropdownItem"), t = o, { class: s, ...i } = Mt(), { computedLink: u, computedLinkProps: r } = wt(l), d = _(() => [
      l.linkClass,
      {
        active: l.active,
        disabled: l.disabled,
        [`text-${l.variant}`]: l.variant !== null
      }
    ]), c = k(() => u.value ? st : l.href ? "a" : "button"), f = Ve(al, null), m = Ve(Ao, null), v = Ve(ll, null), y = (h) => {
      var C, p, B;
      t("click", h), v !== null && ((C = v == null ? void 0 : v.autoClose) == null ? void 0 : C.value) === !0 && ((p = f == null ? void 0 : f.hide) == null || p.call(f)), (B = m == null ? void 0 : m.hide) == null || B.call(m);
    };
    return (h, C) => (b(), O("li", K({
      role: "presentation",
      class: n(s)
    }, n(l).wrapperAttrs), [
      (b(), N(ue(c.value), K({
        class: ["dropdown-item", d.value],
        disabled: n(l).disabled,
        "aria-disabled": n(l).disabled ? !0 : null,
        "aria-current": n(l).active ? !0 : null,
        href: c.value === "a" ? n(l).href : null,
        rel: n(l).rel,
        role: "menuitem",
        type: c.value === "button" ? "button" : null,
        target: n(l).target
      }, { ...n(r), ...i }, { onClick: y }), {
        default: I(() => [
          $(h.$slots, "default")
        ]),
        _: 3
      }, 16, ["class", "disabled", "aria-disabled", "aria-current", "href", "rel", "type", "target"]))
    ], 16));
  }
}), Qi = { role: "presentation" }, eu = ["disabled"], tu = /* @__PURE__ */ z({
  inheritAttrs: !1,
  __name: "BDropdownItemButton",
  props: {
    active: { type: Boolean, default: !1 },
    activeClass: { default: "active" },
    buttonClass: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    variant: { default: null }
  },
  emits: ["click"],
  setup(a, { emit: o }) {
    const l = j(a, "BDropdownItemButton"), t = o, s = _(() => [
      l.buttonClass,
      {
        [l.activeClass]: l.active,
        disabled: l.disabled,
        [`text-${l.variant}`]: l.variant !== null
      }
    ]), i = (u) => {
      t("click", u);
    };
    return (u, r) => (b(), O("li", Qi, [
      Q("button", {
        role: "menu",
        type: "button",
        class: D(["dropdown-item", s.value]),
        disabled: n(l).disabled,
        onClick: i
      }, [
        $(u.$slots, "default")
      ], 10, eu)
    ]));
  }
}), au = { role: "presentation" }, lu = /* @__PURE__ */ z({
  __name: "BDropdownText",
  props: {
    text: { default: "" }
  },
  setup(a) {
    const e = j(a, "BDropdownText");
    return (l, t) => (b(), O("li", au, [
      Q("span", K({ class: "dropdown-item-text" }, l.$attrs), [
        $(l.$slots, "default", {}, () => [
          se(J(n(e).text), 1)
        ])
      ], 16)
    ]));
  }
}), ou = ["id", "novalidate"], mn = /* @__PURE__ */ z({
  __name: "BForm",
  props: {
    floating: { type: Boolean, default: !1 },
    id: { default: void 0 },
    novalidate: { type: Boolean, default: !1 },
    validated: { type: Boolean, default: !1 }
  },
  emits: ["submit"],
  setup(a, { expose: o, emit: e }) {
    const t = j(a, "BForm"), s = e, i = F(null), u = _(() => ({
      "form-floating": t.floating,
      "was-validated": t.validated
    })), r = (d) => {
      s("submit", d);
    };
    return o({
      element: i
    }), (d, c) => (b(), O("form", {
      id: n(t).id,
      ref_key: "element",
      ref: i,
      novalidate: n(t).novalidate,
      class: D(u.value),
      onSubmit: bt(r, ["prevent"])
    }, [
      $(d.$slots, "default")
    ], 42, ou));
  }
}), nu = { class: "form-floating" }, su = ["for"], ru = /* @__PURE__ */ z({
  __name: "BFormFloatingLabel",
  props: {
    label: { default: void 0 },
    labelFor: { default: void 0 },
    text: { default: void 0 }
  },
  setup(a) {
    const e = j(a, "BFormFloatingLabel");
    return (l, t) => (b(), O("div", nu, [
      $(l.$slots, "default", {}, () => [
        se(J(n(e).text), 1)
      ]),
      Q("label", {
        for: n(e).labelFor
      }, [
        $(l.$slots, "label", {}, () => [
          se(J(n(e).label), 1)
        ])
      ], 8, su)
    ]));
  }
}), Ea = /* @__PURE__ */ z({
  __name: "BFormInvalidFeedback",
  props: {
    ariaLive: { default: void 0 },
    forceShow: { type: Boolean, default: !1 },
    id: { default: void 0 },
    role: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    tag: { default: "div" },
    text: { default: void 0 },
    tooltip: { type: Boolean, default: !1 }
  },
  setup(a) {
    const e = j(a, "BFormInvalidFeedback"), l = k(() => e.forceShow === !0 || e.state === !1), t = _(() => ({
      "d-block": l.value,
      "invalid-feedback": !e.tooltip,
      "invalid-tooltip": e.tooltip
    }));
    return (s, i) => (b(), N(ue(n(e).tag), {
      id: n(e).id,
      role: n(e).role,
      "aria-live": n(e).ariaLive,
      "aria-atomic": n(e).ariaLive ? !0 : void 0,
      class: D(t.value)
    }, {
      default: I(() => [
        $(s.$slots, "default", {}, () => [
          se(J(n(e).text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "role", "aria-live", "aria-atomic", "class"]));
  }
}), aa = /* @__PURE__ */ z({
  __name: "BFormRow",
  props: {
    tag: { default: "div" }
  },
  setup(a) {
    const e = j(a, "BFormRow");
    return (l, t) => (b(), N(ue(n(e).tag), { class: "row d-flex flex-wrap" }, {
      default: I(() => [
        $(l.$slots, "default")
      ]),
      _: 3
    }));
  }
}), Fa = /* @__PURE__ */ z({
  __name: "BFormText",
  props: {
    id: { default: void 0 },
    inline: { type: Boolean, default: !1 },
    tag: { default: "small" },
    text: { default: void 0 },
    textVariant: { default: "body-secondary" }
  },
  setup(a) {
    const e = j(a, "BFormText"), l = _(() => ({
      [`text-${e.textVariant}`]: e.textVariant !== null,
      "form-text": !e.inline
    }));
    return (t, s) => (b(), N(ue(n(e).tag), {
      id: n(e).id,
      class: D(l.value)
    }, {
      default: I(() => [
        $(t.$slots, "default", {}, () => [
          se(J(n(e).text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), La = /* @__PURE__ */ z({
  __name: "BFormValidFeedback",
  props: {
    ariaLive: { default: void 0 },
    forceShow: { type: Boolean, default: !1 },
    id: { default: void 0 },
    role: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    tag: { default: "div" },
    text: { default: void 0 },
    tooltip: { type: Boolean, default: !1 }
  },
  setup(a) {
    const e = j(a, "BFormInvalidFeedback"), l = k(() => e.forceShow === !0 || e.state === !0), t = _(() => ({
      "d-block": l.value,
      "valid-feedback": !e.tooltip,
      "valid-tooltip": e.tooltip
    }));
    return (s, i) => (b(), N(ue(n(e).tag), {
      id: n(e).id,
      role: n(e).role,
      "aria-live": n(e).ariaLive,
      "aria-atomic": n(e).ariaLive ? !0 : void 0,
      class: D(t.value)
    }, {
      default: I(() => [
        $(s.$slots, "default", {}, () => [
          se(J(n(e).text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "role", "aria-live", "aria-atomic", "class"]));
  }
}), iu = ["id", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "aria-required", "value", "true-value", "false-value", "indeterminate"], uu = ["for"], bn = /* @__PURE__ */ z({
  inheritAttrs: !1,
  __name: "BFormCheckbox",
  props: /* @__PURE__ */ ye({
    ariaLabel: { default: void 0 },
    ariaLabelledby: { default: void 0 },
    autofocus: { type: Boolean, default: !1 },
    button: { type: Boolean, default: !1 },
    buttonGroup: { type: Boolean, default: !1 },
    buttonVariant: { default: null },
    disabled: { type: Boolean, default: !1 },
    form: { default: void 0 },
    id: { default: void 0 },
    indeterminate: { type: Boolean },
    inline: { type: Boolean, default: !1 },
    modelValue: { type: [Array, Set, String, Boolean, Object, Number, null] },
    name: { default: void 0 },
    plain: { type: Boolean, default: !1 },
    required: { type: Boolean, default: void 0 },
    reverse: { type: Boolean, default: !1 },
    size: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    switch: { type: Boolean, default: !1 },
    uncheckedValue: { type: [Array, Set, String, Boolean, Object, Number, null], default: !1 },
    value: { type: [String, Boolean, Array, Set, Object, Number, null], default: !0 }
  }, {
    modelValue: { type: [Array, Set, String, Boolean, Object, Number, null], default: void 0 },
    modelModifiers: {},
    indeterminate: { type: Boolean, default: !1 },
    indeterminateModifiers: {}
  }),
  emits: ["update:modelValue", "update:indeterminate"],
  setup(a, { expose: o }) {
    const l = j(a, "BFormCheckbox"), t = Re(), s = _e(a, "modelValue"), i = _e(a, "indeterminate"), u = we(() => l.id, "form-check"), r = Ve(So, null), d = F(null), { focused: c } = Fe(d, {
      initialValue: l.autofocus
    }), f = k(() => !Ae(t.default)), m = _({
      get: () => (r == null ? void 0 : r.modelValue.value) ?? s.value,
      set: (g) => {
        if (g !== void 0) {
          if (i.value = !1, r !== null && Array.isArray(g)) {
            r.modelValue.value = g;
            return;
          }
          s.value = g;
        }
      }
    }), v = k(
      () => !!(l.name ?? (r == null ? void 0 : r.name.value)) && (l.required || (r == null ? void 0 : r.required.value))
    ), y = k(() => l.buttonGroup || ((r == null ? void 0 : r.buttons.value) ?? !1)), h = _(() => ({
      plain: l.plain || ((r == null ? void 0 : r.plain.value) ?? !1),
      button: l.button || ((r == null ? void 0 : r.buttons.value) ?? !1),
      inline: l.inline || ((r == null ? void 0 : r.inline.value) ?? !1),
      reverse: l.reverse || ((r == null ? void 0 : r.reverse.value) ?? !1),
      switch: l.switch || ((r == null ? void 0 : r.switch.value) ?? !1),
      state: l.state || (r == null ? void 0 : r.state.value),
      size: l.size ?? (r == null ? void 0 : r.size.value) ?? "md",
      // This is where the true default is made
      buttonVariant: l.buttonVariant ?? (r == null ? void 0 : r.buttonVariant.value) ?? "secondary",
      // This is where the true default is made
      hasDefaultSlot: f.value
    })), C = Do(h), p = jo(h), B = Wo(h);
    return o({
      blur: () => {
        c.value = !1;
      },
      element: d,
      focus: () => {
        c.value = !0;
      }
    }), (g, S) => (b(), N(Gt, {
      skip: y.value,
      class: D(n(C))
    }, {
      default: I(() => {
        var w, x, V;
        return [
          ct(Q("input", K({ id: n(u) }, g.$attrs, {
            ref_key: "input",
            ref: d,
            "onUpdate:modelValue": S[0] || (S[0] = (G) => m.value = G),
            class: n(p),
            type: "checkbox",
            disabled: n(l).disabled || ((w = n(r)) == null ? void 0 : w.disabled.value),
            required: v.value || void 0,
            name: n(l).name || ((x = n(r)) == null ? void 0 : x.name.value),
            form: n(l).form || ((V = n(r)) == null ? void 0 : V.form.value),
            "aria-label": n(l).ariaLabel,
            "aria-labelledby": n(l).ariaLabelledby,
            "aria-required": v.value || void 0,
            value: n(l).value,
            "true-value": n(l).value,
            "false-value": n(l).uncheckedValue,
            indeterminate: n(l).indeterminate
          }), null, 16, iu), [
            [Nn, m.value]
          ]),
          f.value || n(l).plain === !1 ? (b(), O("label", {
            key: 0,
            for: n(u),
            class: D(n(B))
          }, [
            $(g.$slots, "default")
          ], 10, uu)) : te("", !0)
        ];
      }),
      _: 3
    }, 8, ["skip", "class"]));
  }
}), du = ["id"], cu = ["innerHTML"], fu = /* @__PURE__ */ z({
  __name: "BFormCheckboxGroup",
  props: /* @__PURE__ */ ye({
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    autofocus: { type: Boolean, default: !1 },
    buttonVariant: { default: "secondary" },
    buttons: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    disabledField: { default: "disabled" },
    form: { default: void 0 },
    htmlField: { default: "html" },
    id: { default: void 0 },
    modelValue: {},
    name: { default: void 0 },
    options: { default: () => [] },
    plain: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    reverse: { type: Boolean, default: !1 },
    size: { default: "md" },
    stacked: { type: Boolean, default: !1 },
    state: { type: [Boolean, null], default: null },
    switches: { type: Boolean, default: !1 },
    textField: { default: "text" },
    validated: { type: Boolean, default: !1 },
    valueField: { default: "value" }
  }, {
    modelValue: {
      default: () => []
    },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(a, { expose: o }) {
    const l = j(a, "BFormCheckboxGroup"), t = _e(a, "modelValue"), s = we(() => l.id, "checkbox"), i = we(() => l.name, "checkbox"), u = F(null), { focused: r } = Fe(u, {
      initialValue: l.autofocus
    });
    Xe(So, {
      modelValue: t,
      switch: k(() => l.switches),
      buttonVariant: k(() => l.buttonVariant),
      form: k(() => l.form),
      name: i,
      state: k(() => l.state),
      plain: k(() => l.plain),
      size: k(() => l.size),
      inline: k(() => !l.stacked),
      reverse: k(() => l.reverse),
      required: k(() => l.required),
      buttons: k(() => l.buttons),
      disabled: k(() => l.disabled)
    });
    const d = _(
      () => l.options.map(
        (v, y) => typeof v == "string" || typeof v == "number" ? {
          props: {
            value: v,
            disabled: l.disabled
          },
          text: v.toString(),
          html: void 0,
          self: Symbol(`checkboxGroupOptionItem${y}`)
        } : {
          props: {
            value: v[l.valueField],
            disabled: v[l.disabledField],
            ...v.props ? v.props : {}
          },
          text: v[l.textField],
          html: v[l.htmlField],
          self: Symbol(`checkboxGroupOptionItem${y}`)
        }
      )
    ), c = _(() => ({
      required: l.required,
      ariaInvalid: l.ariaInvalid,
      state: l.state,
      validated: l.validated,
      buttons: l.buttons,
      stacked: l.stacked,
      size: l.size
    })), f = qo(c), m = Go(c);
    return o({
      blur: () => {
        r.value = !1;
      },
      focus: () => {
        r.value = !0;
      }
    }), (v, y) => (b(), O("div", K(n(f), {
      id: n(s),
      ref_key: "element",
      ref: u,
      role: "group",
      class: [n(m), "bv-no-focus-ring"],
      tabindex: "-1"
    }), [
      $(v.$slots, "first"),
      (b(!0), O(pe, null, ke(d.value, (h) => (b(), N(bn, K({
        key: h.self,
        ref_for: !0
      }, h.props), {
        default: I(() => [
          h.html ? (b(), O("span", {
            key: 0,
            innerHTML: h.html
          }, null, 8, cu)) : (b(), O(pe, { key: 1 }, [
            se(J(h.text), 1)
          ], 64))
        ]),
        _: 2
      }, 1040))), 128)),
      $(v.$slots, "default")
    ], 16, du));
  }
}), vu = ["for"], pu = ["id", "form", "name", "multiple", "disabled", "capture", "accept", "required", "aria-label", "aria-labelledby", "aria-required", "directory", "webkitdirectory"], mu = /* @__PURE__ */ z({
  inheritAttrs: !1,
  __name: "BFormFile",
  props: /* @__PURE__ */ ye({
    ariaLabel: { default: void 0 },
    ariaLabelledby: { default: void 0 },
    accept: { default: "" },
    autofocus: { type: Boolean, default: !1 },
    capture: { type: [Boolean, String], default: !1 },
    directory: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    form: { default: void 0 },
    id: { default: void 0 },
    label: { default: "" },
    labelClass: { default: void 0 },
    modelValue: {},
    multiple: { type: Boolean, default: !1 },
    name: { default: void 0 },
    noButton: { type: Boolean, default: !1 },
    noDrop: { type: Boolean, default: !1 },
    noTraverse: { type: Boolean, default: !1 },
    plain: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    size: { default: void 0 },
    state: { type: [Boolean, null], default: null }
  }, {
    modelValue: {
      default: null
    },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(a, { expose: o }) {
    const e = Re(), t = j(a, "BFormFile"), s = _e(a, "modelValue"), i = we(() => t.id), u = Ct(() => t.state), r = F(null), { focused: d } = Fe(r, { initialValue: t.autofocus }), c = k(() => !Ae(e.label)), f = k(
      () => typeof t.accept == "string" ? t.accept : t.accept.join(",")
    ), m = _(() => [
      u.value,
      {
        [`form-control-${t.size}`]: t.size !== void 0,
        "form-control": !t.plain,
        "form-control-input-file-hide-button": t.noButton
      }
    ]), v = () => {
      var p, B;
      const C = ((p = r.value) == null ? void 0 : p.files) === null || ((B = r.value) == null ? void 0 : B.files) === void 0 ? null : [...r.value.files];
      s.value = C === null ? null : t.multiple === !0 ? C : C[0];
    }, y = (C) => {
      t.noDrop === !0 && C.preventDefault();
    }, h = () => {
      s.value = null;
    };
    return fe(s, (C) => {
      C === null && r.value !== null && (r.value.value = "");
    }), o({
      blur: () => {
        d.value = !1;
      },
      element: r,
      focus: () => {
        d.value = !0;
      },
      reset: h
    }), (C, p) => (b(), O(pe, null, [
      c.value || n(t).label ? (b(), O("label", {
        key: 0,
        class: D(["form-label", n(t).labelClass]),
        for: n(i)
      }, [
        $(C.$slots, "label", {}, () => [
          se(J(n(t).label), 1)
        ])
      ], 10, vu)) : te("", !0),
      Q("input", K({ id: n(i) }, C.$attrs, {
        ref_key: "input",
        ref: r,
        type: "file",
        class: m.value,
        form: n(t).form,
        name: n(t).name,
        multiple: n(t).multiple,
        disabled: n(t).disabled,
        capture: n(t).capture,
        accept: f.value || void 0,
        required: n(t).required || void 0,
        "aria-label": n(t).ariaLabel,
        "aria-labelledby": n(t).ariaLabelledby,
        "aria-required": n(t).required || void 0,
        directory: n(t).directory,
        webkitdirectory: n(t).directory,
        onChange: v,
        onDrop: y
      }), null, 16, pu)
    ], 64));
  }
}), yn = ["input", "select", "textarea"], bu = yn.map((a) => `${a}:not([disabled])`).join(), yu = [...yn, "a", "button", "label"], gu = "label", hu = "invalid-feedback", Bu = "valid-feedback", _u = "description", wu = "default", Cu = z({
  components: { BCol: Lt, BFormInvalidFeedback: Ea, BFormRow: aa, BFormText: Fa, BFormValidFeedback: La },
  props: {
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    contentCols: { type: [Boolean, String, Number], default: void 0 },
    contentColsLg: { type: [Boolean, String, Number], default: void 0 },
    contentColsMd: { type: [Boolean, String, Number], default: void 0 },
    contentColsSm: { type: [Boolean, String, Number], default: void 0 },
    contentColsXl: { type: [Boolean, String, Number], default: void 0 },
    description: { type: [String], default: void 0 },
    disabled: { type: Boolean, default: !1 },
    feedbackAriaLive: { type: String, default: "assertive" },
    id: { type: String, default: void 0 },
    invalidFeedback: { type: String, default: void 0 },
    label: { type: String, default: void 0 },
    labelAlign: { type: [Boolean, String, Number], default: void 0 },
    labelAlignLg: { type: [Boolean, String, Number], default: void 0 },
    labelAlignMd: { type: [Boolean, String, Number], default: void 0 },
    labelAlignSm: { type: [Boolean, String, Number], default: void 0 },
    labelAlignXl: { type: [Boolean, String, Number], default: void 0 },
    labelClass: { type: [Array, Object, String], default: void 0 },
    labelCols: { type: [Boolean, String, Number], default: void 0 },
    labelColsLg: { type: [Boolean, String, Number], default: void 0 },
    labelColsMd: { type: [Boolean, String, Number], default: void 0 },
    labelColsSm: { type: [Boolean, String, Number], default: void 0 },
    labelColsXl: { type: [Boolean, String, Number], default: void 0 },
    labelFor: { type: String, default: void 0 },
    labelSize: { type: String, default: void 0 },
    labelSrOnly: { type: Boolean, default: !1 },
    state: { type: Boolean, default: null },
    tooltip: { type: Boolean, default: !1 },
    validFeedback: { type: String, default: void 0 },
    validated: { type: Boolean, default: !1 },
    floating: { type: Boolean, default: !1 }
  },
  setup(a) {
    const e = ["xs", "sm", "md", "lg", "xl"], l = (y, h) => e.reduce((C, p) => {
      const B = $l(p === "xs" ? "" : p, `${h}Align`), g = y[B] || null;
      return g && (p === "xs" ? C.push(`text-${g}`) : C.push(`text-${p}-${g}`)), C;
    }, []), t = (y, h) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      e.reduce((C, p) => {
        const B = $l(p === "xs" ? "" : p, `${h}Cols`);
        let g = y[B];
        if (g = g === "" ? !0 : g || !1, typeof g != "boolean" && g !== "auto") {
          const S = Number.parseInt(g);
          g = Number.isNaN(S) ? 0 : S, g = g > 0 ? g : !1;
        }
        return g && (p === "xs" ? C[typeof g == "boolean" ? "col" : "cols"] = g : C[p || (typeof g == "boolean" ? "col" : "cols")] = g), C;
      }, {})
    ), s = F(null), i = (y, h = null) => {
      if (Wa && a.labelFor && s.value !== null) {
        const C = s.value.querySelector(`#${CSS.escape(a.labelFor)}`);
        if (C) {
          const p = "aria-describedby", B = (y || "").split(Qt), g = (h || "").split(Qt), S = (C.getAttribute(p) || "").split(Qt).filter((w) => !g.includes(w)).concat(B).filter((w, x, V) => V.indexOf(w) === x).filter((w) => w).join(" ").trim();
          S ? C.setAttribute(p, S) : C.removeAttribute(p);
        }
      }
    }, u = _(() => t(a, "content")), r = _(() => l(a, "label")), d = _(() => t(a, "label")), c = _(
      () => (
        // Determine if the form group will be rendered horizontal
        // based on the existence of 'content-col' or 'label-col' props
        Object.keys(u.value).length > 0 || Object.keys(d.value).length > 0
      )
    ), f = Ct(() => a.state), m = ma(
      () => a.ariaInvalid,
      () => a.state
    );
    return fe(
      () => null,
      (y, h) => {
        y !== h && i(y, h);
      }
    ), Ue(() => {
      Ie(() => {
        i(null);
      });
    }), {
      ariaDescribedby: null,
      computedAriaInvalid: m,
      contentColProps: u,
      isHorizontal: c,
      labelAlignClasses: r,
      labelColProps: d,
      onLegendClick: (y) => {
        if (a.labelFor || s.value === null)
          return;
        const { target: h } = y, C = h ? h.tagName : "";
        if (yu.indexOf(C) !== -1)
          return;
        const p = [...s.value.querySelectorAll(bu)].filter(zn), [B] = p;
        p.length === 1 && B instanceof HTMLElement && Ln(B);
      },
      stateClass: f
    };
  },
  render() {
    const a = this.$props, o = this.$slots, e = we(), l = !a.labelFor;
    let t = null;
    const s = Ft(gu, {}, o) || a.label, i = s ? we(void 0, "_BV_label_").value : null;
    if (s || this.isHorizontal) {
      const S = l ? "legend" : "label";
      if (a.labelSrOnly)
        s && (t = Pe(
          S,
          {
            class: "visually-hidden",
            id: i,
            for: a.labelFor || null
          },
          s
        )), this.isHorizontal ? t = Pe(Lt, this.labelColProps, { default: () => t }) : t = Pe("div", {}, [t]);
      else {
        const w = {
          onClick: l ? this.onLegendClick : null,
          ...this.isHorizontal ? this.labelColProps : {},
          tag: this.isHorizontal ? S : null,
          id: i,
          for: a.labelFor || null,
          tabIndex: l ? "-1" : null,
          class: [
            this.isHorizontal ? "col-form-label" : "form-label",
            {
              "bv-no-focus-ring": l,
              "col-form-label": this.isHorizontal || l,
              "pt-0": !this.isHorizontal && l,
              "d-block": !this.isHorizontal && !l,
              [`col-form-label-${a.labelSize}`]: !!a.labelSize
            },
            this.labelAlignClasses,
            a.labelClass
          ]
        };
        this.isHorizontal ? t = Pe(Lt, w, { default: () => s }) : t = Pe(S, w, s);
      }
    }
    let u = null;
    const r = Ft(hu, {}, o) || this.invalidFeedback, d = r ? we(void 0, "_BV_feedback_invalid_").value : void 0;
    r && (u = Pe(
      Ea,
      {
        ariaLive: a.feedbackAriaLive,
        id: d,
        state: a.state,
        tooltip: a.tooltip
      },
      { default: () => r }
    ));
    let c = null;
    const f = Ft(Bu, {}, o) || this.validFeedback, m = f ? we(void 0, "_BV_feedback_valid_").value : void 0;
    f && (c = Pe(
      La,
      {
        ariaLive: a.feedbackAriaLive,
        id: m,
        state: a.state,
        tooltip: a.tooltip
      },
      { default: () => f }
      // validFeedbackContent
    ));
    let v = null;
    const y = Ft(_u, {}, o) || this.description, h = y ? we(void 0, "_BV_description_").value : void 0;
    y && (v = Pe(
      Fa,
      {
        id: h
      },
      { default: () => y }
    ));
    const C = this.ariaDescribedby = [
      h,
      a.state === !1 ? d : null,
      a.state === !0 ? m : null
    ].filter((S) => S).join(" ") || null, p = [
      Ft(wu, { ariaDescribedby: C, descriptionId: h, id: e, labelId: i }, o) || "",
      u,
      c,
      v
    ];
    !this.isHorizontal && a.floating && p.push(t);
    let B = Pe(
      "div",
      {
        ref: "content",
        class: [
          {
            "form-floating": !this.isHorizontal && a.floating
          }
        ]
      },
      p
    );
    this.isHorizontal && (B = Pe(Lt, { ref: "content", ...this.contentColProps }, { default: () => p }));
    const g = {
      class: [
        this.stateClass,
        {
          "was-validated": a.validated
        }
      ],
      id: we(() => a.id).value,
      disabled: l ? a.disabled : null,
      role: l ? null : "group",
      "aria-invalid": this.computedAriaInvalid,
      // Only apply `aria-labelledby` if we are a horizontal fieldset
      // as the legend is no longer a direct child of fieldset
      "aria-labelledby": l && this.isHorizontal ? i : null
    };
    return this.isHorizontal && !l ? Pe(aa, g, { default: () => [t, B] }) : Pe(
      l ? "fieldset" : "div",
      g,
      this.isHorizontal && l ? [Pe(aa, null, { default: () => [t, B] })] : this.isHorizontal || !a.floating ? [t, B] : [B]
    );
  }
}), ku = ["id", "value", "name", "form", "type", "disabled", "placeholder", "required", "autocomplete", "readonly", "min", "max", "step", "list", "aria-required", "aria-invalid"], Ol = /* @__PURE__ */ z({
  __name: "BFormInput",
  props: /* @__PURE__ */ ye({
    max: { default: void 0 },
    min: { default: void 0 },
    step: { default: void 0 },
    type: { default: "text" },
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    autocomplete: { default: void 0 },
    autofocus: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    form: { default: void 0 },
    formatter: { type: Function, default: void 0 },
    id: { default: void 0 },
    lazyFormatter: { type: Boolean, default: !1 },
    list: { default: void 0 },
    modelValue: { default: "" },
    name: { default: void 0 },
    placeholder: { default: void 0 },
    plaintext: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    size: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    debounce: { default: 0 },
    debounceMaxWait: { default: NaN }
  }, {
    modelValue: {
      default: ""
    },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(a, { expose: o }) {
    const l = j(a, "BFormInput"), [t, s] = _e(a, "modelValue", {
      set: (p) => {
        if (p === null)
          return;
        let B = p;
        if (s.trim && (B = B.toString().trim()), (s.number || l.type === "number") && typeof B == "string" && B !== "") {
          const g = Number.parseFloat(B);
          B = Number.isNaN(g) ? B : g;
        }
        return B;
      }
    }), { input: i, computedId: u, computedAriaInvalid: r, onInput: d, onChange: c, onBlur: f, focus: m, blur: v } = Uo(l, t, s), y = Ct(() => l.state), h = F(!1), C = _(() => {
      const p = l.type === "range", B = l.type === "color";
      return [
        y.value,
        {
          "form-control-highlighted": h.value,
          "form-range": p,
          "form-control": B || !l.plaintext && !p,
          "form-control-color": B,
          "form-control-plaintext": l.plaintext && !p && !B,
          [`form-control-${l.size}`]: !!l.size
        }
      ];
    });
    return o({
      blur: v,
      element: i,
      focus: m
    }), (p, B) => (b(), O("input", {
      id: n(u),
      ref_key: "input",
      ref: i,
      value: n(t),
      class: D(C.value),
      name: n(l).name || void 0,
      form: n(l).form || void 0,
      type: n(l).type,
      disabled: n(l).disabled,
      placeholder: n(l).placeholder,
      required: n(l).required || void 0,
      autocomplete: n(l).autocomplete || void 0,
      readonly: n(l).readonly || n(l).plaintext,
      min: n(l).min,
      max: n(l).max,
      step: n(l).step,
      list: n(l).type !== "password" ? n(l).list : void 0,
      "aria-required": n(l).required || void 0,
      "aria-invalid": n(r),
      onInput: B[0] || (B[0] = (g) => n(d)(g)),
      onChange: B[1] || (B[1] = (g) => n(c)(g)),
      onBlur: B[2] || (B[2] = (g) => n(f)(g))
    }, null, 42, ku));
  }
}), Tu = ["id", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "value", "aria-required"], $u = ["for"], gn = /* @__PURE__ */ z({
  inheritAttrs: !1,
  __name: "BFormRadio",
  props: /* @__PURE__ */ ye({
    ariaLabel: { default: void 0 },
    ariaLabelledby: { default: void 0 },
    autofocus: { type: Boolean, default: !1 },
    button: { type: Boolean, default: !1 },
    buttonGroup: { type: Boolean, default: !1 },
    buttonVariant: { default: null },
    disabled: { type: Boolean, default: !1 },
    form: { default: void 0 },
    id: { default: void 0 },
    inline: { type: Boolean, default: !1 },
    modelValue: { type: [Boolean, String, Array, Object, Number, null] },
    name: { default: void 0 },
    plain: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    reverse: { type: Boolean, default: !1 },
    size: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    value: { type: [Boolean, String, Array, Object, Number, null], default: !0 }
  }, {
    modelValue: { type: [Boolean, String, Array, Object, Number, null], default: void 0 },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(a, { expose: o }) {
    const l = j(a, "BFormRadio"), t = Re(), s = _e(a, "modelValue"), i = we(() => l.id, "form-check"), u = Ve(Vo, null), r = F(null), { focused: d } = Fe(r, {
      initialValue: l.autofocus
    }), c = k(() => !Ae(t.default)), f = _({
      get: () => (u == null ? void 0 : u.modelValue.value) ?? s.value,
      set: (B) => {
        if (B !== void 0) {
          if (u !== null) {
            u.modelValue.value = B;
            return;
          }
          s.value = B;
        }
      }
    }), m = k(
      () => !!(l.name ?? (u == null ? void 0 : u.name.value)) && (l.required || (u == null ? void 0 : u.required.value))
    ), v = k(() => l.buttonGroup || ((u == null ? void 0 : u.buttons.value) ?? !1)), y = _(() => ({
      plain: l.plain || ((u == null ? void 0 : u.plain.value) ?? !1),
      button: l.button || ((u == null ? void 0 : u.buttons.value) ?? !1),
      inline: l.inline || ((u == null ? void 0 : u.inline.value) ?? !1),
      state: l.state || (u == null ? void 0 : u.state.value),
      reverse: l.reverse || ((u == null ? void 0 : u.reverse.value) ?? !1),
      size: l.size ?? (u == null ? void 0 : u.size.value) ?? "md",
      // This is where the true default is made
      buttonVariant: l.buttonVariant ?? (u == null ? void 0 : u.buttonVariant.value) ?? "secondary",
      // This is where the true default is made
      hasDefaultSlot: c.value
    })), h = Do(y), C = jo(y), p = Wo(y);
    return o({
      blur: () => {
        d.value = !1;
      },
      element: r,
      focus: () => {
        d.value = !0;
      }
    }), (B, g) => (b(), N(Gt, {
      skip: v.value,
      class: D(n(h))
    }, {
      default: I(() => {
        var S, w, x;
        return [
          ct(Q("input", K({ id: n(i) }, B.$attrs, {
            ref_key: "input",
            ref: r,
            "onUpdate:modelValue": g[0] || (g[0] = (V) => f.value = V),
            class: n(C),
            type: "radio",
            disabled: n(l).disabled || ((S = n(u)) == null ? void 0 : S.disabled.value),
            required: m.value || void 0,
            name: n(l).name || ((w = n(u)) == null ? void 0 : w.name.value),
            form: n(l).form || ((x = n(u)) == null ? void 0 : x.form.value),
            "aria-label": n(l).ariaLabel,
            "aria-labelledby": n(l).ariaLabelledby,
            value: n(l).value,
            "aria-required": m.value || void 0
          }), null, 16, Tu), [
            [In, f.value]
          ]),
          c.value || n(l).plain === !1 ? (b(), O("label", {
            key: 0,
            for: n(i),
            class: D(n(p))
          }, [
            $(B.$slots, "default")
          ], 10, $u)) : te("", !0)
        ];
      }),
      _: 3
    }, 8, ["skip", "class"]));
  }
}), xu = ["id"], Su = ["innerHTML"], Vu = /* @__PURE__ */ z({
  __name: "BFormRadioGroup",
  props: /* @__PURE__ */ ye({
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    autofocus: { type: Boolean, default: !1 },
    buttonVariant: { default: "secondary" },
    buttons: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    disabledField: { default: "disabled" },
    form: { default: void 0 },
    htmlField: { default: "html" },
    id: { default: void 0 },
    modelValue: { type: [Boolean, String, Array, Object, Number, null] },
    name: { default: void 0 },
    options: { default: () => [] },
    plain: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    reverse: { type: Boolean, default: !1 },
    size: { default: "md" },
    stacked: { type: Boolean, default: !1 },
    state: { type: [Boolean, null], default: null },
    textField: { default: "text" },
    validated: { type: Boolean, default: !1 },
    valueField: { default: "value" }
  }, {
    modelValue: { type: [Boolean, String, Array, Object, Number, null], default: null },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(a, { expose: o }) {
    const l = j(a, "BFormRadioGroup"), t = _e(a, "modelValue"), s = we(() => l.id, "radio"), i = we(() => l.name, "checkbox"), u = F(null), { focused: r } = Fe(u, {
      initialValue: l.autofocus
    });
    Xe(Vo, {
      modelValue: t,
      buttonVariant: k(() => l.buttonVariant),
      form: k(() => l.form),
      name: i,
      buttons: k(() => l.buttons),
      state: k(() => l.state),
      plain: k(() => l.plain),
      size: k(() => l.size),
      inline: k(() => !l.stacked),
      reverse: k(() => l.reverse),
      required: k(() => l.required),
      disabled: k(() => l.disabled)
    });
    const d = _(
      () => l.options.map(
        (v, y) => typeof v == "string" || typeof v == "number" ? {
          value: v,
          disabled: l.disabled,
          text: v.toString(),
          html: void 0,
          self: Symbol(`radioGroupOptionItem${y}`)
        } : {
          value: v[l.valueField],
          disabled: v[l.disabledField],
          ...v.props ? v.props : {},
          text: v[l.textField],
          html: v[l.htmlField],
          self: Symbol(`radioGroupOptionItem${y}`)
        }
      )
    ), c = _(() => ({
      required: l.required,
      ariaInvalid: l.ariaInvalid,
      state: l.state,
      validated: l.validated,
      buttons: l.buttons,
      stacked: l.stacked,
      size: l.size
    })), f = qo(c), m = Go(c);
    return o({
      blur: () => {
        r.value = !1;
      },
      focus: () => {
        r.value = !0;
      }
    }), (v, y) => (b(), O("div", K(n(f), {
      id: n(s),
      ref_key: "element",
      ref: u,
      role: "radiogroup",
      class: [n(m), "bv-no-focus-ring"],
      tabindex: "-1"
    }), [
      $(v.$slots, "first"),
      (b(!0), O(pe, null, ke(d.value, (h) => (b(), N(gn, {
        key: h.self,
        disabled: h.disabled,
        value: h.value
      }, {
        default: I(() => [
          h.html ? (b(), O("span", {
            key: 0,
            innerHTML: h.html
          }, null, 8, Su)) : (b(), O(pe, { key: 1 }, [
            se(J(h.text), 1)
          ], 64))
        ]),
        _: 2
      }, 1032, ["disabled", "value"]))), 128)),
      $(v.$slots, "default")
    ], 16, xu));
  }
}), Au = ["value", "disabled"], ul = /* @__PURE__ */ z({
  __name: "BFormSelectOption",
  props: {
    disabled: { type: Boolean, default: !1 },
    value: { default: void 0 }
  },
  setup(a) {
    const e = j(a, "BFormSelectOption");
    return (l, t) => (b(), O("option", {
      value: n(e).value,
      disabled: n(e).disabled
    }, [
      $(l.$slots, "default")
    ], 8, Au));
  }
}), Ou = ["label"], Pu = ["innerHTML"], hn = /* @__PURE__ */ z({
  __name: "BFormSelectOptionGroup",
  props: {
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    label: { default: void 0 },
    options: { default: () => [] },
    textField: { default: "text" },
    valueField: { default: "value" }
  },
  setup(a) {
    const e = j(a, "BFormSelectOptionGroup"), { normalizedOptions: l } = Xo(() => e.options, e), t = _(() => l.value);
    return (s, i) => (b(), O("optgroup", {
      label: n(e).label
    }, [
      $(s.$slots, "first"),
      (b(!0), O(pe, null, ke(t.value, (u, r) => (b(), N(ul, K({
        key: r,
        disabled: u.disabled,
        value: u.value,
        ref_for: !0
      }, s.$attrs), {
        default: I(() => [
          u.html ? (b(), O("span", {
            key: 0,
            innerHTML: u.html
          }, null, 8, Pu)) : (b(), O(pe, { key: 1 }, [
            se(J(u.text), 1)
          ], 64))
        ]),
        _: 2
      }, 1040, ["disabled", "value"]))), 128)),
      $(s.$slots, "default")
    ], 8, Ou));
  }
}), Nu = ["id", "name", "form", "multiple", "size", "disabled", "required", "aria-required", "aria-invalid"], Iu = ["innerHTML"], Eu = /* @__PURE__ */ z({
  __name: "BFormSelect",
  props: /* @__PURE__ */ ye({
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    autofocus: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    disabledField: { default: "disabled" },
    form: { default: void 0 },
    htmlField: { default: "html" },
    id: { default: void 0 },
    labelField: { default: "label" },
    modelValue: { type: [Boolean, String, Array, Object, Number, null] },
    multiple: { type: Boolean, default: !1 },
    name: { default: void 0 },
    options: { default: () => [] },
    optionsField: { default: "options" },
    plain: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    selectSize: { default: 0 },
    size: { default: "md" },
    state: { type: [Boolean, null], default: null },
    textField: { default: "text" },
    valueField: { default: "value" }
  }, {
    modelValue: {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      default: ""
    },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(a, { expose: o }) {
    const l = j(a, "BFormSelect"), t = _e(a, "modelValue"), s = we(() => l.id, "input"), i = he(() => l.selectSize), u = Ct(() => l.state), r = F(null), { focused: d } = Fe(r, {
      initialValue: l.autofocus
    }), c = _(() => [
      u.value,
      {
        "form-control": l.plain,
        [`form-control-${l.size}`]: l.size !== "md" && l.plain,
        "form-select": !l.plain,
        [`form-select-${l.size}`]: l.size !== "md" && !l.plain
      }
    ]), f = k(
      () => i.value || l.plain ? i.value : void 0
    ), m = ma(
      () => l.ariaInvalid,
      () => l.state
    ), { normalizedOptions: v, isComplex: y } = Xo(() => l.options, l), h = _(
      () => v.value
    ), C = _({
      get: () => t.value,
      set: (p) => {
        t.value = p;
      }
    });
    return o({
      blur: () => {
        d.value = !1;
      },
      element: r,
      focus: () => {
        d.value = !0;
      }
    }), (p, B) => ct((b(), O("select", {
      id: n(s),
      ref_key: "input",
      ref: r,
      "onUpdate:modelValue": B[0] || (B[0] = (g) => C.value = g),
      class: D(c.value),
      name: n(l).name,
      form: n(l).form || void 0,
      multiple: n(l).multiple || void 0,
      size: f.value,
      disabled: n(l).disabled,
      required: n(l).required || void 0,
      "aria-required": n(l).required || void 0,
      "aria-invalid": n(m)
    }, [
      $(p.$slots, "first"),
      (b(!0), O(pe, null, ke(h.value, (g, S) => (b(), O(pe, { key: S }, [
        n(y)(g) ? (b(), N(hn, {
          key: 0,
          label: g.label,
          options: g.options,
          "value-field": n(l).valueField,
          "text-field": n(l).textField,
          "html-field": n(l).htmlField,
          "disabled-field": n(l).disabledField
        }, null, 8, ["label", "options", "value-field", "text-field", "html-field", "disabled-field"])) : (b(), N(ul, {
          key: 1,
          value: g.value,
          disabled: g.disabled
        }, {
          default: I(() => [
            g.html ? (b(), O("span", {
              key: 0,
              innerHTML: g.html
            }, null, 8, Iu)) : (b(), O(pe, { key: 1 }, [
              se(J(g.text), 1)
            ], 64))
          ]),
          _: 2
        }, 1032, ["value", "disabled"]))
      ], 64))), 128)),
      $(p.$slots, "default")
    ], 10, Nu)), [
      [En, C.value]
    ]);
  }
}), Ta = "ArrowDown", Pl = "End", Nl = "Home", Il = "PageDown", El = "PageUp", $a = "ArrowUp", Fu = ["lang", "tabindex", "title"], Lu = ["name", "form", "value"], zu = ["id", "dir", "tabindex", "aria-label", "aria-invalid", "aria-required", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext"], Me = {
  min: 1,
  max: 100,
  step: 1,
  repeatDelay: 500,
  repeatInterval: 100,
  repeatThreshold: 10,
  repeatMultiplier: 4
}, Ru = /* @__PURE__ */ z({
  __name: "BFormSpinbutton",
  props: /* @__PURE__ */ ye({
    ariaControls: { default: void 0 },
    ariaLabel: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    form: { default: void 0 },
    formatterFn: { type: Function, default: void 0 },
    id: { default: void 0 },
    inline: { type: Boolean, default: !1 },
    labelDecrement: { default: "Decrement" },
    labelIncrement: { default: "Increment" },
    locale: { default: void 0 },
    max: { default: Me.max },
    min: { default: Me.min },
    modelValue: {},
    name: { default: void 0 },
    placeholder: { default: void 0 },
    readonly: { type: Boolean, default: !1 },
    repeatDelay: { default: Me.repeatDelay },
    repeatInterval: { default: Me.repeatInterval },
    repeatStepMultiplier: { default: Me.repeatMultiplier },
    repeatThreshold: { default: Me.repeatThreshold },
    required: { type: Boolean, default: !1 },
    size: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    step: { default: Me.step },
    vertical: { type: Boolean, default: !1 },
    wrap: { type: Boolean, default: !1 }
  }, {
    modelValue: {
      default: null
    },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ ye(["change"], ["update:modelValue"]),
  setup(a, { emit: o }) {
    const e = [$a, Ta, Nl, Pl, El, Il], t = j(a, "BFormSpinbutton"), s = o, i = _e(a, "modelValue"), u = F(null), { focused: r } = Fe(u), d = we(() => t.id, "spinbutton"), c = _(() => ({
      disabled: t.disabled,
      readonly: t.readonly,
      focus: r.value,
      "d-inline-flex": t.inline || t.vertical,
      "d-flex": !t.inline && !t.vertical,
      "align-items-stretch": !t.vertical,
      "flex-column": t.vertical,
      [`form-control-${t.size}`]: t.size !== void 0
    })), f = _(() => ({
      "d-flex": t.vertical,
      "align-self-center": !t.vertical,
      "align-items-center": t.vertical,
      "border-top": t.vertical,
      "border-bottom": t.vertical,
      "border-start": !t.vertical,
      "border-end": !t.vertical
    }));
    let m, v, y = !1;
    const h = he(() => t.step), C = k(
      () => Number.isNaN(h.value) ? Me.step : h.value
    ), p = he(() => t.min), B = k(
      () => Number.isNaN(p.value) ? Me.min : p.value
    ), g = he(() => t.max), S = k(() => {
      const L = C.value, X = B.value;
      return Math.floor((g.value - X) / L) * L + X;
    }), w = he(() => t.repeatDelay, {
      nanToZero: !0,
      method: "parseInt"
    }), x = k(
      () => w.value > 0 ? w.value : Me.repeatDelay
    ), V = he(() => t.repeatInterval, {
      nanToZero: !0,
      method: "parseInt"
    }), G = k(
      () => V.value > 0 ? V.value : Me.repeatInterval
    ), W = he(() => t.repeatThreshold, {
      nanToZero: !0,
      method: "parseInt"
    }), P = k(
      () => Math.max(
        Number.isNaN(W.value) ? Me.repeatThreshold : W.value,
        1
      )
    ), Y = he(() => t.repeatStepMultiplier, {
      nanToZero: !0,
      method: "parseInt"
    }), ae = k(
      () => Math.max(
        Number.isNaN(Y.value) ? Me.repeatMultiplier : Y.value,
        1
      )
    ), ne = k(() => {
      const L = C.value;
      return Math.floor(L) === L ? 0 : (L.toString().split(".")[1] || "").length;
    }), U = k(() => Math.pow(10, ne.value || 0)), T = k(
      () => i.value === null ? "" : i.value.toFixed(ne.value)
    ), { isRtl: A, locale: E } = jr(), M = _(() => {
      const X = [(t.locale ?? (E == null ? void 0 : E.value)) || "locale"];
      return new Intl.NumberFormat(X).resolvedOptions().locale;
    }), Z = () => new Intl.NumberFormat(M.value, {
      style: "decimal",
      useGrouping: !1,
      minimumIntegerDigits: 1,
      minimumFractionDigits: ne.value,
      maximumFractionDigits: ne.value,
      notation: "standard"
    }).format, R = k(() => t.formatterFn ?? Z()), H = (L) => {
      let { value: X } = i;
      if (!t.disabled && X !== null) {
        const ge = C.value * L, me = B.value, Oe = S.value, xe = U.value, { wrap: Se } = t;
        X = Math.round((X - me) / ge) * ge + me + ge, X = Math.round(X * xe) / xe, i.value = X > Oe ? Se ? me : Oe : X < me ? Se ? Oe : me : X;
      }
    }, ce = (L = 1) => {
      if (i.value === null) {
        i.value = B.value;
        return;
      }
      H(1 * L);
    }, le = (L = 1) => {
      if (i.value === null) {
        i.value = t.wrap ? S.value : B.value;
        return;
      }
      H(-1 * L);
    }, q = (L) => {
      L.preventDefault(), L.stopImmediatePropagation();
    };
    De(
      e,
      (L) => {
        const { code: X, altKey: ge, ctrlKey: me, metaKey: Oe } = L;
        if (!(t.disabled || t.readonly || ge || me || Oe) && (q(L), !y)) {
          if (ie(), [$a, Ta].includes(X)) {
            if (y = !0, X === $a) {
              oe(L, ce);
              return;
            }
            X === Ta && oe(L, le);
            return;
          }
          if (X === El) {
            ce(ae.value);
            return;
          }
          if (X === Il) {
            le(ae.value);
            return;
          }
          if (X === Nl) {
            i.value = B.value;
            return;
          }
          X === Pl && (i.value = S.value);
        }
      },
      { target: u, eventName: "keydown" }
    ), De(
      e,
      (L) => {
        const { altKey: X, ctrlKey: ge, metaKey: me } = L;
        t.disabled || t.readonly || X || ge || me || (q(L), ie(), y = !1, s("change", i.value));
      },
      { target: u, eventName: "keyup" }
    );
    const oe = (L, X) => {
      const { type: ge } = L || {};
      if (!t.disabled && !t.readonly) {
        if (de(L) && ge === "mousedown" && L.button)
          return;
        ie(), X(1);
        const me = P.value, Oe = ae.value, xe = x.value, Se = G.value;
        m = setTimeout(() => {
          let et = 0;
          v = setInterval(() => {
            X(et < me ? 1 : Oe), et++;
          }, Se);
        }, xe);
      }
    }, de = (L) => L.type === "mouseup" || L.type === "mousedown", ee = (L) => {
      de(L) && L.type === "mouseup" && L.button || (q(L), ie(), re(!1), s("change", i.value));
    }, re = (L) => {
      try {
        fl(L, [document.body, "mouseup", ee, !1]), fl(L, [document.body, "touchend", ee, !1]);
      } catch {
      }
    }, ie = () => {
      clearTimeout(m), clearInterval(v), m = void 0, v = void 0;
    }, ve = _(() => {
      const L = {
        svg: {
          xmlns: "http://www.w3.org/2000/svg",
          width: "16",
          height: "16",
          fill: "currentColor",
          class: "bi bi-plus",
          viewBox: "0 0 16 16"
        },
        path: {
          d: "M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"
        }
      }, X = {
        svg: {
          xmlns: "http://www.w3.org/2000/svg",
          width: "16",
          height: "16",
          fill: "currentColor",
          class: "bi bi-dash",
          viewBox: "0 0 16 16"
        },
        path: { d: "M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z" }
      }, ge = {
        class: [{ "py-0": !t.vertical }, "btn", "btn-sm", "border-0", "rounded-0"],
        tabindex: "-1",
        type: "button",
        disabled: t.disabled || t.readonly,
        "aria-disabled": t.disabled || t.readonly ? !0 : void 0,
        "aria-controls": d.value
      }, me = {
        "aria-hidden": !0,
        scale: r.value ? 1.5 : 1.25
      }, Oe = (et, xn) => {
        !t.disabled && !t.readonly && (q(et), re(!0), r.value = !0, oe(et, xn));
      }, xe = {
        button: {
          ...ge,
          "aria-label": t.labelIncrement || void 0,
          "aria-keyshortcuts": "ArrowUp"
        },
        svg: {
          ...me,
          ...L.svg
        },
        path: {
          ...L.path
        },
        slot: {
          name: "increment"
        },
        handler: (et) => Oe(et, ce)
      }, Se = {
        button: {
          ...ge,
          "aria-label": t.labelDecrement || void 0,
          "aria-keyshortcuts": "ArrowDown"
        },
        svg: {
          ...me,
          ...X.svg
        },
        path: {
          ...X.path
        },
        slot: {
          name: "decrement"
        },
        handler: (et) => Oe(et, le)
      };
      return {
        top: {
          ...t.vertical ? xe : Se
        },
        bottom: {
          ...t.vertical ? Se : xe
        }
      };
    });
    return (L, X) => (b(), O("div", {
      ref_key: "element",
      ref: u,
      class: D(["b-form-spinbutton form-control", c.value]),
      role: "group",
      lang: M.value,
      tabindex: n(t).disabled ? void 0 : "-1",
      title: n(t).ariaLabel,
      onClick: X[4] || (X[4] = (ge) => r.value = !0)
    }, [
      $(L.$slots, ve.value.top.slot.name, { hasFocus: n(r) }, () => [
        Q("button", K(ve.value.top.button, {
          onMousedown: X[0] || (X[0] = //@ts-ignore
          (...ge) => ve.value.top.handler && ve.value.top.handler(...ge)),
          onTouchstart: X[1] || (X[1] = //@ts-ignore
          (...ge) => ve.value.top.handler && ve.value.top.handler(...ge))
        }), [
          (b(), O("svg", Be(Ce(ve.value.top.svg)), [
            Q("path", Be(Ce(ve.value.top.path)), null, 16)
          ], 16))
        ], 16)
      ]),
      n(t).name && !n(t).disabled ? (b(), O("input", {
        key: "hidden",
        type: "hidden",
        name: n(t).name,
        form: n(t).form,
        value: T.value
      }, null, 8, Lu)) : te("", !0),
      Q("output", {
        id: n(d),
        key: "output",
        class: D(["flex-grow-1", f.value]),
        dir: n(A) ?? !1 ? "rtl" : "ltr",
        tabindex: n(t).disabled ? void 0 : "0",
        role: "spinbutton",
        "aria-live": "off",
        "aria-label": n(t).ariaLabel || void 0,
        "aria-invalid": n(t).state === !1 || !i.value !== null && n(t).required ? !0 : void 0,
        "aria-required": n(t).required ? !0 : void 0,
        "aria-valuemin": B.value,
        "aria-valuemax": S.value,
        "aria-valuenow": i.value !== null ? i.value : void 0,
        "aria-valuetext": i.value !== null ? R.value(i.value) : void 0
      }, [
        Q("bdi", null, J((i.value !== null ? R.value(i.value) : n(t).placeholder) || ""), 1)
      ], 10, zu),
      $(L.$slots, ve.value.bottom.slot.name, { hasFocus: n(r) }, () => [
        Q("button", K(ve.value.bottom.button, {
          onMousedown: X[2] || (X[2] = //@ts-ignore
          (...ge) => ve.value.bottom.handler && ve.value.bottom.handler(...ge)),
          onTouchstart: X[3] || (X[3] = //@ts-ignore
          (...ge) => ve.value.bottom.handler && ve.value.bottom.handler(...ge))
        }), [
          (b(), O("svg", Be(Ce(ve.value.bottom.svg)), [
            Q("path", Be(Ce(ve.value.bottom.path)), null, 16)
          ], 16))
        ], 16)
      ])
    ], 10, Fu));
  }
}), Hu = ["id"], Bn = /* @__PURE__ */ z({
  __name: "BFormTag",
  props: {
    disabled: { type: Boolean, default: !1 },
    id: { default: void 0 },
    noRemove: { type: Boolean, default: !1 },
    pill: { type: Boolean, default: !1 },
    removeLabel: { default: "Remove tag" },
    tag: { default: "span" },
    title: { default: void 0 },
    variant: { default: "secondary" }
  },
  emits: ["remove"],
  setup(a, { emit: o }) {
    const l = j(a, "BFormTag"), t = o, s = Re(), i = we(() => l.id), u = _(
      () => {
        var c;
        return ((((c = s.default) == null ? void 0 : c.call(s, {})[0].children) ?? "").toString() || l.title) ?? "";
      }
    ), r = k(() => `${i.value}taglabel__`), d = _(() => ({
      [`text-bg-${l.variant}`]: l.variant !== null,
      "rounded-pill": l.pill,
      disabled: l.disabled
    }));
    return (c, f) => (b(), N(ue(n(l).tag), {
      id: n(i),
      title: u.value,
      class: D(["badge b-form-tag d-inline-flex align-items-center mw-100", d.value]),
      "aria-labelledby": r.value
    }, {
      default: I(() => [
        Q("span", {
          id: r.value,
          class: "b-form-tag-content flex-grow-1 text-truncate"
        }, [
          $(c.$slots, "default", {}, () => [
            se(J(u.value), 1)
          ])
        ], 8, Hu),
        !n(l).disabled && !n(l).noRemove ? (b(), N(Et, {
          key: 0,
          "aria-keyshortcuts": "Delete",
          "aria-label": n(l).removeLabel,
          class: "b-form-tag-remove",
          "aria-describedby": r.value,
          "aria-controls": n(l).id,
          onClick: f[0] || (f[0] = (m) => t("remove", u.value))
        }, null, 8, ["aria-label", "aria-describedby", "aria-controls"])) : te("", !0)
      ]),
      _: 3
    }, 8, ["id", "title", "class", "aria-labelledby"]));
  }
}), Mu = ["id"], Du = ["id", "for", "aria-live"], ju = ["id", "aria-live"], Wu = ["id"], qu = ["aria-controls"], Gu = {
  role: "group",
  class: "d-flex"
}, Uu = ["id", "disabled", "value", "type", "placeholder", "form", "required", "aria-required"], Xu = ["disabled"], Ku = {
  "aria-live": "polite",
  "aria-atomic": "true"
}, Yu = {
  key: 0,
  class: "d-block invalid-feedback"
}, Zu = {
  key: 1,
  class: "form-text text-body-secondary"
}, Ju = {
  key: 2,
  class: "form-text text-body-secondary"
}, Qu = ["name", "value"], ed = /* @__PURE__ */ z({
  __name: "BFormTags",
  props: /* @__PURE__ */ ye({
    addButtonText: { default: "Add" },
    addButtonVariant: { default: "outline-secondary" },
    addOnChange: { type: Boolean, default: !1 },
    autofocus: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    duplicateTagText: { default: "Duplicate tag(s)" },
    form: { default: void 0 },
    inputAttrs: { default: void 0 },
    inputClass: { default: void 0 },
    inputId: { default: void 0 },
    inputType: { default: "text" },
    invalidTagText: { default: "Invalid tag(s)" },
    limit: { default: void 0 },
    limitTagsText: { default: "Tag limit reached" },
    modelValue: {},
    name: { default: void 0 },
    noAddOnEnter: { type: Boolean, default: !1 },
    noOuterFocus: { type: Boolean, default: !1 },
    noTagRemove: { type: Boolean, default: !1 },
    placeholder: { default: "Add tag..." },
    removeOnDelete: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    separator: { default: void 0 },
    size: { default: "md" },
    state: { type: [Boolean, null], default: null },
    tagClass: { default: void 0 },
    tagPills: { type: Boolean, default: !1 },
    tagRemoveLabel: { default: void 0 },
    tagRemovedLabel: { default: "Tag removed" },
    tagValidator: { type: Function, default: () => !0 },
    tagVariant: { default: "secondary" }
  }, {
    modelValue: {
      default: () => []
    },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ ye(["blur", "focus", "focusin", "focusout", "tag-state"], ["update:modelValue"]),
  setup(a, { expose: o, emit: e }) {
    const t = j(a, "BFormTags"), s = e, i = _e(a, "modelValue"), u = we(), r = he(() => t.limit ?? NaN), d = Ct(() => t.state), c = F(null), { focused: f } = Fe(c, {
      initialValue: t.autofocus
    }), m = k(() => t.inputId || `${u.value}input__`), v = F([...i.value]), y = F(""), h = F(i.value.length > 0), C = F(""), p = F([]), B = F([]), g = F([]);
    Pa(i, v, {
      direction: "ltr",
      transform: {
        ltr: (R) => [...R]
      }
    });
    const S = _(() => [
      d.value,
      {
        [`form-control-${t.size}`]: t.size !== "md",
        disabled: t.disabled,
        focus: f.value
      }
    ]), w = _(() => v.value.includes(y.value)), x = _(
      () => y.value === "" ? !1 : !t.tagValidator(y.value)
    ), V = k(() => v.value.length === r.value), G = k(() => !x.value && !w.value), W = _(() => ({
      addButtonText: t.addButtonText,
      addButtonVariant: t.addButtonVariant,
      addTag: M,
      disableAddButton: G.value,
      disabled: t.disabled,
      duplicateTagText: t.duplicateTagText,
      duplicateTags: g.value,
      form: t.form,
      inputAttrs: {
        ...t.inputAttrs,
        disabled: t.disabled,
        form: t.form,
        id: m,
        value: y
      },
      inputHandlers: {
        input: ne,
        keydown: T,
        change: U
      },
      inputId: m,
      inputType: t.inputType,
      invalidTagText: t.invalidTagText,
      invalidTags: B.value,
      isDuplicate: w.value,
      isInvalid: x.value,
      isLimitReached: V.value,
      limitTagsText: t.limitTagsText,
      limit: r.value,
      noTagRemove: t.noTagRemove,
      placeholder: t.placeholder,
      removeTag: Z,
      required: t.required,
      separator: t.separator,
      size: t.size,
      state: t.state,
      tagClass: t.tagClass,
      tagPills: t.tagPills,
      tagRemoveLabel: t.tagRemoveLabel,
      tagVariant: t.tagVariant,
      tags: v.value
    })), P = (R) => {
      if (t.disabled) {
        R.target.blur();
        return;
      }
      s("focusin", R);
    }, Y = (R) => {
      t.disabled || t.noOuterFocus || (f.value = !0, s("focus", R));
    }, ae = (R) => {
      f.value = !1, s("blur", R);
    }, ne = (R) => {
      var ce, le;
      const H = typeof R == "string" ? R : R.target.value;
      if (h.value = !1, (ce = t.separator) != null && ce.includes(H.charAt(0)) && H.length > 0) {
        c.value && (c.value.value = "");
        return;
      }
      if (y.value = H, (le = t.separator) != null && le.includes(H.charAt(H.length - 1))) {
        M(H.slice(0, H.length - 1));
        return;
      }
      p.value = t.tagValidator(H) && !w.value ? [H] : [], B.value = t.tagValidator(H) ? [] : [H], g.value = w.value ? [H] : [], s("tag-state", p.value, B.value, g.value);
    }, U = (R) => {
      t.addOnChange && (ne(R), w.value || M(y.value));
    }, T = (R) => {
      if (R.key === "Enter" && !t.noAddOnEnter) {
        M(y.value);
        return;
      }
      (R.key === "Backspace" || R.key === "Delete") && t.removeOnDelete && y.value === "" && h.value && v.value.length > 0 ? Z(v.value[v.value.length - 1]) : h.value = !0;
    };
    De(T, { target: c });
    const A = _(() => {
      if (t.separator)
        return typeof t.separator == "string" ? t.separator : t.separator.join("");
    }), E = _(() => {
      if (A.value)
        return new RegExp(`[${Ar(A.value)}]+`);
    }), M = (R) => {
      R = (R ?? y.value).trim();
      const H = E.value ? R.split(E.value).map((q) => q.trim()) : [R], ce = [];
      for (const q of H)
        if (!(q === "" || w.value || !t.tagValidator(q))) {
          if (r.value && V.value)
            break;
          ce.push(q);
        }
      const le = [...i.value, ...ce];
      y.value = "", h.value = !0, i.value = le, f.value = !0;
    }, Z = (R) => {
      const H = v.value.indexOf((R == null ? void 0 : R.toString()) ?? "");
      H !== -1 && (C.value = v.value.splice(H, 1).toString(), i.value = v.value);
    };
    return o({
      blur: () => {
        f.value = !1;
      },
      element: c,
      focus: () => {
        f.value = !0;
      }
    }), (R, H) => (b(), O("div", {
      id: n(u),
      class: D(["b-form-tags form-control h-auto", S.value]),
      role: "group",
      tabindex: "-1",
      onFocusin: P,
      onFocusout: H[1] || (H[1] = (ce) => s("focusout", ce))
    }, [
      Q("output", {
        id: `${n(u)}selected_tags__`,
        class: "visually-hidden",
        for: m.value,
        "aria-live": n(f) ? "polite" : "off",
        "aria-atomic": "true",
        "aria-relevant": "additions text"
      }, J(v.value.join(", ")), 9, Du),
      Q("div", {
        id: `${n(u)}removed_tags__`,
        role: "status",
        "aria-live": n(f) ? "assertive" : "off",
        "aria-atomic": "true",
        class: "visually-hidden"
      }, " (" + J(n(t).tagRemovedLabel) + ") " + J(C.value), 9, ju),
      $(R.$slots, "default", Be(Ce(W.value)), () => [
        Q("ul", {
          id: `${n(u)}tag_list__`,
          class: "b-form-tags-list list-unstyled mb-0 d-flex flex-wrap align-items-center"
        }, [
          (b(!0), O(pe, null, ke(v.value, (ce, le) => $(R.$slots, "tag", {
            key: le,
            tag: ce,
            tagClass: n(t).tagClass,
            tagVariant: n(t).tagVariant,
            tagPills: n(t).tagPills,
            removeTag: Z
          }, () => [
            (b(), N(Bn, {
              key: ce,
              class: D(n(t).tagClass),
              tag: "li",
              variant: n(t).tagVariant,
              pill: n(t).tagPills,
              onRemove: Z
            }, {
              default: I(() => [
                se(J(ce), 1)
              ]),
              _: 2
            }, 1032, ["class", "variant", "pill"]))
          ])), 128)),
          Q("li", {
            role: "none",
            "aria-live": "off",
            class: "b-from-tags-field flex-grow-1",
            "aria-controls": `${n(u)}tag_list__`
          }, [
            Q("div", Gu, [
              Q("input", K({
                id: m.value,
                ref_key: "input",
                ref: c,
                disabled: n(t).disabled,
                value: y.value,
                type: n(t).inputType,
                placeholder: n(t).placeholder,
                class: "b-form-tags-input w-100 flex-grow-1 p-0 m-0 bg-transparent border-0",
                style: { outline: "currentcolor none 0px", "min-width": "5rem" }
              }, n(t).inputAttrs, {
                form: n(t).form,
                required: n(t).required || void 0,
                "aria-required": n(t).required || void 0,
                onInput: ne,
                onChange: U,
                onFocus: Y,
                onBlur: ae
              }), null, 16, Uu),
              G.value ? (b(), O("button", {
                key: 0,
                type: "button",
                class: D(["btn b-form-tags-button py-0", [
                  R.inputClass,
                  {
                    [`btn-${n(t).addButtonVariant}`]: n(t).addButtonVariant !== null,
                    "disabled invisible": y.value.length === 0
                  }
                ]]),
                style: { "font-size": "90%" },
                disabled: n(t).disabled || y.value.length === 0 || V.value,
                onClick: H[0] || (H[0] = (ce) => M(y.value))
              }, [
                $(R.$slots, "add-button-text", {}, () => [
                  se(J(n(t).addButtonText), 1)
                ])
              ], 10, Xu)) : te("", !0)
            ])
          ], 8, qu)
        ], 8, Wu),
        Q("div", Ku, [
          x.value ? (b(), O("div", Yu, J(n(t).invalidTagText) + ": " + J(y.value), 1)) : te("", !0),
          w.value ? (b(), O("small", Zu, J(n(t).duplicateTagText) + ": " + J(y.value), 1)) : te("", !0),
          v.value.length === n(t).limit ? (b(), O("small", Ju, J(n(t).limitTagsText), 1)) : te("", !0)
        ])
      ]),
      n(t).name ? (b(!0), O(pe, { key: 0 }, ke(v.value, (ce, le) => (b(), O("input", {
        key: le,
        type: "hidden",
        name: n(t).name,
        value: ce
      }, null, 8, Qu))), 128)) : te("", !0)
    ], 42, Mu));
  }
}), td = ["id", "name", "form", "value", "disabled", "placeholder", "required", "autocomplete", "readonly", "aria-required", "aria-invalid", "rows", "wrap"], ad = /* @__PURE__ */ z({
  __name: "BFormTextarea",
  props: /* @__PURE__ */ ye({
    noResize: { type: Boolean, default: !1 },
    rows: { default: 2 },
    wrap: { default: "soft" },
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    autocomplete: { default: void 0 },
    autofocus: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    form: { default: void 0 },
    formatter: { type: Function, default: void 0 },
    id: { default: void 0 },
    lazyFormatter: { type: Boolean, default: !1 },
    list: { default: void 0 },
    modelValue: { default: "" },
    name: { default: void 0 },
    placeholder: { default: void 0 },
    plaintext: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    size: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    debounce: { default: 0 },
    debounceMaxWait: { default: NaN }
  }, {
    modelValue: {
      default: ""
    },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(a, { expose: o }) {
    const l = j(a, "BFormTextarea"), [t, s] = _e(a, "modelValue", {
      set: (p) => {
        if (p === null)
          return;
        let B = p;
        if (s.trim && (B = B.toString().trim()), s.number && typeof B == "string" && B !== "") {
          const g = Number.parseFloat(B);
          B = Number.isNaN(g) ? B : g;
        }
        return B;
      }
    }), { input: i, computedId: u, computedAriaInvalid: r, onInput: d, onChange: c, onBlur: f, focus: m, blur: v } = Uo(l, t, s), y = Ct(() => l.state), h = _(() => [
      y.value,
      l.plaintext ? "form-control-plaintext" : "form-control",
      {
        [`form-control-${l.size}`]: !!l.size
      }
    ]), C = _(() => ({
      resize: l.noResize ? "none" : void 0
    }));
    return o({
      blur: v,
      element: i,
      focus: m
    }), (p, B) => (b(), O("textarea", {
      id: n(u),
      ref_key: "input",
      ref: i,
      class: D(h.value),
      name: n(l).name || void 0,
      form: n(l).form || void 0,
      value: n(t) ?? void 0,
      disabled: n(l).disabled,
      placeholder: n(l).placeholder,
      required: n(l).required || void 0,
      autocomplete: n(l).autocomplete || void 0,
      readonly: n(l).readonly || n(l).plaintext,
      "aria-required": n(l).required || void 0,
      "aria-invalid": n(r),
      rows: n(l).rows,
      style: Le(C.value),
      wrap: n(l).wrap || void 0,
      onInput: B[0] || (B[0] = (g) => n(d)(g)),
      onChange: B[1] || (B[1] = (g) => n(c)(g)),
      onBlur: B[2] || (B[2] = (g) => n(f)(g))
    }, null, 46, td));
  }
}), ld = {
  key: 0,
  class: "input-group-text"
}, od = ["innerHTML"], nd = { key: 1 }, sd = {
  key: 0,
  class: "input-group-text"
}, rd = ["innerHTML"], id = { key: 1 }, ud = /* @__PURE__ */ z({
  __name: "BInputGroup",
  props: {
    append: { default: void 0 },
    appendHtml: { default: void 0 },
    id: { default: void 0 },
    prepend: { default: void 0 },
    prependHtml: { default: void 0 },
    size: { default: "md" },
    tag: { default: "div" }
  },
  setup(a) {
    Xe(Lo, !0);
    const e = j(a, "BInputGroup"), l = _(() => ({
      [`input-group-${e.size}`]: e.size !== "md"
    })), t = k(() => !!e.append || !!e.appendHtml), s = k(() => !!e.prepend || !!e.prependHtml);
    return (i, u) => (b(), N(ue(n(e).tag), {
      id: n(e).id,
      class: D(["input-group", l.value]),
      role: "group"
    }, {
      default: I(() => [
        $(i.$slots, "prepend", {}, () => [
          s.value ? (b(), O("span", ld, [
            n(e).prependHtml ? (b(), O("span", {
              key: 0,
              innerHTML: n(e).prependHtml
            }, null, 8, od)) : (b(), O("span", nd, J(n(e).prepend), 1))
          ])) : te("", !0)
        ]),
        $(i.$slots, "default"),
        $(i.$slots, "append", {}, () => [
          t.value ? (b(), O("span", sd, [
            n(e).appendHtml ? (b(), O("span", {
              key: 0,
              innerHTML: n(e).appendHtml
            }, null, 8, rd)) : (b(), O("span", id, J(n(e).append), 1))
          ])) : te("", !0)
        ])
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), dd = /* @__PURE__ */ z({
  __name: "BInputGroupText",
  props: {
    tag: { default: "div" },
    text: { default: void 0 }
  },
  setup(a) {
    const e = j(a, "BInputGroupText");
    return (l, t) => (b(), N(ue(n(e).tag), { class: "input-group-text" }, {
      default: I(() => [
        $(l.$slots, "default", {}, () => [
          se(J(n(e).text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), cd = /* @__PURE__ */ z({
  __name: "BListGroup",
  props: {
    flush: { type: Boolean, default: !1 },
    horizontal: { type: [Boolean, String], default: !1 },
    numbered: { type: Boolean, default: !1 },
    tag: { default: "div" }
  },
  setup(a) {
    const e = j(a, "BListGroup"), l = _(() => {
      const s = e.flush ? !1 : e.horizontal;
      return {
        "list-group-flush": e.flush,
        "list-group-horizontal": s === !0,
        [`list-group-horizontal-${s}`]: typeof s == "string",
        "list-group-numbered": e.numbered
      };
    }), t = k(() => e.numbered === !0 ? "ol" : e.tag);
    return Xe(To, {
      numbered: k(() => e.numbered)
    }), (s, i) => (b(), N(ue(t.value), {
      class: D(["list-group", l.value])
    }, {
      default: I(() => [
        $(s.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), fd = /* @__PURE__ */ z({
  __name: "BListGroupItem",
  props: {
    action: { type: Boolean, default: !1 },
    button: { type: Boolean, default: !1 },
    tag: { default: "div" },
    active: { type: Boolean, default: !1 },
    activeClass: { default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    stretched: { type: Boolean, default: !1 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: void 0 },
    prefetch: { type: Boolean },
    noPrefetch: { type: Boolean },
    prefetchedClass: {},
    noRel: { type: Boolean }
  },
  setup(a) {
    const e = j(a, "BListGroupItem"), l = Mt(), t = Ve(To, null), { computedLink: s } = wt(e), i = k(() => !e.button && s.value), u = k(
      () => t != null && t.numbered.value ? "li" : e.button ? "button" : i.value ? st : e.tag
    ), r = _(
      () => e.action || i.value || e.button || ["a", "router-link", "button", "b-link"].includes(e.tag)
    ), d = _(() => ({
      [`list-group-item-${e.variant}`]: e.variant !== null && e.variant !== void 0,
      "list-group-item-action": r.value,
      active: e.active,
      disabled: e.disabled
    })), c = _(() => {
      const f = {};
      return e.button && ((!l || !l.type) && (f.type = "button"), e.disabled && (f.disabled = !0)), f;
    });
    return (f, m) => (b(), N(ue(u.value), K({
      class: ["list-group-item", d.value],
      "aria-current": n(e).active ? !0 : void 0,
      "aria-disabled": n(e).disabled ? !0 : void 0,
      target: i.value ? n(e).target : void 0,
      href: n(e).button ? void 0 : n(e).href,
      to: n(e).button ? void 0 : n(e).to
    }, c.value), {
      default: I(() => [
        $(f.$slots, "default")
      ]),
      _: 3
    }, 16, ["class", "aria-current", "aria-disabled", "target", "href", "to"]));
  }
}), vd = { id: "__BVID__modal-container" }, pd = /* @__PURE__ */ z({
  __name: "BModalOrchestrator",
  props: {
    teleportDisabled: { default: !1 },
    teleportTo: { default: "body" }
  },
  setup(a, { expose: o }) {
    const l = j(a, "BModalOrchestrator"), { modals: t, remove: s, show: i, confirm: u, leave: r } = Ko(), d = (c) => ga(c, ["_promise", "_self", "_isConfirm", "_modelValue"]);
    return o({
      modals: t,
      show: i,
      confirm: u
    }), (c, f) => (b(), N(Bt, {
      to: n(l).teleportTo,
      disabled: n(l).teleportDisabled
    }, [
      Q("div", vd, [
        (b(!0), O(pe, null, ke(n(t), (m, v) => (b(), N(ue(m.value.component), K({
          key: v,
          modelValue: m.value.props._modelValue,
          "onUpdate:modelValue": (y) => m.value.props._modelValue = y,
          ref_for: !0
        }, d(m.value.props), {
          "teleport-disabled": !0,
          "onUpdate:modelValue": (y) => {
            var h;
            return (h = n(r)) == null ? void 0 : h(m.value.props._self);
          },
          onHide: (y) => {
            if (m.value.props._isConfirm === !0) {
              if (y.trigger === "ok") {
                m.value.props._promise.resolve(!0);
                return;
              }
              if (y.trigger === "cancel") {
                m.value.props._promise.resolve(!1);
                return;
              }
              m.value.props._promise.resolve(null);
            }
            m.value.props._promise.resolve(!0);
          },
          onHidden: (y) => {
            var h;
            return (h = n(s)) == null ? void 0 : h(m.value.props._self);
          }
        }), null, 16, ["modelValue", "onUpdate:modelValue", "onHide", "onHidden"]))), 128))
      ])
    ], 8, ["to", "disabled"]));
  }
}), md = /* @__PURE__ */ z({
  __name: "BNav",
  props: {
    align: { default: void 0 },
    cardHeader: { type: Boolean, default: !1 },
    fill: { type: Boolean, default: !1 },
    justified: { type: Boolean, default: !1 },
    pills: { type: Boolean, default: !1 },
    small: { type: Boolean, default: !1 },
    tabs: { type: Boolean, default: !1 },
    tag: { default: "ul" },
    underline: { type: Boolean, default: !1 },
    vertical: { type: Boolean, default: !1 }
  },
  setup(a) {
    const e = j(a, "BNav"), l = jt(() => e.align), t = _(() => ({
      "nav-tabs": e.tabs,
      "nav-pills": e.pills && !e.tabs,
      "card-header-tabs": !e.vertical && e.cardHeader && e.tabs,
      "card-header-pills": !e.vertical && e.cardHeader && e.pills && !e.tabs,
      "flex-column": e.vertical,
      "nav-fill": !e.vertical && e.fill,
      "nav-justified": !e.vertical && e.justified,
      [l.value]: !e.vertical && e.align !== void 0,
      small: e.small,
      "nav-underline": e.underline
    }));
    return (s, i) => (b(), N(ue(n(e).tag), {
      class: D(["nav", t.value])
    }, {
      default: I(() => [
        $(s.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), bd = { class: "d-flex flex-row align-items-center flex-wrap" }, yd = /* @__PURE__ */ z({
  inheritAttrs: !1,
  __name: "BNavForm",
  props: {
    role: { default: void 0 },
    floating: { type: Boolean, default: void 0 },
    id: { default: void 0 },
    novalidate: { type: Boolean, default: void 0 },
    validated: { type: Boolean, default: void 0 }
  },
  emits: ["submit"],
  setup(a, { emit: o }) {
    const l = j(a, "BNavForm"), t = o, s = (i) => {
      t("submit", i);
    };
    return (i, u) => (b(), O("li", bd, [
      be(mn, K(i.$attrs, {
        id: n(l).id,
        floating: n(l).floating,
        role: n(l).role,
        novalidate: n(l).novalidate,
        validated: n(l).validated,
        class: "d-flex",
        onSubmit: bt(s, ["prevent"])
      }), {
        default: I(() => [
          $(i.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "floating", "role", "novalidate", "validated"])
    ]));
  }
}), gd = { class: "nav-item" }, hd = /* @__PURE__ */ z({
  __name: "BNavItem",
  props: {
    linkAttrs: { default: void 0 },
    linkClass: { default: void 0 },
    active: { type: Boolean, default: void 0 },
    activeClass: { default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    stretched: { type: Boolean, default: !1 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: void 0 },
    prefetch: { type: Boolean },
    noPrefetch: { type: Boolean },
    prefetchedClass: {},
    noRel: { type: Boolean }
  },
  emits: ["click"],
  setup(a, { emit: o }) {
    const l = j(a, "BNavItem"), t = o, s = _(
      () => ol(l, [
        "active",
        "activeClass",
        "append",
        "disabled",
        "href",
        "icon",
        "opacity",
        "opacityHover",
        "rel",
        "replace",
        "routerComponentName",
        "target",
        "to",
        "underlineOffset",
        "underlineOffsetHover",
        "underlineOpacity",
        "underlineOpacityHover",
        "underlineVariant",
        "variant"
      ])
    );
    return s.value.activeClass, (i, u) => (b(), O("li", gd, [
      be(st, K({
        class: ["nav-link", i.linkClass],
        tabindex: n(l).disabled ? -1 : void 0,
        "aria-disabled": n(l).disabled ? !0 : void 0
      }, { ...s.value, ...i.linkAttrs }, {
        onClick: u[0] || (u[0] = (r) => t("click", r))
      }), {
        default: I(() => [
          $(i.$slots, "default")
        ]),
        _: 3
      }, 16, ["class", "tabindex", "aria-disabled"])
    ]));
  }
}), Bd = { class: "nav-item dropdown" }, _d = /* @__PURE__ */ z({
  __name: "BNavItemDropdown",
  props: /* @__PURE__ */ ye({
    ariaLabel: { default: void 0 },
    autoClose: { type: [Boolean, String], default: !0 },
    boundary: { default: "clippingAncestors" },
    boundaryPadding: { default: void 0 },
    center: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    dropend: { type: Boolean, default: !1 },
    dropstart: { type: Boolean, default: !1 },
    dropup: { type: Boolean, default: !1 },
    end: { type: Boolean, default: !1 },
    floatingMiddleware: { default: void 0 },
    id: { default: void 0 },
    isNav: { type: Boolean, default: !0 },
    lazy: { type: Boolean, default: !1 },
    menuClass: { default: void 0 },
    modelValue: { type: Boolean },
    noCaret: { type: Boolean, default: !1 },
    noFlip: { type: Boolean, default: !1 },
    noShift: { type: Boolean, default: !1 },
    noSize: { type: Boolean, default: !1 },
    offset: { default: 0 },
    role: { default: "menu" },
    size: { default: "md" },
    skipWrapper: { type: Boolean },
    split: { type: Boolean, default: !1 },
    splitButtonType: { default: "button" },
    splitClass: { default: void 0 },
    splitDisabled: { type: Boolean, default: void 0 },
    splitHref: { default: void 0 },
    splitTo: { default: void 0 },
    splitVariant: { default: void 0 },
    strategy: { default: "absolute" },
    text: { default: void 0 },
    toggleClass: { default: void 0 },
    toggleText: { default: "Toggle dropdown" },
    variant: { default: "link" },
    wrapperClass: {},
    teleportDisabled: { default: !1 },
    teleportTo: { default: void 0 }
  }, {
    modelValue: { type: Boolean, default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ ye(["click", "hidden", "hide", "hide-prevented", "show", "show-prevented", "shown", "toggle"], ["update:modelValue"]),
  setup(a, { expose: o, emit: e }) {
    const t = j(a, "BNavItemDropdown"), s = e, i = _e(a, "modelValue"), u = F(null), r = () => {
      var f;
      (f = u.value) == null || f.hide();
    }, d = () => {
      var f;
      (f = u.value) == null || f.show();
    };
    return o({
      hide: r,
      show: d,
      toggle: () => {
        var f;
        (f = u.value) == null || f.toggle();
      }
    }), (f, m) => (b(), O("li", Bd, [
      be(pn, K({
        ref_key: "dropdown",
        ref: u
      }, n(t), {
        modelValue: i.value,
        "onUpdate:modelValue": m[0] || (m[0] = (v) => i.value = v),
        "is-nav": "",
        onShow: m[1] || (m[1] = (v) => s("show", v)),
        onShown: m[2] || (m[2] = (v) => s("shown")),
        onHide: m[3] || (m[3] = (v) => s("hide", v)),
        onHidden: m[4] || (m[4] = (v) => s("hidden")),
        onHidePrevented: m[5] || (m[5] = (v) => s("hide-prevented")),
        onShowPrevented: m[6] || (m[6] = (v) => s("show-prevented")),
        onClick: m[7] || (m[7] = (v) => s("click", v)),
        onToggle: m[8] || (m[8] = (v) => s("toggle"))
      }), {
        "button-content": I(() => [
          $(f.$slots, "button-content")
        ]),
        "toggle-text": I(() => [
          $(f.$slots, "toggle-text")
        ]),
        default: I(() => [
          $(f.$slots, "default", {
            hide: r,
            show: d
          })
        ]),
        _: 3
      }, 16, ["modelValue"])
    ]));
  }
}), wd = { class: "navbar-text" }, Cd = /* @__PURE__ */ z({
  __name: "BNavText",
  props: {
    text: { default: void 0 }
  },
  setup(a) {
    const e = j(a, "BNavText");
    return (l, t) => (b(), O("li", wd, [
      $(l.$slots, "default", {}, () => [
        se(J(n(e).text), 1)
      ])
    ]));
  }
}), kd = /* @__PURE__ */ z({
  __name: "BNavbar",
  props: {
    autoClose: { type: Boolean, default: !0 },
    container: { type: [Boolean, String], default: "fluid" },
    fixed: { default: void 0 },
    print: { type: Boolean, default: !1 },
    sticky: { default: void 0 },
    tag: { default: "nav" },
    toggleable: { type: [Boolean, String], default: !1 },
    variant: { default: null }
  },
  setup(a) {
    const e = j(a, "BNavbar"), l = k(() => e.tag === "nav" ? void 0 : "navigation"), t = Er(() => e.container), s = _(() => ({
      "d-print": e.print,
      [`sticky-${e.sticky}`]: e.sticky !== void 0,
      [`bg-${e.variant}`]: e.variant !== null,
      [`fixed-${e.fixed}`]: e.fixed !== void 0,
      "navbar-expand": e.toggleable === !1,
      [`navbar-expand-${e.toggleable}`]: typeof e.toggleable == "string"
    }));
    return Xe(ll, {
      tag: k(() => e.tag),
      autoClose: k(() => e.autoClose)
    }), (i, u) => (b(), N(ue(n(e).tag), {
      class: D(["navbar", s.value]),
      role: l.value
    }, {
      default: I(() => [
        n(e).container !== !1 ? (b(), O("div", {
          key: 0,
          class: D(n(t))
        }, [
          $(i.$slots, "default")
        ], 2)) : $(i.$slots, "default", { key: 1 })
      ]),
      _: 3
    }, 8, ["class", "role"]));
  }
}), Td = /* @__PURE__ */ z({
  __name: "BNavbarBrand",
  props: {
    tag: { default: "div" },
    active: { type: Boolean, default: void 0 },
    activeClass: { default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    stretched: { type: Boolean, default: !1 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: void 0 },
    prefetch: { type: Boolean },
    noPrefetch: { type: Boolean },
    prefetchedClass: {},
    noRel: { type: Boolean }
  },
  setup(a) {
    const e = j(a, "BNavbarBrand"), { computedLink: l, computedLinkProps: t } = wt(e, [
      "active",
      "activeClass",
      "append",
      "disabled",
      "href",
      "rel",
      "replace",
      "routerComponentName",
      "target",
      "to",
      "variant",
      "opacity",
      "opacityHover",
      "underlineVariant",
      "underlineOffset",
      "underlineOffsetHover",
      "underlineOpacity",
      "underlineOpacityHover",
      "icon"
    ]), s = k(() => l.value ? st : e.tag);
    return (i, u) => (b(), N(ue(s.value), K({ class: "navbar-brand" }, n(t)), {
      default: I(() => [
        $(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), $d = /* @__PURE__ */ z({
  __name: "BNavbarNav",
  props: {
    align: { default: void 0 },
    fill: { type: Boolean, default: !1 },
    justified: { type: Boolean, default: !1 },
    small: { type: Boolean, default: !1 },
    tag: { default: "ul" }
  },
  setup(a) {
    const e = j(a, "BNavbarNav"), l = jt(() => e.align), t = _(() => ({
      "nav-fill": e.fill,
      "nav-justified": e.justified,
      [l.value]: e.align !== void 0,
      small: e.small
    }));
    return (s, i) => (b(), O("ul", {
      class: D(["navbar-nav", t.value])
    }, [
      $(s.$slots, "default")
    ], 2));
  }
}), Fl = (a, o) => a.setAttribute("data-bs-theme", o), xd = {
  mounted(a, o) {
    Fl(a, o.value);
  },
  updated(a, o) {
    Fl(a, o.value);
  }
}, Sd = (a, o) => {
  const { modifiers: e, arg: l, value: t } = a, s = Object.keys(e || {}), i = typeof t == "string" ? t.split(Qt) : t;
  if (o.tagName.toLowerCase() === "a") {
    const u = o.getAttribute("href") || "";
    Tr.test(u) && s.push(u.replace(kr, ""));
  }
  return Array.prototype.concat.apply([], [l, i]).forEach((u) => typeof u == "string" && s.push(u)), s.filter((u, r, d) => u && d.indexOf(u) === r);
}, Vd = (a, o) => {
  a.forEach((e) => {
    const l = document.getElementById(e);
    l !== null && l.dispatchEvent(new Event("bv-toggle"));
  }), setTimeout(() => _n(a, o), 50);
}, _n = (a, o) => {
  let e = !1;
  a.forEach((l) => {
    const t = document.getElementById(l);
    t != null && t.classList.contains("show") && (e = !0), t != null && t.classList.contains("closing") && (e = !1);
  }), o.setAttribute("aria-expanded", e ? "true" : "false"), o.classList.remove(e ? "collapsed" : "not-collapsed"), o.classList.add(e ? "not-collapsed" : "collapsed");
}, Ll = (a, o) => {
  const e = Sd(o, a);
  e.length !== 0 && (a.__toggle && a.removeEventListener("click", a.__toggle), a.__toggle = () => Vd(e, a), a.addEventListener("click", a.__toggle), a.setAttribute("aria-controls", e.join(" ")), _n(e, a));
}, za = {
  mounted: Ll,
  updated: Ll,
  unmounted(a) {
    a.removeEventListener("click", a.__toggle), a.removeAttribute("aria-controls"), a.removeAttribute("aria-expanded");
  }
}, Ad = {
  mounted(a, o) {
    if (!Ht(o.value))
      return;
    const l = ua(o.value, a);
    !l.content && !l.title || ca(a, o, {
      ...da(o, a),
      ...l
    });
  },
  updated(a, o) {
    if (!Ht(o.value))
      return;
    const l = ua(o.value, a);
    !l.content && !l.title || (fa(a), ca(a, o, {
      ...da(o, a),
      ...l
    }));
  },
  beforeUnmount(a) {
    fa(a);
  }
}, zl = (a, o) => {
  a.$__scrollspy && a.$__scrollspy.cleanup();
  const { arg: e, value: l } = o, t = typeof l == "object" && l !== null, s = e || (typeof l == "string" ? l : t ? l.content || l.element : null);
  a.$__scrollspy = Zo(s, a, t ? ga(l, ["content", "element"]) : {});
}, Od = {
  mounted: zl,
  updated: zl,
  beforeUnmount(a) {
    a.$__scrollspy && a.$__scrollspy.cleanup();
  }
}, Pd = {
  mounted(a, o) {
    const e = Ht(o.value);
    if (!e)
      return;
    const l = ua(o.value, a);
    !l.content && !l.title || ca(a, o, {
      noninteractive: !0,
      ...da(o, a),
      title: l.title ?? l.content ?? "",
      tooltip: e
    });
  },
  updated(a, o) {
    const e = Ht(o.value);
    if (!e)
      return;
    const l = ua(o.value, a);
    !l.content && !l.title || (fa(a), ca(a, o, {
      noninteractive: !0,
      ...da(o, a),
      title: l.title ?? l.content ?? "",
      tooltip: e
    }));
  },
  beforeUnmount(a) {
    fa(a);
  }
}, Ra = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  vBColorMode: xd,
  vBModal: za,
  vBPopover: Ad,
  vBScrollspy: Od,
  vBToggle: za,
  vBTooltip: Pd
}, Symbol.toStringTag, { value: "Module" })), Nd = ["disabled", "aria-label"], Id = /* @__PURE__ */ Q("span", { class: "navbar-toggler-icon" }, null, -1), Ed = /* @__PURE__ */ z({
  __name: "BNavbarToggle",
  props: {
    disabled: { type: Boolean, default: !1 },
    label: { default: "Toggle navigation" },
    target: { default: void 0 }
  },
  emits: ["click"],
  setup(a, { emit: o }) {
    const l = j(a, "BNavbarToggle"), t = o, s = _(() => ({
      disabled: l.disabled
    })), i = (u) => {
      l.disabled || t("click", u);
    };
    return (u, r) => ct((b(), O("button", {
      class: D(["navbar-toggler", s.value]),
      type: "button",
      disabled: n(l).disabled,
      "aria-label": n(l).label,
      onClick: i
    }, [
      $(u.$slots, "default", {}, () => [
        Id
      ])
    ], 10, Nd)), [
      [n(za), n(l).disabled ? void 0 : n(l).target]
    ]);
  }
}), Fd = ["id", "aria-labelledby"], Ld = ["id"], zd = /* @__PURE__ */ z({
  inheritAttrs: !1,
  __name: "BOffcanvas",
  props: /* @__PURE__ */ ye({
    backdrop: { type: Boolean, default: !0 },
    backdropBlur: { default: void 0 },
    backdropVariant: { default: "dark" },
    bodyAttrs: { default: void 0 },
    bodyClass: { default: void 0 },
    bodyScrolling: { type: Boolean, default: !1 },
    footerClass: { default: void 0 },
    headerClass: { default: void 0 },
    headerCloseClass: { default: void 0 },
    headerCloseLabel: { default: "Close" },
    headerCloseVariant: { default: "secondary" },
    id: { default: void 0 },
    lazy: { type: Boolean, default: !1 },
    modelValue: { type: Boolean },
    noCloseOnBackdrop: { type: Boolean, default: !1 },
    noCloseOnEsc: { type: Boolean, default: !1 },
    noFocus: { type: Boolean, default: !1 },
    noHeader: { type: Boolean, default: !1 },
    noHeaderClose: { type: Boolean, default: !1 },
    placement: { default: "start" },
    shadow: { type: [String, Boolean], default: !1 },
    title: { default: void 0 },
    width: { default: void 0 },
    teleportDisabled: { default: !1 },
    teleportTo: { default: "body" }
  }, {
    modelValue: { type: Boolean, default: !1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ ye(["close", "esc", "hidden", "hide", "hide-prevented", "show", "show-prevented", "shown"], ["update:modelValue"]),
  setup(a, { expose: o, emit: e }) {
    const t = j(a, "BOffcanvas"), s = e, i = Re(), u = _e(a, "modelValue"), r = we(() => t.id, "offcanvas");
    Yo(u, () => t.bodyScrolling);
    const d = F(null);
    De(
      "Escape",
      () => {
        V("esc");
      },
      { target: d }
    );
    const { focused: c } = Fe(d, {
      initialValue: u.value && t.noFocus === !1
    }), f = F(u.value), m = F(!1), v = k(() => t.backdrop === !0 && u.value === !0), y = k(
      () => t.lazy === !1 || t.lazy === !0 && m.value === !0 || t.lazy === !0 && u.value === !0
    ), h = k(() => !Ae(i["header-close"])), C = _(() => [
      { "text-reset": !h.value },
      t.headerCloseClass
    ]), p = _(() => ({
      variant: h.value ? t.headerCloseVariant : void 0,
      class: C.value
    })), B = k(() => !Ae(i.footer)), g = _(() => [
      // props.responsive === undefined ? 'offcanvas' : `offcanvas-${props.responsive}`,
      "offcanvas",
      // Remove when above check is fixed
      `offcanvas-${t.placement}`,
      {
        show: u.value && f.value === !0,
        [`shadow-${t.shadow}`]: !!t.shadow
      }
    ]), S = _(() => ({
      width: t.width
    })), w = _(() => ({
      visible: u.value,
      placement: t.placement,
      hide: V
    })), x = (U, T = {}) => new _t(U, {
      cancelable: !1,
      target: d.value || null,
      relatedTarget: null,
      trigger: null,
      ...T,
      componentId: r.value
    }), V = (U = "") => {
      if (U === "backdrop" && t.noCloseOnBackdrop || U === "esc" && t.noCloseOnEsc) {
        s("hide-prevented");
        return;
      }
      const T = x("hide", { cancelable: U !== "", trigger: U });
      if (U === "close" && s(U, T), U === "esc" && s(U, T), s("hide", T), T.defaultPrevented) {
        s("hide-prevented");
        return;
      }
      u.value = !1;
    }, G = () => {
      const U = x("show", { cancelable: !0 });
      if (s("show", U), U.defaultPrevented) {
        u.value = !1, s("show-prevented");
        return;
      }
      u.value = !0;
    }, W = () => {
      Ie(() => {
        t.noFocus === !1 && (c.value = !0);
      });
    }, P = () => G(), Y = () => {
      f.value = !0, W(), s("shown", x("shown")), t.lazy === !0 && (m.value = !0);
    }, ae = () => {
      f.value = !1;
    }, ne = () => {
      s("hidden", x("hidden")), t.lazy === !0 && (m.value = !1);
    };
    return $e(d, "bv-toggle", () => {
      u.value ? V() : G();
    }), o({
      hide: V,
      show: G
    }), (U, T) => (b(), N(Bt, {
      to: n(t).teleportTo,
      disabled: n(t).teleportDisabled
    }, [
      be(qt, {
        "no-fade": !0,
        "trans-props": {
          enterToClass: "showing",
          enterFromClass: "",
          leaveToClass: "hiding show",
          leaveFromClass: "show"
        },
        onBeforeEnter: P,
        onAfterEnter: Y,
        onLeave: ae,
        onAfterLeave: ne
      }, {
        default: I(() => [
          ct(Q("div", K({
            id: n(r),
            ref_key: "element",
            ref: d,
            "aria-modal": "true",
            role: "dialog",
            class: g.value,
            style: S.value,
            tabindex: "-1",
            "aria-labelledby": `${n(r)}-offcanvas-label`,
            "data-bs-backdrop": "false"
          }, U.$attrs), [
            y.value ? (b(), O(pe, { key: 0 }, [
              n(t).noHeader ? te("", !0) : (b(), O("div", {
                key: 0,
                class: D(["offcanvas-header", n(t).headerClass])
              }, [
                $(U.$slots, "header", Be(Ce(w.value)), () => [
                  Q("h5", {
                    id: `${n(r)}-offcanvas-label`,
                    class: "offcanvas-title"
                  }, [
                    $(U.$slots, "title", Be(Ce(w.value)), () => [
                      se(J(n(t).title), 1)
                    ])
                  ], 8, Ld),
                  n(t).noHeaderClose ? te("", !0) : (b(), O(pe, { key: 0 }, [
                    h.value ? (b(), N(pt, K({ key: 0 }, p.value, {
                      onClick: T[0] || (T[0] = (A) => V("close"))
                    }), {
                      default: I(() => [
                        $(U.$slots, "header-close")
                      ]),
                      _: 3
                    }, 16)) : (b(), N(Et, K({
                      key: 1,
                      "aria-label": n(t).headerCloseLabel
                    }, p.value, {
                      onClick: T[1] || (T[1] = (A) => V("close"))
                    }), null, 16, ["aria-label"]))
                  ], 64))
                ])
              ], 2)),
              Q("div", K({
                class: ["offcanvas-body", n(t).bodyClass]
              }, n(t).bodyAttrs), [
                $(U.$slots, "default", Be(Ce(w.value)))
              ], 16),
              B.value ? (b(), O("div", {
                key: 1,
                class: D(n(t).footerClass)
              }, [
                $(U.$slots, "footer", Be(Ce(w.value)))
              ], 2)) : te("", !0)
            ], 64)) : te("", !0)
          ], 16, Fd), [
            [Dt, u.value]
          ])
        ]),
        _: 3
      }),
      $(U.$slots, "backdrop", {}, () => [
        be(Ba, {
          blur: n(t).backdropBlur,
          variant: n(t).backdropVariant,
          show: v.value,
          fixed: "",
          "no-wrap": "",
          "no-spinner": "",
          onClick: T[2] || (T[2] = (A) => V("backdrop"))
        }, null, 8, ["blur", "variant", "show"])
      ])
    ], 8, ["to", "disabled"]));
  }
}), Rd = ["aria-disabled", "aria-label"], Rl = 20, Hl = 0, Hd = /* @__PURE__ */ z({
  __name: "BPagination",
  props: /* @__PURE__ */ ye({
    align: { default: "start" },
    ariaControls: { default: void 0 },
    ariaLabel: { default: "Pagination" },
    disabled: { type: Boolean, default: !1 },
    ellipsisClass: { default: void 0 },
    ellipsisText: { default: "…" },
    firstClass: { default: void 0 },
    firstNumber: { type: Boolean, default: !1 },
    firstText: { default: "«" },
    hideEllipsis: { type: Boolean, default: !1 },
    hideGotoEndButtons: { type: Boolean, default: !1 },
    labelFirstPage: { default: "Go to first page" },
    labelLastPage: { default: "Go to last page" },
    labelNextPage: { default: "Go to next page" },
    labelPage: { default: "Go to page" },
    labelPrevPage: { default: "Go to previous page" },
    lastClass: { default: void 0 },
    lastNumber: { type: Boolean, default: !1 },
    lastText: { default: "»" },
    limit: { default: 5 },
    modelValue: {},
    nextClass: { default: void 0 },
    nextText: { default: "›" },
    pageClass: { default: void 0 },
    perPage: { default: Rl },
    pills: { type: Boolean, default: !1 },
    prevClass: { default: void 0 },
    prevText: { default: "‹" },
    size: { default: void 0 },
    totalRows: { default: Hl }
  }, {
    modelValue: { default: 1 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ ye(["page-click"], ["update:modelValue"]),
  setup(a, { emit: o }) {
    const d = j(a, "BPagination"), c = o, f = _e(a, "modelValue"), m = he(() => d.limit, { nanToZero: !0, method: "parseInt" }), v = he(() => d.perPage, { nanToZero: !0, method: "parseInt" }), y = he(() => d.totalRows, { nanToZero: !0, method: "parseInt" }), h = he(f, { nanToZero: !0, method: "parseInt" }), C = k(() => Math.max(v.value || Rl, 1)), p = k(() => Math.max(y.value || Hl, 0)), B = k(() => Math.ceil(p.value / C.value)), g = k(() => d.align === "fill"), S = k(() => d.align === "fill" ? "start" : d.align), w = jt(S), x = (ee) => ee === h.value, V = (ee) => d.disabled ? null : x(ee) ? "0" : "-1", G = (ee) => d.disabled || x(ee) || h.value < 1 || // Check if the number is out of bounds
    ee < 1 || ee > B.value, W = _(() => G(1)), P = _(() => G(h.value - 1)), Y = _(() => G(B.value)), ae = _(() => G(h.value + 1)), ne = ({
      page: ee,
      classVal: re,
      dis: ie,
      slotName: ve,
      textValue: L,
      tabIndex: X,
      label: ge,
      position: me,
      isActive: Oe,
      role: xe,
      hidden: Se
    }) => ({
      li: {
        class: [
          "page-item",
          {
            active: Oe,
            disabled: ie,
            "flex-fill": g.value,
            "d-flex": g.value && !ie
          },
          re
        ],
        role: xe,
        "aria-hidden": Se
      },
      button: {
        is: ie ? "span" : "button",
        class: ["page-link", { "flex-grow-1": !ie && g.value }],
        "aria-label": ge,
        "aria-controls": d.ariaControls || void 0,
        "aria-disabled": ie ? !0 : void 0,
        "aria-posinset": me,
        "aria-setsize": me ? B.value : void 0,
        role: "menuitem",
        type: ie ? void 0 : "button",
        tabindex: ie ? void 0 : X
      },
      text: {
        name: ve,
        active: Oe,
        value: L ?? ee,
        page: ee,
        disabled: ie,
        index: ee - 1,
        content: L ? void 0 : ee
      },
      clickHandler: (et) => oe(et, ee)
    }), U = ({
      page: ee,
      classVal: re,
      dis: ie,
      slotName: ve,
      textValue: L,
      label: X
    }) => ne({ page: ee, classVal: re, dis: ie, slotName: ve, textValue: L, label: X, tabIndex: "-1" }), T = (ee) => ne({
      page: ee,
      dis: d.disabled,
      classVal: d.pageClass,
      slotName: "page",
      label: d.labelPage ? `${d.labelPage} ${ee}` : void 0,
      tabIndex: V(ee) ?? void 0,
      position: ee,
      isActive: x(ee)
    }), A = _(
      () => U({
        page: 1,
        dis: W.value,
        classVal: d.firstClass,
        slotName: "first-text",
        textValue: d.firstText,
        label: d.labelFirstPage
      })
    ), E = _(
      () => U({
        page: Math.max(h.value - 1, 1),
        dis: P.value,
        classVal: d.prevClass,
        slotName: "prev-text",
        textValue: d.prevText,
        label: d.labelPrevPage
      })
    ), M = _(
      () => U({
        page: Math.min(h.value + 1, B.value),
        dis: ae.value,
        classVal: d.nextClass,
        slotName: "next-text",
        textValue: d.nextText,
        label: d.labelNextPage
      })
    ), Z = _(
      () => U({
        page: B.value,
        dis: Y.value,
        classVal: d.lastClass,
        slotName: "last-text",
        textValue: d.lastText,
        label: d.labelLastPage
      })
    ), R = ia(), H = ia(), ce = _(() => ({
      li: {
        class: [
          "page-item",
          "disabled",
          "bv-d-xs-down-none",
          g.value ? "flex-fill" : "",
          d.ellipsisClass
        ],
        role: "separator"
      },
      span: {
        class: ["page-link"]
      }
    })), le = _(() => [
      w.value,
      {
        [`pagination-${d.size}`]: d.size !== void 0,
        "b-pagination-pills": d.pills
      }
    ]), q = _(() => ({
      pageSize: C.value,
      totalRows: y.value,
      numberOfPages: B.value
    })), oe = (ee, re) => {
      if (re === h.value)
        return;
      const ie = new rt("page-click", {
        cancelable: !0,
        target: ee.target
      });
      c("page-click", ie, re), !ie.defaultPrevented && (f.value = re);
    };
    fe(h, (ee) => {
      const ie = ((ve, L) => {
        const X = ve || 1;
        return X > L ? L : X < 1 ? 1 : X;
      })(ee, B.value);
      ie !== f.value && (f.value = ie);
    }), fe(q, (ee, re) => {
      (re.pageSize !== ee.pageSize && re.totalRows === ee.totalRows || re.numberOfPages !== ee.numberOfPages && h.value > re.numberOfPages) && (f.value = 1);
    });
    const de = _(() => {
      const ee = B.value, { value: re } = h, ie = m.value, ve = d.firstNumber ? 1 : 0, L = d.lastNumber ? 1 : 0, X = d.hideEllipsis || ie <= 3, ge = d.hideGotoEndButtons ? 1 : 0;
      if (ee < ie + ve + L)
        return [
          !ve && !ge ? -1 : null,
          -2,
          ...Array.from({ length: ee }, (xe, Se) => Se + 1),
          -3,
          !L && !ge ? -4 : null
        ].filter((xe) => xe !== null);
      const me = Array.from({ length: ie + 4 - ge * 2 });
      ge ? (me[0] = -2, me[me.length - 1] = -3) : (ve ? (me[0] = -2, me[1] = 1) : (me[0] = -1, me[1] = -2), L ? (me[me.length - 1] = -3, me[me.length - 2] = ee) : (me[me.length - 1] = -4, me[me.length - 2] = -3));
      const Oe = Math.floor(ie / 2);
      if (re <= Oe + ve) {
        for (let xe = 1; xe <= ie; xe++)
          me[xe + 1 - ge] = xe + ve;
        X || (me[me.length - 3] = -5);
      }
      if (re > ee - Oe - L) {
        const xe = ee - (ie - 1) - L;
        for (let Se = 0; Se < ie; Se++)
          me[Se + 2 - ge] = xe + Se;
        X || (me[2] = -5);
      }
      if (!me[2]) {
        const xe = re - Math.floor(ie / 2);
        for (let Se = 0; Se < ie; Se++)
          me[Se + 2 - ge] = xe + Se;
        X || (me[2] = -5, me[me.length - 3] = -5);
      }
      return me;
    });
    return (ee, re) => (b(), O("ul", {
      class: D(["pagination", le.value]),
      role: "menubar",
      "aria-disabled": n(d).disabled,
      "aria-label": n(d).ariaLabel || void 0
    }, [
      be(n(R).define, null, {
        default: I(({ button: ie, li: ve, text: L, clickHandler: X }) => [
          Q("li", Be(Ce(ve)), [
            (b(), N(ue(ie.is), K(ie, { onClick: X }), {
              default: I(() => [
                $(ee.$slots, L.name, {
                  disabled: L.disabled,
                  page: L.page,
                  index: L.index,
                  active: L.active,
                  content: L.value
                }, () => [
                  se(J(L.value), 1)
                ])
              ]),
              _: 2
            }, 1040, ["onClick"]))
          ], 16)
        ]),
        _: 3
      }),
      be(n(H).define, null, {
        default: I(() => [
          Q("li", Be(Ce(ce.value.li)), [
            Q("span", Be(Ce(ce.value.span)), [
              $(ee.$slots, "ellipsis-text", {}, () => [
                se(J(n(d).ellipsisText || "..."), 1)
              ])
            ], 16)
          ], 16)
        ]),
        _: 3
      }),
      (b(!0), O(pe, null, ke(de.value, (ie) => (b(), O(pe, {
        key: `page-${ie}`
      }, [
        ie === -1 ? (b(), N(n(R).reuse, K({
          key: 0,
          ref_for: !0
        }, A.value), null, 16)) : ie === -2 ? (b(), N(n(R).reuse, K({
          key: 1,
          ref_for: !0
        }, E.value), null, 16)) : ie === -3 ? (b(), N(n(R).reuse, K({
          key: 2,
          ref_for: !0
        }, M.value), null, 16)) : ie === -4 ? (b(), N(n(R).reuse, K({
          key: 3,
          ref_for: !0
        }, Z.value), null, 16)) : ie === -5 ? (b(), N(n(H).reuse, { key: 4 })) : ie !== null ? (b(), N(n(R).reuse, K({
          key: 5,
          ref_for: !0
        }, T(ie)), null, 16)) : te("", !0)
      ], 64))), 128))
    ], 10, Rd));
  }
}), Ke = /* @__PURE__ */ z({
  inheritAttrs: !1,
  __name: "BPlaceholder",
  props: {
    animation: { default: void 0 },
    cols: { default: 12 },
    size: { default: "md" },
    tag: { default: "span" },
    variant: { default: null },
    width: { default: void 0 },
    wrapperTag: { default: "span" }
  },
  setup(a) {
    const e = j(a, "BPlaceholder"), l = k(
      () => e.width === void 0 ? void 0 : typeof e.width == "number" ? e.width.toString() : e.width.replace("%", "")
    ), t = k(
      () => e.cols === void 0 ? void 0 : typeof e.cols == "number" ? e.cols.toString() : e.cols
    ), s = _(() => ({
      [`col-${t.value}`]: t.value !== void 0 && l.value === void 0,
      [`bg-${e.variant}`]: e.variant !== null,
      [`placeholder-${e.size}`]: e.size !== "md"
    })), i = _(() => ({
      [`placeholder-${e.animation}`]: e.animation !== void 0
    })), u = _(() => ({
      width: l.value === void 0 ? void 0 : `${l.value}%`
    }));
    return (r, d) => (b(), N(ue(n(e).wrapperTag), {
      class: D(i.value)
    }, {
      default: I(() => [
        (b(), N(ue(r.tag), K(r.$attrs, {
          class: ["placeholder", s.value],
          style: u.value
        }), null, 16, ["class", "style"]))
      ]),
      _: 1
    }, 8, ["class"]));
  }
}), wn = /* @__PURE__ */ z({
  __name: "BPlaceholderButton",
  props: {
    animation: { default: void 0 },
    cols: { default: void 0 },
    tag: { default: "div" },
    variant: { default: "primary" },
    width: { default: void 0 }
  },
  setup(a) {
    const e = j(a, "BPlaceholderButton"), l = _(() => ({
      [`btn-${e.variant}`]: e.variant !== null
    }));
    return (t, s) => (b(), N(Ke, {
      class: D(["btn disabled", l.value]),
      animation: n(e).animation,
      width: n(e).width,
      cols: n(e).cols,
      tag: n(e).tag,
      style: { cursor: "wait", "pointer-events": "auto" }
    }, null, 8, ["class", "animation", "width", "cols", "tag"]));
  }
}), Md = /* @__PURE__ */ z({
  __name: "BPlaceholderCard",
  props: {
    animation: { default: void 0 },
    footerAnimation: { default: void 0 },
    footerSize: { default: "md" },
    footerVariant: { default: void 0 },
    footerWidth: { default: 100 },
    headerAnimation: { default: void 0 },
    headerSize: { default: "md" },
    headerVariant: { default: void 0 },
    headerWidth: { default: 100 },
    imgBlankColor: { default: "#868e96" },
    imgPlacement: { default: "top" },
    imgHeight: { default: 100 },
    imgSrc: { default: void 0 },
    noButton: { type: Boolean, default: !1 },
    noFooter: { type: Boolean, default: !1 },
    noHeader: { type: Boolean, default: !1 },
    noImg: { type: Boolean, default: !1 },
    size: { default: "md" },
    variant: { default: void 0 }
  },
  setup(a) {
    const e = j(a, "BPlaceholderCard"), l = _(() => ({
      animation: e.animation,
      size: e.size,
      variant: e.variant
    })), t = k(() => e.noButton ? Ke : wn);
    return (s, i) => (b(), N(vn, {
      "img-placement": n(e).imgPlacement
    }, ja({
      default: I(() => [
        $(s.$slots, "default", {}, () => [
          be(Ke, K({ cols: "7" }, l.value), null, 16),
          be(Ke, K({ cols: "4" }, l.value), null, 16),
          be(Ke, K({ cols: "4" }, l.value), null, 16),
          be(Ke, K({ cols: "6" }, l.value), null, 16),
          be(Ke, K({ cols: "8" }, l.value), null, 16)
        ])
      ]),
      _: 2
    }, [
      n(e).noImg ? void 0 : {
        name: "img",
        fn: I(() => [
          $(s.$slots, "img", {}, () => [
            be(il, {
              blank: !n(e).imgSrc,
              "blank-color": n(e).imgBlankColor,
              height: n(e).imgSrc ? void 0 : n(e).imgHeight,
              src: n(e).imgSrc,
              "img-placement": n(e).imgPlacement,
              style: { cursor: "wait" }
            }, null, 8, ["blank", "blank-color", "height", "src", "img-placement"])
          ])
        ]),
        key: "0"
      },
      n(e).noHeader ? void 0 : {
        name: "header",
        fn: I(() => [
          $(s.$slots, "header", {}, () => [
            be(Ke, {
              width: n(e).headerWidth,
              variant: n(e).headerVariant,
              animation: n(e).headerAnimation,
              size: n(e).headerSize
            }, null, 8, ["width", "variant", "animation", "size"])
          ])
        ]),
        key: "1"
      },
      n(e).noFooter ? void 0 : {
        name: "footer",
        fn: I(() => [
          $(s.$slots, "footer", {}, () => [
            (b(), N(ue(t.value), {
              width: n(e).footerWidth,
              animation: n(e).footerAnimation,
              size: n(e).noButton ? n(e).footerSize : void 0,
              variant: n(e).footerVariant
            }, null, 8, ["width", "animation", "size", "variant"]))
          ])
        ]),
        key: "2"
      }
    ]), 1032, ["img-placement"]));
  }
}), Dd = "300px", dl = /* @__PURE__ */ z({
  __name: "BTableSimple",
  props: {
    bordered: { type: Boolean, default: !1 },
    borderless: { type: Boolean, default: !1 },
    borderVariant: { default: null },
    captionTop: { type: Boolean, default: !1 },
    dark: { type: Boolean, default: !1 },
    fixed: { type: Boolean, default: !1 },
    hover: { type: Boolean, default: !1 },
    id: { default: void 0 },
    noBorderCollapse: { type: Boolean, default: !1 },
    outlined: { type: Boolean, default: !1 },
    responsive: { type: [Boolean, String], default: !1 },
    small: { type: Boolean, default: !1 },
    stacked: { type: [Boolean, String], default: !1 },
    stickyHeader: { type: [Boolean, String, Number], default: !1 },
    striped: { type: Boolean, default: !1 },
    stripedColumns: { type: Boolean, default: !1 },
    variant: { default: null },
    tableAttrs: { default: void 0 },
    tableClass: { default: void 0 }
  },
  setup(a) {
    const e = j(a, "BTableSimple"), l = _(() => [
      e.tableClass,
      "table",
      "b-table",
      {
        "table-bordered": e.bordered,
        "table-borderless": e.borderless,
        [`border-${e.borderVariant}`]: e.borderVariant !== null,
        "caption-top": e.captionTop,
        "table-dark": e.dark,
        "table-hover": e.hover,
        "b-table-stacked": e.stacked === !0,
        [`b-table-stacked-${e.stacked}`]: typeof e.stacked == "string",
        "table-striped": e.striped,
        "table-sm": e.small,
        [`table-${e.variant}`]: e.variant !== null,
        "table-striped-columns": e.stripedColumns
      }
    ]), t = _(() => ({
      id: e.id,
      class: l.value,
      ...e.tableAttrs
    })), s = pa(
      _(
        () => (e.stickyHeader === !0 ? Dd : e.stickyHeader) || NaN
      )
    ), i = _(() => e.stickyHeader !== !1), u = _(() => e.responsive !== !1 || i.value), r = _(
      () => i.value ? { maxHeight: s.value } : void 0
    ), d = _(() => ({
      "table-responsive": e.responsive === !0,
      [`table-responsive-${e.responsive}`]: typeof e.responsive == "string",
      "b-table-sticky-header": i.value
    }));
    return (c, f) => u.value ? (b(), O("div", {
      key: 0,
      class: D(d.value),
      style: Le(r.value)
    }, [
      Q("table", Be(Ce(t.value)), [
        $(c.$slots, "default")
      ], 16)
    ], 6)) : (b(), O("table", Be(K({ key: 1 }, t.value)), [
      $(c.$slots, "default")
    ], 16));
  }
}), jd = /* @__PURE__ */ z({
  __name: "BPlaceholderTable",
  props: {
    animation: { default: void 0 },
    cellWidth: { default: 100 },
    columns: { default: 5 },
    footerAnimation: { default: void 0 },
    footerCellWidth: { default: 100 },
    footerColumns: { default: void 0 },
    footerSize: { default: "md" },
    footerVariant: { default: void 0 },
    headerAnimation: { default: void 0 },
    headerCellWidth: { default: 100 },
    headerColumns: { default: void 0 },
    headerSize: { default: "md" },
    headerVariant: { default: void 0 },
    hideHeader: { type: Boolean, default: !1 },
    rows: { default: 3 },
    showFooter: { type: Boolean, default: !1 },
    size: { default: "md" },
    variant: { default: void 0 }
  },
  setup(a) {
    const e = j(a, "BPlaceholderTable"), l = he(() => e.columns), t = he(() => e.rows), s = k(() => e.headerColumns ?? NaN), i = k(() => e.footerColumns ?? NaN), u = he(s), r = he(i), d = k(() => l.value || 5), c = k(() => t.value || 3), f = k(
      () => e.headerColumns === void 0 ? d.value : u.value
    ), m = k(
      () => e.footerColumns === void 0 ? d.value : r.value
    );
    return (v, y) => (b(), N(dl, null, {
      default: I(() => [
        n(e).hideHeader ? te("", !0) : $(v.$slots, "thead", { key: 0 }, () => [
          Q("thead", null, [
            Q("tr", null, [
              (b(!0), O(pe, null, ke(f.value, (h, C) => (b(), O("th", { key: C }, [
                be(Ke, {
                  size: n(e).headerSize,
                  variant: n(e).headerVariant,
                  animation: n(e).headerAnimation,
                  width: n(e).headerCellWidth
                }, null, 8, ["size", "variant", "animation", "width"])
              ]))), 128))
            ])
          ])
        ]),
        $(v.$slots, "default", {}, () => [
          Q("tbody", null, [
            (b(!0), O(pe, null, ke(c.value, (h, C) => (b(), O("tr", { key: C }, [
              (b(!0), O(pe, null, ke(d.value, (p, B) => (b(), O("td", { key: B }, [
                be(Ke, {
                  size: n(e).size,
                  variant: n(e).variant,
                  animation: n(e).animation,
                  width: n(e).cellWidth
                }, null, 8, ["size", "variant", "animation", "width"])
              ]))), 128))
            ]))), 128))
          ])
        ]),
        n(e).showFooter ? $(v.$slots, "tfoot", { key: 1 }, () => [
          Q("tfoot", null, [
            Q("tr", null, [
              (b(!0), O(pe, null, ke(m.value, (h, C) => (b(), O("th", { key: C }, [
                be(Ke, {
                  size: n(e).footerSize,
                  variant: n(e).footerVariant,
                  animation: n(e).footerAnimation,
                  width: n(e).footerCellWidth
                }, null, 8, ["size", "variant", "animation", "width"])
              ]))), 128))
            ])
          ])
        ]) : te("", !0)
      ]),
      _: 3
    }));
  }
}), Wd = /* @__PURE__ */ z({
  __name: "BPlaceholderWrapper",
  props: {
    loading: { type: Boolean, default: !1 }
  },
  setup(a) {
    const e = j(a, "BPlaceholderWrapper");
    return (l, t) => n(e).loading ? $(l.$slots, "loading", { key: 0 }) : $(l.$slots, "default", { key: 1 });
  }
}), qd = /* @__PURE__ */ z({
  __name: "BRow",
  props: {
    tag: { default: "div" },
    gutterX: { default: void 0 },
    gutterY: { default: void 0 },
    noGutters: { type: Boolean, default: !1 },
    alignV: { default: void 0 },
    alignH: { default: void 0 },
    alignContent: { default: void 0 },
    cols: { default: void 0 },
    colsSm: { default: void 0 },
    colsMd: { default: void 0 },
    colsLg: { default: void 0 },
    colsXl: { default: void 0 },
    colsXxl: { default: void 0 }
  },
  setup(a) {
    const e = j(a, "BRow"), l = jt(() => e.alignH), t = _(
      () => Jt(
        {
          cols: e.cols,
          colsLg: e.colsLg,
          colsMd: e.colsMd,
          colsSm: e.colsSm,
          colsXl: e.colsXl,
          colsXxl: e.colsXxl
        },
        ["cols", "colsLg", "colsMd", "colsSm", "colsXl", "colsXxl"],
        "cols",
        "row-cols"
      )
    ), s = _(() => [
      t.value,
      {
        [`gx-${e.gutterX}`]: e.gutterX !== void 0,
        [`gy-${e.gutterY}`]: e.gutterY !== void 0,
        "g-0": e.noGutters,
        [`align-items-${e.alignV}`]: e.alignV !== void 0,
        [l.value]: e.alignH !== void 0,
        [`align-content-${e.alignContent}`]: e.alignContent !== void 0
      }
    ]);
    return (i, u) => (b(), N(ue(n(e).tag), {
      class: D(["row", s.value])
    }, {
      default: I(() => [
        $(i.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), tt = (a) => typeof a == "object" && a !== null, zt = (a) => typeof a == "object" && a !== null && "key" in a, Cn = /* @__PURE__ */ z({
  __name: "BTbody",
  props: {
    variant: { default: null }
  },
  setup(a) {
    const e = j(a, "BTbody"), l = _(() => ({
      [`thead-${e.variant}`]: e.variant !== null
    }));
    return (t, s) => (b(), O("tbody", {
      class: D(l.value)
    }, [
      $(t.$slots, "default")
    ], 2));
  }
}), Gd = ["scope", "colspan", "rowspan", "data-label"], Ud = { key: 0 }, xt = /* @__PURE__ */ z({
  __name: "BTd",
  props: {
    colspan: { default: void 0 },
    rowspan: { default: void 0 },
    stackedHeading: { default: void 0 },
    stickyColumn: { type: Boolean, default: !1 },
    variant: { default: null }
  },
  setup(a) {
    const e = j(a, "BTd"), l = _(() => ({
      [`table-${e.variant}`]: e.variant !== null,
      "b-table-sticky-column": e.stickyColumn,
      "table-b-table-default": e.stickyColumn && e.variant === null
    })), t = k(() => e.colspan ? "colspan" : e.rowspan ? "rowspan" : "col");
    return (s, i) => (b(), O("td", {
      scope: t.value,
      class: D(l.value),
      colspan: n(e).colspan,
      rowspan: n(e).rowspan,
      "data-label": n(e).stackedHeading
    }, [
      n(e).stackedHeading ? (b(), O("div", Ud, [
        $(s.$slots, "default")
      ])) : $(s.$slots, "default", { key: 1 })
    ], 10, Gd));
  }
}), Ha = /* @__PURE__ */ z({
  __name: "BTfoot",
  props: {
    variant: { default: null }
  },
  setup(a) {
    const e = j(a, "BTfoot"), l = _(() => ({
      [`table-${e.variant}`]: e.variant !== null
    }));
    return (t, s) => (b(), O("tfoot", {
      class: D(l.value)
    }, [
      $(t.$slots, "default")
    ], 2));
  }
}), Xd = ["scope", "colspan", "rowspan", "data-label"], Kd = { key: 0 }, Ma = /* @__PURE__ */ z({
  __name: "BTh",
  props: {
    colspan: { default: void 0 },
    rowspan: { default: void 0 },
    stackedHeading: { default: void 0 },
    stickyColumn: { type: Boolean, default: !1 },
    variant: { default: null }
  },
  setup(a) {
    const e = j(a, "BTh"), l = _(() => ({
      [`table-${e.variant}`]: e.variant !== null,
      "b-table-sticky-column": e.stickyColumn,
      "table-b-table-default": e.stickyColumn && e.variant === null
    })), t = k(() => e.colspan ? "colspan" : e.rowspan ? "rowspan" : "col");
    return (s, i) => (b(), O("th", {
      scope: t.value,
      class: D(l.value),
      colspan: n(e).colspan,
      rowspan: n(e).rowspan,
      "data-label": n(e).stackedHeading
    }, [
      n(e).stackedHeading !== void 0 ? (b(), O("div", Kd, [
        $(s.$slots, "default")
      ])) : $(s.$slots, "default", { key: 1 })
    ], 10, Xd));
  }
}), kn = /* @__PURE__ */ z({
  __name: "BThead",
  props: {
    variant: { default: null }
  },
  setup(a) {
    const e = j(a, "BThead"), l = _(() => ({
      [`table-${e.variant}`]: e.variant !== null
    }));
    return (t, s) => (b(), O("thead", {
      class: D(l.value)
    }, [
      $(t.$slots, "default")
    ], 2));
  }
}), at = /* @__PURE__ */ z({
  __name: "BTr",
  props: {
    variant: { default: null }
  },
  setup(a) {
    const e = j(a, "BTr"), l = _(() => ({
      [`table-${e.variant}`]: e.variant !== null
    }));
    return (t, s) => (b(), O("tr", {
      class: D(l.value)
    }, [
      $(t.$slots, "default")
    ], 2));
  }
}), Yd = {
  key: 0,
  class: "b-table-stacked-label"
}, Zd = { class: "d-inline-flex flex-nowrap align-items-center gap-1" }, Jd = { key: 2 }, Tn = /* @__PURE__ */ z({
  __name: "BTableLite",
  props: {
    align: { default: void 0 },
    caption: { default: void 0 },
    captionHtml: { default: void 0 },
    detailsTdClass: { default: void 0 },
    emptyFilteredText: { default: "There are no records matching your request" },
    emptyText: { default: "There are no records to show" },
    fieldColumnClass: { type: [Function, String, Object, Array], default: void 0 },
    fields: { default: () => [] },
    footClone: { type: Boolean, default: !1 },
    footRowVariant: { default: void 0 },
    footVariant: { default: void 0 },
    headRowVariant: { default: void 0 },
    headVariant: { default: void 0 },
    items: { default: () => [] },
    labelStacked: { type: Boolean, default: !1 },
    modelValue: { default: void 0 },
    primaryKey: { default: void 0 },
    showEmpty: { type: Boolean, default: !1 },
    tbodyClass: { default: void 0 },
    tbodyTrAttrs: {},
    tbodyTrClass: { type: [Function, String, Object, Array], default: void 0 },
    tfootClass: { default: void 0 },
    tfootTrClass: { default: void 0 },
    theadClass: { default: void 0 },
    theadTrClass: { default: void 0 },
    bordered: { type: Boolean, default: void 0 },
    borderless: { type: Boolean, default: void 0 },
    borderVariant: { default: void 0 },
    captionTop: { type: Boolean, default: void 0 },
    dark: { type: Boolean, default: void 0 },
    fixed: { type: Boolean, default: void 0 },
    hover: { type: Boolean, default: void 0 },
    id: { default: void 0 },
    noBorderCollapse: { type: Boolean, default: void 0 },
    outlined: { type: Boolean, default: void 0 },
    responsive: { type: [Boolean, String], default: void 0 },
    small: { type: Boolean, default: void 0 },
    stacked: { type: [Boolean, String], default: void 0 },
    stickyHeader: { type: [Boolean, String, Number], default: void 0 },
    striped: { type: Boolean, default: void 0 },
    stripedColumns: { type: Boolean, default: void 0 },
    variant: { default: void 0 },
    tableAttrs: {},
    tableClass: { default: void 0 }
  },
  emits: ["head-clicked", "row-clicked", "row-dbl-clicked", "row-hovered", "row-unhovered"],
  setup(a, { emit: o }) {
    const l = j(a, "BTableLite"), t = o, s = (p) => [
      p,
      p._showDetails
    ], i = F(
      new WeakMap(
        l.items.reduce(
          (p, B) => (tt(B) && p.push(s(B)), p),
          []
        )
      )
    );
    fe(
      () => l.items,
      (p) => {
        p.forEach((B) => {
          if (!tt(B))
            return;
          const g = s(B);
          i.value.set(g[0], g[1]);
        });
      },
      { deep: !0 }
    );
    const u = _(() => [
      l.tableClass,
      {
        [`align-${l.align}`]: l.align !== void 0
      }
    ]), r = _(() => {
      if (!l.fields.length && l.items.length) {
        const [p] = l.items;
        return tt(p) || Array.isArray(p) ? Object.keys(p).map((B) => {
          const g = Ca(B);
          return {
            key: B,
            label: g,
            tdAttr: l.stacked === !0 ? { "data-label": g } : void 0
          };
        }) : [{ key: "", _noHeader: !0 }];
      }
      return l.fields.map((p) => {
        if (zt(p))
          return {
            ...p,
            tdAttr: l.stacked === !0 ? { "data-label": Ca(p.key), ...p.tdAttr } : p.tdAttr
          };
        const B = Ca(p);
        return {
          key: p,
          label: B,
          tdAttr: l.stacked === !0 ? { "data-label": B } : void 0
        };
      });
    }), d = k(() => r.value.length), c = _(() => !(r.value.length > 0 && r.value.every((p) => p._noHeader === !0))), f = (p, B, g) => {
      const S = Ee(p, B);
      return g && typeof g == "function" ? g(S, B, p) : g;
    }, m = (p, B, g = !1) => {
      t("head-clicked", p.key, p, B, g);
    }, v = (p) => {
      if (tt(p)) {
        const B = i.value.get(p);
        i.value.set(p, !B), p._showDetails = !B;
      }
    }, y = (p) => [
      p.class,
      p.thClass,
      {
        "b-table-sticky-column": p.stickyColumn
      },
      l.fieldColumnClass ? typeof l.fieldColumnClass == "function" ? l.fieldColumnClass(p) : l.fieldColumnClass : null
    ], h = (p, B) => {
      var g, S;
      return [
        p.class,
        p.tdClass,
        tt(B) && (g = B._cellVariants) != null && g[p.key] ? `table-${(S = B._cellVariants) == null ? void 0 : S[p.key]}` : null,
        {
          "b-table-sticky-column": p.stickyColumn
        }
      ];
    }, C = (p, B) => l.tbodyTrClass ? typeof l.tbodyTrClass == "function" ? l.tbodyTrClass(p, B) : l.tbodyTrClass : null;
    return (p, B) => (b(), N(dl, {
      id: n(l).id,
      bordered: n(l).bordered,
      borderless: n(l).borderless,
      "border-variant": n(l).borderVariant,
      "caption-top": n(l).captionTop,
      dark: n(l).dark,
      fixed: n(l).fixed,
      hover: n(l).hover,
      "no-border-collapse": n(l).noBorderCollapse,
      outlined: n(l).outlined,
      responsive: n(l).responsive,
      small: n(l).small,
      stacked: n(l).stacked,
      "sticky-header": n(l).stickyHeader,
      striped: n(l).striped,
      "table-class": u.value,
      variant: n(l).variant,
      "striped-columns": n(l).stripedColumns
    }, {
      default: I(() => [
        ct(be(kn, {
          variant: n(l).headVariant,
          class: D(n(l).theadClass)
        }, {
          default: I(() => [
            p.$slots["thead-top"] ? $(p.$slots, "thead-top", { key: 0 }) : te("", !0),
            be(at, {
              variant: n(l).headRowVariant,
              class: D(n(l).theadTrClass)
            }, {
              default: I(() => [
                (b(!0), O(pe, null, ke(r.value, (g) => (b(), N(Ma, K({
                  key: g.key,
                  scope: "col",
                  class: y(g),
                  title: g.headerTitle,
                  variant: g.variant,
                  abbr: g.headerAbbr,
                  style: g.thStyle,
                  ref_for: !0
                }, g.thAttr, {
                  onClick: (S) => m(g, S)
                }), {
                  default: I(() => [
                    $(p.$slots, p.$slots[`head(${String(g.key)})`] ? `head(${String(g.key)})` : "head()", {
                      label: g.label,
                      column: g.key,
                      field: g,
                      isFoot: !1
                    }, () => [
                      se(J(n(ea)(g)), 1)
                    ])
                  ]),
                  _: 2
                }, 1040, ["class", "title", "variant", "abbr", "style", "onClick"]))), 128))
              ]),
              _: 3
            }, 8, ["variant", "class"]),
            p.$slots["thead-sub"] ? (b(), N(at, { key: 1 }, {
              default: I(() => [
                (b(!0), O(pe, null, ke(r.value, (g) => (b(), N(xt, {
                  key: g.key,
                  scope: "col",
                  variant: g.variant,
                  class: D([g.class, g.thClass])
                }, {
                  default: I(() => [
                    $(p.$slots, "thead-sub", K({
                      items: r.value,
                      ref_for: !0
                    }, g), () => [
                      se(J(g.label), 1)
                    ])
                  ]),
                  _: 2
                }, 1032, ["variant", "class"]))), 128))
              ]),
              _: 3
            })) : te("", !0)
          ]),
          _: 3
        }, 8, ["variant", "class"]), [
          [Dt, c.value]
        ]),
        be(Cn, {
          class: D(n(l).tbodyClass)
        }, {
          default: I(() => [
            $(p.$slots, "custom-body", {
              fields: r.value,
              items: n(l).items,
              columns: r.value.length
            }, () => [
              !n(l).stacked && p.$slots["top-row"] ? (b(), N(at, { key: 0 }, {
                default: I(() => [
                  $(p.$slots, "top-row")
                ]),
                _: 3
              })) : te("", !0),
              (b(!0), O(pe, null, ke(n(l).items, (g, S) => (b(), O(pe, { key: S }, [
                be(at, {
                  class: D(C(g, "row")),
                  variant: n(tt)(g) ? g._rowVariant : void 0,
                  onClick: (w) => !n(Xt)(w) && t("row-clicked", g, S, w),
                  onDblclick: (w) => !n(Xt)(w) && t("row-dbl-clicked", g, S, w),
                  onMouseenter: (w) => !n(Xt)(w) && t("row-hovered", g, S, w),
                  onMouseleave: (w) => !n(Xt)(w) && t("row-unhovered", g, S, w)
                }, {
                  default: I(() => [
                    (b(!0), O(pe, null, ke(r.value, (w) => {
                      var x;
                      return b(), N(xt, K({
                        key: w.key,
                        variant: n(tt)(g) && (x = g._cellVariants) != null && x[w.key] ? null : w.variant,
                        class: h(w, g),
                        ref_for: !0
                      }, f(g, String(w.key), w.tdAttr)), {
                        default: I(() => [
                          n(l).stacked && n(l).labelStacked ? (b(), O("label", Yd, J(n(ea)(w)), 1)) : te("", !0),
                          $(
                            p.$slots,
                            p.$slots[`cell(${String(w.key)})`] ? `cell(${String(w.key)})` : "cell()",
                            {
                              value: n(Na)(g, String(w.key), w.formatter),
                              unformatted: n(Ee)(g, String(w.key)),
                              index: S,
                              item: g,
                              field: w,
                              items: p.items,
                              toggleDetails: () => {
                                v(g);
                              },
                              detailsShowing: n(tt)(g) ? i.value.get(g) ?? !1 : !1
                            },
                            () => [
                              !p.$slots[`cell(${String(w.key)})`] && !p.$slots["cell()"] ? (b(), O(pe, { key: 0 }, [
                                se(J(n(Na)(g, String(w.key), w.formatter)), 1)
                              ], 64)) : te("", !0)
                            ]
                          )
                        ]),
                        _: 2
                      }, 1040, ["variant", "class"]);
                    }), 128))
                  ]),
                  _: 2
                }, 1032, ["class", "variant", "onClick", "onDblclick", "onMouseenter", "onMouseleave"]),
                n(tt)(g) && i.value.get(g) === !0 && p.$slots["row-details"] ? (b(), O(pe, { key: 0 }, [
                  be(at, {
                    "aria-hidden": "true",
                    role: "presentation",
                    class: "d-none"
                  }),
                  be(at, {
                    class: D(C(g, "row-details")),
                    variant: g._rowVariant
                  }, {
                    default: I(() => [
                      be(xt, { colspan: d.value }, {
                        default: I(() => [
                          $(p.$slots, "row-details", {
                            item: g,
                            toggleDetails: () => {
                              v(g);
                            },
                            fields: n(l).fields,
                            index: S
                          })
                        ]),
                        _: 2
                      }, 1032, ["colspan"])
                    ]),
                    _: 2
                  }, 1032, ["class", "variant"])
                ], 64)) : te("", !0)
              ], 64))), 128)),
              n(l).showEmpty && n(l).items.length === 0 ? (b(), N(at, {
                key: 1,
                class: "b-table-empty-slot"
              }, {
                default: I(() => [
                  be(xt, { colspan: d.value }, {
                    default: I(() => [
                      $(p.$slots, "empty", {
                        items: n(l).items
                      }, () => [
                        se(J(n(l).emptyText), 1)
                      ])
                    ]),
                    _: 3
                  }, 8, ["colspan"])
                ]),
                _: 3
              })) : te("", !0),
              !n(l).stacked && p.$slots["bottom-row"] ? (b(), N(at, { key: 2 }, {
                default: I(() => [
                  $(p.$slots, "bottom-row")
                ]),
                _: 3
              })) : te("", !0)
            ])
          ]),
          _: 3
        }, 8, ["class"]),
        n(l).footClone ? (b(), N(Ha, {
          key: 0,
          variant: n(l).footVariant,
          class: D(n(l).tfootClass)
        }, {
          default: I(() => [
            be(at, {
              variant: n(l).footRowVariant,
              class: D(n(l).tfootTrClass)
            }, {
              default: I(() => [
                (b(!0), O(pe, null, ke(r.value, (g) => (b(), N(Ma, K({
                  key: g.key,
                  scope: "col",
                  class: y(g),
                  title: g.headerTitle,
                  abbr: g.headerAbbr,
                  style: g.thStyle,
                  variant: g.variant,
                  ref_for: !0
                }, g.thAttr, {
                  onClick: (S) => m(g, S, !0)
                }), {
                  default: I(() => [
                    Q("div", Zd, [
                      Q("div", null, [
                        $(
                          p.$slots,
                          p.$slots[`foot(${String(g.key)})`] ? `foot(${String(g.key)})` : "foot()",
                          {
                            label: g.label,
                            column: g.key,
                            field: g,
                            isFoot: !0
                          },
                          () => [
                            se(J(n(ea)(g)), 1)
                          ]
                        )
                      ])
                    ])
                  ]),
                  _: 2
                }, 1040, ["class", "title", "abbr", "style", "variant", "onClick"]))), 128))
              ]),
              _: 3
            }, 8, ["variant", "class"])
          ]),
          _: 3
        }, 8, ["variant", "class"])) : p.$slots["custom-foot"] ? (b(), N(Ha, { key: 1 }, {
          default: I(() => [
            $(p.$slots, "custom-foot", {
              fields: r.value,
              items: n(l).items,
              columns: r.value.length
            })
          ]),
          _: 3
        })) : te("", !0),
        p.$slots["table-caption"] || n(l).caption ? (b(), O("caption", Jd, [
          $(p.$slots, "table-caption", {}, () => [
            se(J(n(l).caption), 1)
          ])
        ])) : te("", !0)
      ]),
      _: 3
    }, 8, ["id", "bordered", "borderless", "border-variant", "caption-top", "dark", "fixed", "hover", "no-border-collapse", "outlined", "responsive", "small", "stacked", "sticky-header", "striped", "table-class", "variant", "striped-columns"]));
  }
}), Qd = /* @__PURE__ */ Q("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  fill: "currentColor",
  class: "bi bi-arrow-up-short",
  viewBox: "0 0 16 16",
  "aria-hidden": ""
}, [
  /* @__PURE__ */ Q("path", {
    "fill-rule": "evenodd",
    d: "M8 12a.5.5 0 0 0 .5-.5V5.707l2.146 2.147a.5.5 0 0 0 .708-.708l-3-3a.5.5 0 0 0-.708 0l-3 3a.5.5 0 1 0 .708.708L7.5 5.707V11.5a.5.5 0 0 0 .5.5z"
  })
], -1), ec = /* @__PURE__ */ Q("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  fill: "currentColor",
  class: "bi bi-arrow-down-short",
  viewBox: "0 0 16 16",
  "aria-hidden": ""
}, [
  /* @__PURE__ */ Q("path", {
    "fill-rule": "evenodd",
    d: "M8 4a.5.5 0 0 1 .5.5v5.793l2.146-2.147a.5.5 0 0 1 .708.708l-3 3a.5.5 0 0 1-.708 0l-3-3a.5.5 0 1 1 .708-.708L7.5 10.293V4.5A.5.5 0 0 1 8 4z"
  })
], -1), tc = {
  style: { opacity: 0.4 },
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  fill: "currentColor",
  class: "bi bi-arrow-up-short",
  viewBox: "0 0 16 16",
  "aria-hidden": ""
}, ac = /* @__PURE__ */ Q("path", {
  "fill-rule": "evenodd",
  d: "M8 12a.5.5 0 0 0 .5-.5V5.707l2.146 2.147a.5.5 0 0 0 .708-.708l-3-3a.5.5 0 0 0-.708 0l-3 3a.5.5 0 1 0 .708.708L7.5 5.707V11.5a.5.5 0 0 0 .5.5z"
}, null, -1), lc = [
  ac
], oc = { class: "d-flex align-items-center gap-2 mt-5" }, nc = /* @__PURE__ */ z({
  __name: "BTable",
  props: /* @__PURE__ */ ye({
    provider: { default: void 0 },
    noProvider: { default: void 0 },
    noProviderPaging: { type: Boolean, default: !1 },
    noProviderSorting: { type: Boolean, default: !1 },
    noProviderFiltering: { type: Boolean, default: !1 },
    sortBy: {},
    mustSort: { type: [Boolean, Array], default: !1 },
    selectable: { type: Boolean, default: !1 },
    multisort: { type: Boolean, default: !1 },
    stickySelect: { type: Boolean, default: !1 },
    selectHead: { type: [Boolean, String], default: !0 },
    selectMode: { default: "multi" },
    selectionVariant: { default: "primary" },
    busy: { type: Boolean },
    busyLoadingText: { default: "Loading..." },
    perPage: { default: Number.POSITIVE_INFINITY },
    currentPage: { default: 1 },
    filter: { default: void 0 },
    filterable: { default: void 0 },
    noLocalSorting: { type: Boolean, default: !1 },
    noSelectOnClick: { type: Boolean, default: !1 },
    selectedItems: {},
    noSortableIcon: { type: Boolean, default: !1 },
    align: { default: void 0 },
    caption: { default: void 0 },
    captionHtml: { default: void 0 },
    detailsTdClass: { default: void 0 },
    emptyFilteredText: { default: void 0 },
    emptyText: { default: void 0 },
    fieldColumnClass: { type: [Function, String, Object, Array], default: void 0 },
    fields: { default: () => [] },
    footClone: { type: Boolean, default: void 0 },
    footRowVariant: { default: void 0 },
    footVariant: { default: void 0 },
    headRowVariant: { default: void 0 },
    headVariant: { default: void 0 },
    items: { default: () => [] },
    labelStacked: { type: Boolean, default: void 0 },
    modelValue: { default: void 0 },
    primaryKey: { default: void 0 },
    showEmpty: { type: Boolean, default: void 0 },
    tbodyClass: { default: void 0 },
    tbodyTrAttrs: {},
    tbodyTrClass: { type: [Function, String, Object, Array], default: void 0 },
    tfootClass: { default: void 0 },
    tfootTrClass: { default: void 0 },
    theadClass: { default: void 0 },
    theadTrClass: { default: void 0 },
    bordered: { type: Boolean, default: void 0 },
    borderless: { type: Boolean, default: void 0 },
    borderVariant: { default: void 0 },
    captionTop: { type: Boolean, default: void 0 },
    dark: { type: Boolean, default: void 0 },
    fixed: { type: Boolean, default: void 0 },
    hover: { type: Boolean, default: void 0 },
    id: { default: void 0 },
    noBorderCollapse: { type: Boolean, default: void 0 },
    outlined: { type: Boolean, default: void 0 },
    responsive: { type: [Boolean, String], default: void 0 },
    small: { type: Boolean, default: void 0 },
    stacked: { type: [Boolean, String], default: void 0 },
    stickyHeader: { type: [Boolean, String, Number], default: void 0 },
    striped: { type: Boolean, default: void 0 },
    stripedColumns: { type: Boolean, default: void 0 },
    variant: { default: void 0 },
    tableAttrs: {}
  }, {
    sortBy: {
      default: void 0
    },
    sortByModifiers: {},
    busy: { type: Boolean, default: !1 },
    busyModifiers: {},
    selectedItems: {
      default: () => []
    },
    selectedItemsModifiers: {}
  }),
  emits: /* @__PURE__ */ ye(["filtered", "head-clicked", "row-clicked", "row-dbl-clicked", "row-hovered", "row-unhovered", "row-selected", "row-unselected", "sorted", "change"], ["update:sortBy", "update:busy", "update:selectedItems"]),
  setup(a, { expose: o, emit: e }) {
    const t = j(a, "BTable"), s = e, i = _e(a, "sortBy"), u = _e(a, "busy"), r = _e(a, "selectedItems"), d = _({
      get: () => /* @__PURE__ */ new Set([...r.value]),
      set: (T) => {
        r.value = [...T];
      }
    }), c = {
      add: (T) => {
        const A = new Set(d.value);
        A.add(T), d.value = A, s("row-selected", T);
      },
      clear: () => {
        d.value.forEach((T) => {
          c.delete(T);
        });
      },
      delete: (T) => {
        const A = new Set(d.value);
        if (t.primaryKey) {
          const E = t.primaryKey;
          r.value.forEach((M, Z) => {
            const R = Ee(M, E), H = Ee(T, E);
            R && H && R === H && A.delete(r.value[Z]);
          });
        } else
          A.delete(T);
        d.value = A, s("row-unselected", T);
      },
      set: (T) => {
        d.value = new Set(T), d.value.forEach((A) => {
          s("row-unselected", A);
        });
      },
      has: (T) => {
        if (!t.primaryKey)
          return d.value.has(T);
        const A = t.primaryKey;
        for (const E of d.value) {
          const M = Ee(E, A), Z = Ee(T, A);
          if (M && Z && M === Z)
            return !0;
        }
        return !1;
      }
    }, f = F([]), m = he(() => t.perPage, { method: "parseInt" }), v = he(() => t.currentPage, { method: "parseInt" }), y = k(() => !!t.filter), h = k(() => t.provider !== void 0), C = k(() => d.value.size > 0), p = _(
      () => i.value !== void 0 || t.fields.some(
        (T) => typeof T == "object" && T !== null && T.sortable === !0
      )
    ), B = _(
      () => t.fields.map((T) => {
        var M;
        if (!(typeof T == "object" && T !== null))
          return T;
        const A = (M = i.value) == null ? void 0 : M.find((Z) => T.key === Z.key), E = p.value === !1 ? void 0 : A === void 0 ? "none" : A.order === "desc" ? "descending" : A.order === "asc" ? "ascending" : "none";
        return {
          ...T,
          thAttr: {
            "aria-sort": E,
            ...T.thAttr
          }
        };
      })
    ), g = _(() => ({
      "b-table-busy": u.value,
      "b-table-selectable": t.selectable,
      "user-select-none": t.selectable && C.value
    })), S = _(() => [
      t.tbodyTrClass ? typeof t.tbodyTrClass == "function" ? t.tbodyTrClass(null, "table-busy") : t.tbodyTrClass : null
    ]), w = (T) => [
      {
        "b-table-sortable-column": p.value && T.sortable
      }
    ], x = (T, A) => [
      {
        [`selected table-${t.selectionVariant}`]: t.selectable && T && c.has(T)
      },
      t.tbodyTrClass ? typeof t.tbodyTrClass == "function" ? t.tbodyTrClass(T, A) : t.tbodyTrClass : null
    ], V = _(() => {
      const T = (M) => {
        var R;
        const Z = (R = i.value) == null ? void 0 : R.filter((H) => !!H.order);
        return !Z || Z.length === 0 ? M : [...M].sort((H, ce) => {
          for (let le = 0; le < (Z.length ?? 0); le++) {
            const q = Z[le], oe = (ie) => {
              if (!tt(ie))
                return String(ie);
              const ve = B.value.find((X) => zt(X) ? X.key === q.key : !1), L = Ee(ie, q.key);
              if (zt(ve) && ve.sortByFormatted) {
                const X = typeof ve.sortByFormatted == "function" ? ve.sortByFormatted : ve.formatter;
                if (X)
                  return Na(ie, String(ve.key), X);
              }
              return typeof L == "object" && L !== null ? JSON.stringify(L) : (L == null ? void 0 : L.toString()) ?? "";
            }, de = oe(H), ee = oe(ce), re = q.comparer ? q.comparer(de, ee) : de.localeCompare(ee, void 0, { numeric: !0 });
            if (re !== 0)
              return q.order === "asc" ? re : -re;
          }
          return 0;
        });
      }, A = (M) => M.filter(
        (Z) => tt(Z) ? Object.entries(Z).some(([R, H]) => {
          var q, oe, de;
          return H == null || R[0] === "_" || !((q = t.filterable) != null && q.includes(R)) && ((oe = t.filterable) != null && oe.length) ? !1 : (() => {
            const ee = B.value.find((re) => zt(re) ? re.key === R : !1);
            if (zt(ee) && ee.filterByFormatted) {
              const re = typeof ee.filterByFormatted == "function" ? ee.filterByFormatted : ee.formatter;
              if (re)
                return re(H, String(ee.key), Z);
            }
            return typeof H == "object" ? JSON.stringify(Object.values(H)) : H.toString();
          })().toLowerCase().includes(((de = t.filter) == null ? void 0 : de.toLowerCase()) ?? "");
        }) : !0
      );
      let E = h.value ? f.value : t.items;
      return E = E.map((M) => {
        if (typeof M == "object" && M !== null && Object.keys(M).some((Z) => Z.includes("."))) {
          let Z = {};
          for (const R in M)
            R.includes(".") ? Z = Pr(Z, R, M[R]) : Z[R] = M[R];
          return Z;
        }
        return M;
      }), (y.value === !0 && !h.value || y.value === !0 && h.value && t.noProviderFiltering) && (E = A(E)), (p.value === !0 && !h.value && !t.noLocalSorting || p.value === !0 && h.value && t.noProviderSorting) && (E = T(E)), E;
    }), G = _(() => Number.isNaN(m.value) || h.value && !t.noProviderPaging ? V.value : V.value.slice(
      (v.value - 1) * (m.value || Number.POSITIVE_INFINITY),
      v.value * (m.value || Number.POSITIVE_INFINITY)
    ));
    fe(G, (T) => {
      s("change", T);
    });
    const W = (T, A, E = !1, M = !1, Z = !1) => {
      if (t.selectable)
        if (t.selectMode === "single" || t.selectMode === "multi") {
          if (E || M)
            return;
          c.has(T) ? c.delete(T) : t.selectMode === "single" ? c.set([T]) : c.add(T);
        } else if (M || Z)
          c.has(T) ? c.delete(T) : c.add(T);
        else if (E) {
          const R = [...d.value].pop(), H = t.items.findIndex((oe) => oe === R), ce = Math.min(H, A), le = Math.max(H, A), q = t.items.slice(ce, le + 1);
          c.set(q);
        } else
          c.set([T]);
    }, P = (T, A, E) => {
      t.noSelectOnClick === !1 && W(T, A, E.shiftKey, E.ctrlKey, E.metaKey), s("row-clicked", T, A, E);
    }, Y = (T) => {
      var q, oe;
      if (!p.value)
        return;
      const A = typeof T == "object" && T !== null ? T.key : T, E = typeof T == "object" && T !== null ? T.sortable : !1;
      if (!(p.value === !0 && E === !0))
        return;
      const M = (de) => {
        if (de === "asc")
          return "desc";
        if (de === void 0 || t.mustSort === !0 || Array.isArray(t.mustSort) && t.mustSort.includes(A))
          return "asc";
      }, Z = ((q = i.value) == null ? void 0 : q.findIndex((de) => de.key === A)) ?? -1, R = (oe = i.value) == null ? void 0 : oe[Z], H = (
        // If value is new, we default to ascending
        // Otherwise we make a temp copy of the value
        Z === -1 || !R ? { key: A, order: "asc" } : { ...R }
      ), ce = () => {
        var ee, re;
        let de = H;
        if (Z === -1)
          i.value = [...i.value ?? [], H];
        else {
          const ie = M(H.order);
          de = { ...H, order: ie }, i.value = ie ? (ee = i.value) == null ? void 0 : ee.map((ve) => ve.key === de.key ? de : ve) : (re = i.value) == null ? void 0 : re.filter((ve) => ve.key !== de.key);
        }
        return de;
      }, le = () => {
        const de = {
          ...H,
          order: Z === -1 ? H.order : M(H.order)
        };
        return i.value = [de], de;
      };
      s("sorted", t.multisort === !0 ? ce() : le());
    }, ae = (T, A, E, M = !1) => {
      s("head-clicked", T, A, E, M), Y(A);
    }, ne = async () => {
      if (!h.value || t.provider === void 0 || u.value)
        return;
      u.value = !0;
      const T = t.provider({
        currentPage: v.value,
        filter: t.filter,
        sortBy: i.value,
        perPage: m.value
      });
      try {
        const A = T instanceof Promise ? await T : T;
        if (A === void 0)
          return;
        f.value = A;
      } finally {
        u.value = !1;
      }
    }, U = async (T, A, E) => {
      if (A === E)
        return;
      const M = (ce) => {
        var le;
        return ((le = t.noProvider) == null ? void 0 : le.includes(ce)) === !0;
      }, Z = (T === "currentPage" || T === "perPage") && (M("paging") || t.noProviderPaging === !0), R = T === "filter" && (M("filtering") || t.noProviderFiltering === !0), H = (T === "sortBy" || T === "sortDesc") && (M("sorting") || t.noProviderSorting === !0);
      Z || R || H || (h.value === !0 && await ne(), T === "currentPage" || T === "perPage" || s("filtered", [...V.value]));
    };
    return fe(
      () => t.filter,
      (T, A) => {
        U("filter", T, A), !(T === A || h.value) && (T || s("filtered", [...V.value]));
      }
    ), fe(v, (T, A) => {
      U("currentPage", T, A);
    }), fe(m, (T, A) => {
      U("perPage", T, A);
    }), fe(
      i,
      (T, A) => {
        U("sortBy", T, A);
      },
      { deep: !0 }
    ), fe(
      () => t.provider,
      (T) => {
        if (T === void 0) {
          f.value = [];
          return;
        }
        ne();
      }
    ), Ue(ne), o({
      // The row selection methods are really for compat. Users should probably use the v-model though
      clearSelected: () => {
        t.selectable && c.clear();
      },
      refresh: ne,
      selectAllRows: () => {
        if (!t.selectable)
          return;
        const T = d.value.size > 0 ? [...d.value] : [];
        d.value = /* @__PURE__ */ new Set([...V.value]), d.value.forEach((A) => {
          T.includes(A) || s("row-selected", A);
        });
      },
      selectRow: (T) => {
        if (!t.selectable)
          return;
        const A = V.value[T];
        !A || c.has(A) || c.add(A);
      },
      unselectRow: (T) => {
        if (!t.selectable)
          return;
        const A = V.value[T];
        !A || !c.has(A) || c.delete(A);
      },
      isRowSelected: (T) => {
        if (!t.selectable)
          return !1;
        const A = V.value[T];
        return c.has(A);
      }
    }), (T, A) => (b(), N(Tn, K(n(t), {
      "aria-busy": u.value,
      items: G.value,
      fields: B.value,
      "table-class": g.value,
      "tbody-tr-class": x,
      "field-column-class": w,
      onHeadClicked: ae,
      onRowDblClicked: A[0] || (A[0] = (E, M, Z) => {
        s("row-dbl-clicked", E, M, Z);
      }),
      onRowClicked: P,
      onRowHovered: A[1] || (A[1] = (E, M, Z) => {
        s("row-hovered", E, M, Z);
      }),
      onRowUnhovered: A[2] || (A[2] = (E, M, Z) => {
        s("row-unhovered", E, M, Z);
      })
    }), ja({
      "head()": I((E) => {
        var M, Z, R, H;
        return [
          se(J(n(ea)(E.field)) + " ", 1),
          p.value && E.field.sortable && n(t).noSortableIcon === !1 ? (b(), O(pe, { key: 0 }, [
            ((Z = (M = i.value) == null ? void 0 : M.find((ce) => ce.key === E.field.key)) == null ? void 0 : Z.order) === "asc" ? $(
              T.$slots,
              T.$slots[`sortAsc(${String(E.field.key)})`] ? `sortAsc(${String(E.field.key)})` : "sortAsc()",
              Be(K({ key: 0 }, { ...E })),
              () => [
                Qd
              ]
            ) : ((H = (R = i.value) == null ? void 0 : R.find((ce) => ce.key === E.field.key)) == null ? void 0 : H.order) === "desc" ? $(
              T.$slots,
              T.$slots[`sortDesc(${String(E.field.key)})`] ? `sortDesc(${String(E.field.key)})` : "sortDesc()",
              Be(K({ key: 1 }, { ...E })),
              () => [
                ec
              ]
            ) : $(
              T.$slots,
              T.$slots[`sortDefault(${String(E.field.key)})`] ? `sortDefault(${String(E.field.key)})` : "sortDefault()",
              Be(K({ key: 2 }, { ...E })),
              () => [
                (b(), O("svg", tc, lc))
              ]
            )
          ], 64)) : te("", !0)
        ];
      }),
      "custom-body": I((E) => [
        u.value ? (b(), N(at, {
          key: 0,
          class: D(["b-table-busy-slot", S.value])
        }, {
          default: I(() => [
            be(xt, {
              colspan: E.fields.length
            }, {
              default: I(() => [
                $(T.$slots, "table-busy", {}, () => [
                  be(Ba, { show: "" }, {
                    overlay: I(() => [
                      Q("div", oc, [
                        be(ha),
                        Q("strong", null, J(n(t).busyLoadingText), 1)
                      ])
                    ]),
                    _: 1
                  })
                ])
              ]),
              _: 2
            }, 1032, ["colspan"])
          ]),
          _: 2
        }, 1032, ["class"])) : te("", !0)
      ]),
      _: 2
    }, [
      ke(T.$slots, (E, M) => ({
        name: M,
        fn: I((Z) => [
          $(T.$slots, M, Be(Ce(Z)))
        ])
      }))
    ]), 1040, ["aria-busy", "items", "fields", "table-class"]));
  }
}), sc = /* @__PURE__ */ z({
  inheritAttrs: !1,
  __name: "BTab",
  props: /* @__PURE__ */ ye({
    active: { type: Boolean },
    buttonId: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    id: { default: void 0 },
    lazy: { type: Boolean, default: void 0 },
    lazyOnce: { type: Boolean, default: void 0 },
    noBody: { type: Boolean, default: !1 },
    tag: { default: "div" },
    title: { default: void 0 },
    titleItemClass: { default: void 0 },
    titleLinkAttrs: { default: void 0 },
    titleLinkClass: { default: void 0 }
  }, {
    active: { type: Boolean, default: !1 },
    activeModifiers: {}
  }),
  emits: ["update:active"],
  setup(a) {
    const e = j(a, "BTab"), l = Re(), t = _e(a, "active"), s = Ve(Co, null), i = we(() => e.id, "tabpane"), u = we(() => e.buttonId, "tab"), r = F(!1), d = F(null), { onClick: c, ...f } = Mt(), m = _(
      () => ({
        id: i.value,
        buttonId: u.value,
        disabled: e.disabled,
        title: e.title,
        titleComponent: l.title,
        titleItemClass: e.titleItemClass,
        titleLinkAttrs: e.titleLinkAttrs,
        titleLinkClass: e.titleLinkClass,
        onClick: c,
        el: d.value
      })
    );
    Ue(() => {
      s && (s.registerTab(m), e.active && s.activateTab(i.value));
    }), Fn(() => {
      s && s.unregisterTab(i.value);
    });
    const v = k(() => (s == null ? void 0 : s.activeId.value) === i.value), y = F(v.value), h = k(() => !!(s != null && s.lazy.value || (e.lazyOnce ?? e.lazy))), C = k(() => e.lazyOnce !== void 0), p = k(() => v.value && !e.disabled), B = k(
      () => p.value || !h.value || h.value && C.value && r.value
    );
    fe(v, (S) => {
      if (S) {
        t.value = !0, setTimeout(() => {
          y.value = !0;
        }, 0);
        return;
      }
      y.value = !1, t.value = !1;
    }), fe(
      () => e.active,
      (S) => {
        if (s) {
          if (!S) {
            v.value && s.activateTab(void 0);
            return;
          }
          s.activateTab(i.value);
        }
      }
    );
    const g = _(() => [
      {
        active: v.value,
        show: y.value,
        "card-body": (s == null ? void 0 : s.card.value) && e.noBody === !1,
        fade: !(s != null && s.noFade.value)
      },
      y.value ? s == null ? void 0 : s.activeTabClass : s == null ? void 0 : s.inactiveTabClass,
      s == null ? void 0 : s.tabClass
    ]);
    return fe(B, (S) => {
      S && !r.value && (r.value = !0);
    }), (S, w) => (b(), N(ue(n(e).tag), K({
      id: n(i),
      ref_key: "el",
      ref: d,
      class: ["tab-pane", g.value],
      role: "tabpanel",
      "aria-labelledby": n(u)
    }, f), {
      default: I(() => [
        B.value ? $(S.$slots, "default", { key: 0 }) : te("", !0)
      ]),
      _: 3
    }, 16, ["id", "class", "aria-labelledby"]));
  }
}), rc = ["aria-orientation"], ic = ["id", "aria-controls", "aria-selected", "onClick"], uc = /* @__PURE__ */ z({
  __name: "BTabs",
  props: /* @__PURE__ */ ye({
    activeId: {},
    activeNavItemClass: { default: void 0 },
    activeTabClass: { default: void 0 },
    align: { default: void 0 },
    card: { type: Boolean, default: !1 },
    contentClass: { default: void 0 },
    end: { type: Boolean, default: !1 },
    fill: { type: Boolean, default: !1 },
    id: { default: void 0 },
    inactiveNavItemClass: { default: void 0 },
    inactiveTabClass: { default: void 0 },
    justified: { type: Boolean, default: !1 },
    lazy: { type: Boolean, default: !1 },
    modelValue: {},
    navClass: { default: void 0 },
    navItemClass: { default: void 0 },
    navWrapperClass: { default: void 0 },
    noFade: { type: Boolean, default: !1 },
    noNavStyle: { type: Boolean, default: !1 },
    pills: { type: Boolean, default: !1 },
    small: { type: Boolean, default: !1 },
    tag: { default: "div" },
    tabClass: { default: void 0 },
    vertical: { type: Boolean, default: !1 }
  }, {
    modelValue: {
      default: -1
    },
    modelModifiers: {},
    activeId: {
      default: void 0
    },
    activeIdModifiers: {}
  }),
  emits: /* @__PURE__ */ ye(["activate-tab", "click"], ["update:modelValue", "update:activeId"]),
  setup(a, { emit: o }) {
    const l = j(a, "BTabs"), t = o, s = _e(a, "modelValue"), i = _e(a, "activeId"), u = ia(), r = F([]), d = _(
      () => r.value.map((w) => {
        const x = n(w), V = x.id === i.value;
        return {
          ...x,
          active: V,
          navItemClasses: [
            {
              active: V,
              disabled: x.disabled
            },
            V ? l.activeNavItemClass : l.inactiveNavItemClass,
            l.navItemClass,
            x.titleLinkClass
          ]
        };
      })
    ), c = k(() => !(d != null && d.value && d.value.length > 0)), f = _(() => ({
      "d-flex": l.vertical,
      "align-items-start": l.vertical
    })), m = jt(() => l.align), v = _(() => ({
      "nav-pills": l.pills,
      "flex-column me-3": l.vertical,
      [m.value]: l.align !== void 0,
      "nav-fill": l.fill,
      "card-header-tabs": l.card,
      "nav-justified": l.justified,
      "nav-tabs": !l.noNavStyle && !l.pills,
      small: l.small
    })), y = (w) => {
      var x;
      if (w !== void 0) {
        const V = (x = d.value[w]) == null ? void 0 : x.id;
        if (w > -1 && w < d.value.length && !d.value[w].disabled && (s.value < 0 || i.value !== V || s.value !== w)) {
          const G = new rt("activate-tab", { cancelable: !0 });
          t("activate-tab", w, s.value, G), G.defaultPrevented || (i.value !== V && (i.value = V), s.value !== w && (s.value = w));
        }
      }
    }, h = (w, x) => {
      var V, G, W;
      y(x), x >= 0 && !d.value[x].disabled && ((V = d.value[x]) != null && V.onClick) && typeof d.value[x].onClick == "function" && ((W = (G = d.value[x]).onClick) == null || W.call(G, w));
    }, C = (w) => {
      var x, V;
      d.value.length <= 0 || (s.value = p(s.value + w, w), (V = document.getElementById((x = d.value[s.value]) == null ? void 0 : x.buttonId)) == null || V.focus());
    }, p = (w, x) => {
      let V = w, G = -1, W = -1;
      for (let P = 0; P < d.value.length; P++)
        d.value[P].disabled || (G === -1 && (G = P), W = P);
      for (; V >= G && V <= W && d.value[V].disabled; )
        V += x;
      return V < G && (V = G), V > W && (V = W), V;
    };
    fe(s, (w, x) => {
      if (w === x || d.value.length <= 0)
        return;
      const V = p(w, w > x ? 1 : -1);
      Ie(() => {
        y(V);
      });
    }), fe(i, (w, x) => {
      const V = d.value.findIndex((G) => G.id === w);
      if (w !== x && !(d.value.length <= 0)) {
        if (V === -1) {
          y(p(0, 1));
          return;
        }
        y(V);
      }
    });
    const B = (w) => {
      r.value.find((x) => x.value.id === w.value.id) ? r.value[r.value.findIndex((x) => x.value.id === w.value.id)] = w : r.value.push(w), r.value.sort((x, V) => {
        if (!Node || !x.value.el || !V.value.el)
          return 0;
        const G = x.value.el.compareDocumentPosition(V.value.el);
        return G & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : G & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
      });
    }, g = (w) => {
      r.value = r.value.filter((x) => x.value.id !== w);
    };
    fe(
      r,
      () => {
        S();
      },
      { deep: !0 }
    );
    const S = () => {
      var w;
      if (d.value.length === 0) {
        s.value = -1, i.value = void 0;
        return;
      }
      if (s.value >= 0 && !i.value && (i.value = (w = d.value[s.value]) == null ? void 0 : w.id), d.value.find((x) => x.id === i.value)) {
        y(d.value.findIndex((x) => x.id === i.value));
        return;
      }
      y(d.value.map((x) => !x.disabled).indexOf(!0));
    };
    return Xe(Co, {
      lazy: k(() => l.lazy),
      card: k(() => l.card),
      noFade: k(() => l.noFade),
      activeTabClass: k(() => l.activeTabClass),
      inactiveTabClass: k(() => l.inactiveTabClass),
      tabClass: k(() => l.tabClass),
      registerTab: B,
      unregisterTab: g,
      activeId: i,
      activateTab: (w) => {
        const x = d.value.findIndex((V) => V.id === w);
        if (w === void 0 || x === -1) {
          y(p(0, 1));
          return;
        }
        y(x);
      }
    }), (w, x) => (b(), N(ue(n(l).tag), {
      id: n(l).id,
      class: D(["tabs", f.value])
    }, {
      default: I(() => [
        be(n(u).define, null, {
          default: I(() => [
            Q("div", {
              class: D(["tab-content", n(l).contentClass])
            }, [
              $(w.$slots, "default"),
              c.value ? (b(), O("div", {
                key: "bv-empty-tab",
                class: D(["tab-pane active", { "card-body": n(l).card }])
              }, [
                $(w.$slots, "empty")
              ], 2)) : te("", !0)
            ], 2)
          ]),
          _: 3
        }),
        n(l).end ? (b(), N(n(u).reuse, { key: 0 })) : te("", !0),
        Q("div", {
          class: D([
            n(l).navWrapperClass,
            { "card-header": n(l).card, "ms-auto": w.vertical && n(l).end }
          ])
        }, [
          Q("ul", {
            class: D(["nav", [v.value, n(l).navClass]]),
            role: "tablist",
            "aria-orientation": n(l).vertical ? "vertical" : "horizontal"
          }, [
            $(w.$slots, "tabs-start"),
            (b(!0), O(pe, null, ke(d.value, (V, G) => (b(), O("li", {
              key: V.id,
              class: D(["nav-item", V.titleItemClass]),
              role: "presentation"
            }, [
              Q("button", K({
                id: V.buttonId,
                class: ["nav-link", V.navItemClasses],
                role: "tab",
                "aria-controls": V.id,
                "aria-selected": V.active,
                ref_for: !0
              }, V.titleLinkAttrs, {
                onKeydown: [
                  x[0] || (x[0] = Ut(bt((W) => C(-1), ["stop", "prevent"]), ["left"])),
                  x[1] || (x[1] = Ut(bt((W) => C(1), ["stop", "prevent"]), ["right"])),
                  x[2] || (x[2] = Ut(bt((W) => C(-999), ["stop", "prevent"]), ["page-up"])),
                  x[3] || (x[3] = Ut(bt((W) => C(999), ["stop", "prevent"]), ["page-down"]))
                ],
                onClick: bt((W) => h(W, G), ["stop", "prevent"])
              }), [
                V.titleComponent ? (b(), N(ue(V.titleComponent), { key: 0 })) : (b(), O(pe, { key: 1 }, [
                  se(J(V.title), 1)
                ], 64))
              ], 16, ic)
            ], 2))), 128)),
            $(w.$slots, "tabs-end")
          ], 10, rc)
        ], 2),
        n(l).end ? te("", !0) : (b(), N(n(u).reuse, { key: 1 }))
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), dc = { id: "__BVID__toaster-container" }, cc = /* @__PURE__ */ z({
  __name: "BToastOrchestrator",
  props: {
    appendToast: { type: Boolean, default: !1 },
    teleportDisabled: { default: !1 },
    teleportTo: { default: "body" }
  },
  setup(a, { expose: o }) {
    const l = j(a, "BToastOrchestrator"), { remove: t, toasts: s, show: i, _setIsAppend: u, leave: r } = Jo();
    fe(
      () => l.appendToast,
      (c) => {
        u == null || u(c);
      },
      { immediate: !0 }
    );
    const d = (c) => ga(c, ["_modelValue", "_self", "pos"]);
    return o({
      remove: t,
      show: i,
      toasts: s
    }), (c, f) => (b(), N(Bt, {
      to: n(l).teleportTo,
      disabled: n(l).teleportDisabled
    }, [
      Q("div", dc, [
        (b(!0), O(pe, null, ke(n(Nr), (m, v) => (b(), O("div", {
          key: v,
          class: D([m, "toast-container position-fixed p-3"])
        }, [
          be(ql, { name: "b-list" }, {
            default: I(() => {
              var y;
              return [
                (b(!0), O(pe, null, ke((y = n(s)) == null ? void 0 : y.filter((h) => h.value.props.pos === v), (h) => (b(), N(ue(h.value.component), K({
                  key: h.value.props._self,
                  ref_for: !0
                }, d(h.value.props), {
                  "model-value": h.value.props._modelValue,
                  "trans-props": { ...h.value.props.transProps, appear: !0 },
                  "onUpdate:modelValue": (C) => {
                    var p;
                    return (p = n(r)) == null ? void 0 : p(h.value.props._self);
                  },
                  onHide: (C) => {
                    var p;
                    return (p = n(t)) == null ? void 0 : p(h.value.props._self);
                  }
                }), null, 16, ["model-value", "trans-props", "onUpdate:modelValue", "onHide"]))), 128))
              ];
            }),
            _: 2
          }, 1024)
        ], 2))), 128))
      ])
    ], 8, ["to", "disabled"]));
  }
}), fc = /* @__PURE__ */ z({
  __name: "BTooltip",
  props: /* @__PURE__ */ ye({
    interactive: { type: Boolean, default: void 0 },
    boundary: {},
    boundaryPadding: {},
    click: { type: Boolean, default: void 0 },
    content: { default: void 0 },
    customClass: { default: void 0 },
    delay: { default: void 0 },
    floatingMiddleware: { default: void 0 },
    html: { type: Boolean, default: void 0 },
    id: { default: void 0 },
    inline: { type: Boolean, default: void 0 },
    manual: { type: Boolean, default: void 0 },
    modelValue: { type: Boolean },
    noAutoClose: { type: Boolean, default: void 0 },
    noFade: { type: Boolean, default: void 0 },
    noFlip: { type: Boolean, default: void 0 },
    noHide: { type: Boolean, default: void 0 },
    noShift: { type: Boolean, default: void 0 },
    noSize: { type: Boolean },
    noninteractive: { type: Boolean, default: void 0 },
    offset: { default: void 0 },
    placement: { default: void 0 },
    persistent: { type: Boolean },
    realtime: { type: Boolean, default: void 0 },
    reference: { default: void 0 },
    strategy: { default: void 0 },
    target: { default: void 0 },
    title: { default: void 0 },
    variant: { default: void 0 },
    teleportDisabled: { default: void 0 },
    teleportTo: { default: void 0 }
  }, {
    modelValue: { type: Boolean, default: void 0 },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(a, { expose: o }) {
    var u, r, d;
    const l = j(a, "BTooltip"), t = _e(a, "modelValue"), s = _(() => {
      const { interactive: c, noninteractive: f, ...m } = l;
      return { noninteractive: f !== void 0 ? f : !c, ...m };
    }), i = F(null);
    return o({
      hide: (u = i.value) == null ? void 0 : u.hide,
      show: (r = i.value) == null ? void 0 : r.show,
      toggle: (d = i.value) == null ? void 0 : d.toggle
    }), (c, f) => (b(), N(tl, K({
      ref_key: "popover",
      ref: i
    }, s.value, {
      modelValue: t.value,
      "onUpdate:modelValue": f[0] || (f[0] = (m) => t.value = m),
      tooltip: ""
    }), ja({ _: 2 }, [
      ke(c.$slots, (m, v) => ({
        name: v,
        fn: I((y) => [
          $(c.$slots, v, Be(Ce(y)))
        ])
      }))
    ]), 1040, ["modelValue"]));
  }
}), la = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BAccordion: ii,
  BAccordionItem: di,
  BAlert: fi,
  BAvatar: bi,
  BAvatarGroup: yi,
  BBadge: on,
  BBreadcrumb: Bi,
  BBreadcrumbItem: nn,
  BButton: pt,
  BButtonGroup: _i,
  BButtonToolbar: Ci,
  BCard: vn,
  BCardBody: cn,
  BCardFooter: fn,
  BCardGroup: Ti,
  BCardHeader: rn,
  BCardImg: il,
  BCardSubtitle: dn,
  BCardText: $i,
  BCardTitle: un,
  BCarousel: Ii,
  BCarouselSlide: Ri,
  BCloseButton: Et,
  BCol: Lt,
  BCollapse: ln,
  BContainer: Hi,
  BDropdown: pn,
  BDropdownDivider: Wi,
  BDropdownForm: Gi,
  BDropdownGroup: Ki,
  BDropdownHeader: Zi,
  BDropdownItem: Ji,
  BDropdownItemButton: tu,
  BDropdownText: lu,
  BForm: mn,
  BFormCheckbox: bn,
  BFormCheckboxGroup: fu,
  BFormFile: mu,
  BFormFloatingLabel: ru,
  BFormGroup: Cu,
  BFormInput: Ol,
  BFormInvalidFeedback: Ea,
  BFormRadio: gn,
  BFormRadioGroup: Vu,
  BFormRow: aa,
  BFormSelect: Eu,
  BFormSelectOption: ul,
  BFormSelectOptionGroup: hn,
  BFormSpinbutton: Ru,
  BFormTag: Bn,
  BFormTags: ed,
  BFormText: Fa,
  BFormTextarea: ad,
  BFormValidFeedback: La,
  BImg: rl,
  BInput: Ol,
  BInputGroup: ud,
  BInputGroupText: dd,
  BLink: st,
  BListGroup: cd,
  BListGroupItem: fd,
  BModal: Ia,
  BModalOrchestrator: pd,
  BNav: md,
  BNavForm: yd,
  BNavItem: hd,
  BNavItemDropdown: _d,
  BNavText: Cd,
  BNavbar: kd,
  BNavbarBrand: Td,
  BNavbarNav: $d,
  BNavbarToggle: Ed,
  BOffcanvas: zd,
  BOverlay: Ba,
  BPagination: Hd,
  BPlaceholder: Ke,
  BPlaceholderButton: wn,
  BPlaceholderCard: Md,
  BPlaceholderTable: jd,
  BPlaceholderWrapper: Wd,
  BPopover: tl,
  BProgress: en,
  BProgressBar: Qo,
  BRow: qd,
  BSpinner: ha,
  BTab: sc,
  BTable: nc,
  BTableLite: Tn,
  BTableSimple: dl,
  BTabs: uc,
  BTbody: Cn,
  BTd: xt,
  BTfoot: Ha,
  BTh: Ma,
  BThead: kn,
  BToast: tn,
  BToastOrchestrator: cc,
  BTooltip: fc,
  BTr: at,
  BTransition: qt
}, Symbol.toStringTag, { value: "Module" })), mc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  useBreadcrumb: zo,
  useColorMode: Ir,
  useModal: Dr,
  useModalController: Ko,
  useScrollspy: Zo,
  useToast: Jo
}, Symbol.toStringTag, { value: "Module" })), bc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BvCarouselEvent: Gl,
  BvEvent: rt,
  BvTriggerableEvent: _t
}, Symbol.toStringTag, { value: "Module" })), yc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), $n = (a) => a.toLowerCase().startsWith("v") ? a.slice(1) : a, gc = ({
  components: a = !1,
  directives: o = !1,
  plugins: e = {},
  aliases: l = {}
} = {}) => ({
  install(t) {
    const s = typeof a == "boolean" ? { all: a } : a, i = Object.keys(la);
    va(s, i).forEach((d) => {
      const c = la[d];
      t.component(d, c);
    });
    const u = typeof o == "boolean" ? { all: o } : o, r = Object.keys(Ra);
    va(u, r).forEach((d) => {
      const c = $n(d), f = Ra[d];
      t.directive(c, f);
    }), Object.entries(l).forEach(([d, c]) => {
      const f = typeof c == "string" ? la[c] : c;
      t.component(d, f);
    }), ((e == null ? void 0 : e.breadcrumb) ?? !0) && t.use(Zr), (((e == null ? void 0 : e.id) ?? !0) || typeof e.id == "object") && t.use(Jr, e), ((e == null ? void 0 : e.modalController) ?? !0) && t.use(li), ((e == null ? void 0 : e.modalManager) ?? !0) && t.use(oi), (((e == null ? void 0 : e.rtl) ?? !0) || typeof e.rtl == "object") && t.use(ni, e), ((e == null ? void 0 : e.toast) ?? !0) && t.use(Yr), t.use(si, e);
  }
}), hc = ({
  aliases: a = {},
  directives: o = !0,
  components: e = !0
} = {}) => {
  const l = typeof e == "boolean" ? { all: e } : e, t = Object.keys(la), s = new Set(va(l, t)), i = typeof o == "boolean" ? { all: o } : o, u = Object.keys(Ra), r = new Set(va(i, u).map($n));
  return [
    {
      type: "component",
      resolve: (c) => {
        if (s.has(c) || a[c])
          return {
            name: a[c] || c,
            from: "bootstrap-vue-next"
          };
      }
    },
    {
      type: "directive",
      resolve: (c) => {
        if (r.has(c))
          return {
            name: `v${c}`,
            from: "bootstrap-vue-next"
          };
      }
    }
  ];
};
export {
  ii as BAccordion,
  di as BAccordionItem,
  fi as BAlert,
  bi as BAvatar,
  yi as BAvatarGroup,
  on as BBadge,
  Bi as BBreadcrumb,
  nn as BBreadcrumbItem,
  pt as BButton,
  _i as BButtonGroup,
  Ci as BButtonToolbar,
  vn as BCard,
  cn as BCardBody,
  fn as BCardFooter,
  Ti as BCardGroup,
  rn as BCardHeader,
  il as BCardImg,
  dn as BCardSubtitle,
  $i as BCardText,
  un as BCardTitle,
  Ii as BCarousel,
  Ri as BCarouselSlide,
  Et as BCloseButton,
  Lt as BCol,
  ln as BCollapse,
  Hi as BContainer,
  pn as BDropdown,
  Wi as BDropdownDivider,
  Gi as BDropdownForm,
  Ki as BDropdownGroup,
  Zi as BDropdownHeader,
  Ji as BDropdownItem,
  tu as BDropdownItemButton,
  lu as BDropdownText,
  mn as BForm,
  bn as BFormCheckbox,
  fu as BFormCheckboxGroup,
  mu as BFormFile,
  ru as BFormFloatingLabel,
  Cu as BFormGroup,
  Ol as BFormInput,
  Ea as BFormInvalidFeedback,
  gn as BFormRadio,
  Vu as BFormRadioGroup,
  aa as BFormRow,
  Eu as BFormSelect,
  ul as BFormSelectOption,
  hn as BFormSelectOptionGroup,
  Ru as BFormSpinbutton,
  Bn as BFormTag,
  ed as BFormTags,
  Fa as BFormText,
  ad as BFormTextarea,
  La as BFormValidFeedback,
  rl as BImg,
  Ol as BInput,
  ud as BInputGroup,
  dd as BInputGroupText,
  st as BLink,
  cd as BListGroup,
  fd as BListGroupItem,
  Ia as BModal,
  pd as BModalOrchestrator,
  md as BNav,
  yd as BNavForm,
  hd as BNavItem,
  _d as BNavItemDropdown,
  Cd as BNavText,
  kd as BNavbar,
  Td as BNavbarBrand,
  $d as BNavbarNav,
  Ed as BNavbarToggle,
  zd as BOffcanvas,
  Ba as BOverlay,
  Hd as BPagination,
  Ke as BPlaceholder,
  wn as BPlaceholderButton,
  Md as BPlaceholderCard,
  jd as BPlaceholderTable,
  Wd as BPlaceholderWrapper,
  tl as BPopover,
  en as BProgress,
  Qo as BProgressBar,
  qd as BRow,
  ha as BSpinner,
  sc as BTab,
  nc as BTable,
  Tn as BTableLite,
  dl as BTableSimple,
  uc as BTabs,
  Cn as BTbody,
  xt as BTd,
  Ha as BTfoot,
  Ma as BTh,
  kn as BThead,
  tn as BToast,
  cc as BToastOrchestrator,
  fc as BTooltip,
  at as BTr,
  qt as BTransition,
  hc as BootstrapVueNextResolver,
  Gl as BvCarouselEvent,
  rt as BvEvent,
  _t as BvTriggerableEvent,
  la as Components,
  mc as Composables,
  Ra as Directives,
  yc as Types,
  bc as Utils,
  gc as createBootstrap,
  gc as default,
  zo as useBreadcrumb,
  Ir as useColorMode,
  Dr as useModal,
  Ko as useModalController,
  Zo as useScrollspy,
  Jo as useToast,
  xd as vBColorMode,
  za as vBModal,
  Ad as vBPopover,
  Od as vBScrollspy,
  za as vBToggle,
  Pd as vBTooltip
};
//# sourceMappingURL=bootstrap-vue-next.mjs.map
